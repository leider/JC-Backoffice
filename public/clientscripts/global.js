if (function(global, factory) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function(w) {
        if (!w.document) throw new Error("jQuery requires a window with a document");
        return factory(w);
    } : factory(global);
}("undefined" != typeof window ? window : this, function(window, noGlobal) {
    "use strict";
    function DOMEval(code, doc) {
        doc = doc || document;
        var script = doc.createElement("script");
        script.text = code, doc.head.appendChild(script).parentNode.removeChild(script);
    }
    function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = jQuery.type(obj);
        return "function" !== type && !jQuery.isWindow(obj) && ("array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj);
    }
    function winnow(elements, qualifier, not) {
        return jQuery.isFunction(qualifier) ? jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
        }) : qualifier.nodeType ? jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
        }) : "string" != typeof qualifier ? jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
        }) : risSimple.test(qualifier) ? jQuery.filter(qualifier, elements, not) : (qualifier = jQuery.filter(qualifier, elements), 
        jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not && 1 === elem.nodeType;
        }));
    }
    function sibling(cur, dir) {
        for (;(cur = cur[dir]) && 1 !== cur.nodeType; ) ;
        return cur;
    }
    function createOptions(options) {
        var object = {};
        return jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
            object[flag] = !0;
        }), object;
    }
    function Identity(v) {
        return v;
    }
    function Thrower(ex) {
        throw ex;
    }
    function adoptValue(value, resolve, reject) {
        var method;
        try {
            value && jQuery.isFunction(method = value.promise) ? method.call(value).done(resolve).fail(reject) : value && jQuery.isFunction(method = value.then) ? method.call(value, resolve, reject) : resolve.call(void 0, value);
        } catch (value) {
            reject.call(void 0, value);
        }
    }
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed), window.removeEventListener("load", completed), 
        jQuery.ready();
    }
    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }
    function getData(data) {
        return "true" === data || "false" !== data && ("null" === data ? null : data === +data + "" ? +data : rbrace.test(data) ? JSON.parse(data) : data);
    }
    function dataAttr(elem, key, data) {
        var name;
        if (void 0 === data && 1 === elem.nodeType) if (name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase(), 
        data = elem.getAttribute(name), "string" == typeof data) {
            try {
                data = getData(data);
            } catch (e) {}
            dataUser.set(elem, key, data);
        } else data = void 0;
        return data;
    }
    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        } : function() {
            return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || "px" !== unit && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
            unit = unit || initialInUnit[3], valueParts = valueParts || [], initialInUnit = +initial || 1;
            do scale = scale || ".5", initialInUnit /= scale, jQuery.style(elem, prop, initialInUnit + unit); while (scale !== (scale = currentValue() / initial) && 1 !== scale && --maxIterations);
        }
        return valueParts && (initialInUnit = +initialInUnit || +initial || 0, adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2], 
        tween && (tween.unit = unit, tween.start = initialInUnit, tween.end = adjusted)), 
        adjusted;
    }
    function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
        return display ? display : (temp = doc.body.appendChild(doc.createElement(nodeName)), 
        display = jQuery.css(temp, "display"), temp.parentNode.removeChild(temp), "none" === display && (display = "block"), 
        defaultDisplayMap[nodeName] = display, display);
    }
    function showHide(elements, show) {
        for (var display, elem, values = [], index = 0, length = elements.length; index < length; index++) elem = elements[index], 
        elem.style && (display = elem.style.display, show ? ("none" === display && (values[index] = dataPriv.get(elem, "display") || null, 
        values[index] || (elem.style.display = "")), "" === elem.style.display && isHiddenWithinTree(elem) && (values[index] = getDefaultDisplay(elem))) : "none" !== display && (values[index] = "none", 
        dataPriv.set(elem, "display", display)));
        for (index = 0; index < length; index++) null != values[index] && (elements[index].style.display = values[index]);
        return elements;
    }
    function getAll(context, tag) {
        var ret;
        return ret = "undefined" != typeof context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : "undefined" != typeof context.querySelectorAll ? context.querySelectorAll(tag || "*") : [], 
        void 0 === tag || tag && jQuery.nodeName(context, tag) ? jQuery.merge([ context ], ret) : ret;
    }
    function setGlobalEval(elems, refElements) {
        for (var i = 0, l = elems.length; i < l; i++) dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
    function buildFragment(elems, context, scripts, selection, ignored) {
        for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; i < l; i++) if (elem = elems[i], 
        elem || 0 === elem) if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [ elem ] : elem); else if (rhtml.test(elem)) {
            for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || [ "", "" ])[1].toLowerCase(), 
            wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2], 
            j = wrap[0]; j--; ) tmp = tmp.lastChild;
            jQuery.merge(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = "";
        } else nodes.push(context.createTextNode(elem));
        for (fragment.textContent = "", i = 0; elem = nodes[i++]; ) if (selection && jQuery.inArray(elem, selection) > -1) ignored && ignored.push(elem); else if (contains = jQuery.contains(elem.ownerDocument, elem), 
        tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), 
        scripts) for (j = 0; elem = tmp[j++]; ) rscriptType.test(elem.type || "") && scripts.push(elem);
        return fragment;
    }
    function returnTrue() {
        return !0;
    }
    function returnFalse() {
        return !1;
    }
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }
    function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if ("object" == typeof types) {
            "string" != typeof selector && (data = data || selector, selector = void 0);
            for (type in types) on(elem, type, selector, data, types[type], one);
            return elem;
        }
        if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, 
        data = void 0) : (fn = data, data = selector, selector = void 0)), fn === !1) fn = returnFalse; else if (!fn) return elem;
        return 1 === one && (origFn = fn, fn = function(event) {
            return jQuery().off(event), origFn.apply(this, arguments);
        }, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem : elem;
    }
    function disableScript(elem) {
        return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);
        return match ? elem.type = match[1] : elem.removeAttribute("type"), elem;
    }
    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
        if (1 === dest.nodeType) {
            if (dataPriv.hasData(src) && (pdataOld = dataPriv.access(src), pdataCur = dataPriv.set(dest, pdataOld), 
            events = pdataOld.events)) {
                delete pdataCur.handle, pdataCur.events = {};
                for (type in events) for (i = 0, l = events[type].length; i < l; i++) jQuery.event.add(dest, type, events[type][i]);
            }
            dataUser.hasData(src) && (udataOld = dataUser.access(src), udataCur = jQuery.extend({}, udataOld), 
            dataUser.set(dest, udataCur));
        }
    }
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();
        "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : "input" !== nodeName && "textarea" !== nodeName || (dest.defaultValue = src.defaultValue);
    }
    function domManip(collection, args, callback, ignored) {
        args = concat.apply([], args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
        if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return collection.each(function(index) {
            var self = collection.eq(index);
            isFunction && (args[0] = value.call(this, index, self.html())), domManip(self, args, callback, ignored);
        });
        if (l && (fragment = buildFragment(args, collection[0].ownerDocument, !1, collection, ignored), 
        first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), 
        first || ignored)) {
            for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; i < l; i++) node = fragment, 
            i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), 
            callback.call(collection[i], node, i);
            if (hasScripts) for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), 
            i = 0; i < hasScripts; i++) node = scripts[i], rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : DOMEval(node.textContent.replace(rcleanScript, ""), doc));
        }
        return collection;
    }
    function remove(elem, selector, keepData) {
        for (var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0; null != (node = nodes[i]); i++) keepData || 1 !== node.nodeType || jQuery.cleanData(getAll(node)), 
        node.parentNode && (keepData && jQuery.contains(node.ownerDocument, node) && setGlobalEval(getAll(node, "script")), 
        node.parentNode.removeChild(node));
        return elem;
    }
    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;
        return computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name], 
        "" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), 
        !support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, 
        minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, 
        ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), 
        void 0 !== ret ? ret + "" : ret;
    }
    function addGetHookIf(conditionFn, hookFn) {
        return {
            get: function() {
                return conditionFn() ? void delete this.get : (this.get = hookFn).apply(this, arguments);
            }
        };
    }
    function vendorPropName(name) {
        if (name in emptyStyle) return name;
        for (var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length; i--; ) if (name = cssPrefixes[i] + capName, 
        name in emptyStyle) return name;
    }
    function setPositiveNumber(elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }
    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i, val = 0;
        for (i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0; i < 4; i += 2) "margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), 
        isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), 
        "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), 
        "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
        return val;
    }
    function getWidthOrHeight(elem, name, extra) {
        var val, valueIsBorderBox = !0, styles = getStyles(elem), isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
        if (elem.getClientRects().length && (val = elem.getBoundingClientRect()[name]), 
        val <= 0 || null == val) {
            if (val = curCSS(elem, name, styles), (val < 0 || null == val) && (val = elem.style[name]), 
            rnumnonpx.test(val)) return val;
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), 
            val = parseFloat(val) || 0;
        }
        return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px";
    }
    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
    }
    function raf() {
        timerId && (window.requestAnimationFrame(raf), jQuery.fx.tick());
    }
    function createFxNow() {
        return window.setTimeout(function() {
            fxNow = void 0;
        }), fxNow = jQuery.now();
    }
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };
        for (includeWidth = includeWidth ? 1 : 0; i < 4; i += 2 - includeWidth) which = cssExpand[i], 
        attrs["margin" + which] = attrs["padding" + which] = type;
        return includeWidth && (attrs.opacity = attrs.width = type), attrs;
    }
    function createTween(value, prop, animation) {
        for (var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length; index < length; index++) if (tween = collection[index].call(animation, prop, value)) return tween;
    }
    function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, 
        oldfire = hooks.empty.fire, hooks.empty.fire = function() {
            hooks.unqueued || oldfire();
        }), hooks.unqueued++, anim.always(function() {
            anim.always(function() {
                hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire();
            });
        }));
        for (prop in props) if (value = props[prop], rfxtypes.test(value)) {
            if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                hidden = !0;
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
        }
        if (propTween = !jQuery.isEmptyObject(props), propTween || !jQuery.isEmptyObject(orig)) {
            isBox && 1 === elem.nodeType && (opts.overflow = [ style.overflow, style.overflowX, style.overflowY ], 
            restoreDisplay = dataShow && dataShow.display, null == restoreDisplay && (restoreDisplay = dataPriv.get(elem, "display")), 
            display = jQuery.css(elem, "display"), "none" === display && (restoreDisplay ? display = restoreDisplay : (showHide([ elem ], !0), 
            restoreDisplay = elem.style.display || restoreDisplay, display = jQuery.css(elem, "display"), 
            showHide([ elem ]))), ("inline" === display || "inline-block" === display && null != restoreDisplay) && "none" === jQuery.css(elem, "float") && (propTween || (anim.done(function() {
                style.display = restoreDisplay;
            }), null == restoreDisplay && (display = style.display, restoreDisplay = "none" === display ? "" : display)), 
            style.display = "inline-block")), opts.overflow && (style.overflow = "hidden", anim.always(function() {
                style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2];
            })), propTween = !1;
            for (prop in orig) propTween || (dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = dataPriv.access(elem, "fxshow", {
                display: restoreDisplay
            }), toggle && (dataShow.hidden = !hidden), hidden && showHide([ elem ], !0), anim.done(function() {
                hidden || showHide([ elem ]), dataPriv.remove(elem, "fxshow");
                for (prop in orig) jQuery.style(elem, prop, orig[prop]);
            })), propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = propTween.start, 
            hidden && (propTween.end = propTween.start, propTween.start = 0));
        }
    }
    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) if (name = jQuery.camelCase(index), easing = specialEasing[name], 
        value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), 
        index !== name && (props[name] = value, delete props[index]), hooks = jQuery.cssHooks[name], 
        hooks && "expand" in hooks) {
            value = hooks.expand(value), delete props[name];
            for (index in value) index in props || (props[index] = value[index], specialEasing[index] = easing);
        } else specialEasing[name] = easing;
    }
    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
            delete tick.elem;
        }), tick = function() {
            if (stopped) return !1;
            for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; index < length; index++) animation.tweens[index].run(percent);
            return deferred.notifyWith(elem, [ animation, percent, remaining ]), percent < 1 && length ? remaining : (deferred.resolveWith(elem, [ animation ]), 
            !1);
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(!0, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                return animation.tweens.push(tween), tween;
            },
            stop: function(gotoEnd) {
                var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) return this;
                for (stopped = !0; index < length; index++) animation.tweens[index].run(1);
                return gotoEnd ? (deferred.notifyWith(elem, [ animation, 1, 0 ]), deferred.resolveWith(elem, [ animation, gotoEnd ])) : deferred.rejectWith(elem, [ animation, gotoEnd ]), 
                this;
            }
        }), props = animation.props;
        for (propFilter(props, animation.opts.specialEasing); index < length; index++) if (result = Animation.prefilters[index].call(animation, elem, props, animation.opts)) return jQuery.isFunction(result.stop) && (jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result)), 
        result;
        return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), 
        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        })), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }
    function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
    }
    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }
    function buildParams(prefix, obj, traditional, add) {
        var name;
        if (jQuery.isArray(obj)) jQuery.each(obj, function(i, v) {
            traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v && null != v ? i : "") + "]", v, traditional, add);
        }); else if (traditional || "object" !== jQuery.type(obj)) add(prefix, obj); else for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
    }
    function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
            "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
            if (jQuery.isFunction(func)) for (;dataType = dataTypes[i++]; ) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", 
            (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func);
        };
    }
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        function inspect(dataType) {
            var selected;
            return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), 
                inspect(dataTypeOrTransport), !1);
            }), selected;
        }
        var inspected = {}, seekingTransport = structure === transports;
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
        return deep && jQuery.extend(!0, target, deep), target;
    }
    function ajaxHandleResponses(s, jqXHR, responses) {
        for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0]; ) dataTypes.shift(), 
        void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
        if (ct) for (type in contents) if (contents[type] && contents[type].test(ct)) {
            dataTypes.unshift(type);
            break;
        }
        if (dataTypes[0] in responses) finalDataType = dataTypes[0]; else {
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                firstDataType || (firstDataType = type);
            }
            finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) return finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), 
        responses[finalDataType];
    }
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
        for (current = dataTypes.shift(); current; ) if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), 
        !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), 
        prev = current, current = dataTypes.shift()) if ("*" === current) current = prev; else if ("*" !== prev && prev !== current) {
            if (conv = converters[prev + " " + current] || converters["* " + current], !conv) for (conv2 in converters) if (tmp = conv2.split(" "), 
            tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                conv === !0 ? conv = converters[conv2] : converters[conv2] !== !0 && (current = tmp[0], 
                dataTypes.unshift(tmp[1]));
                break;
            }
            if (conv !== !0) if (conv && s.throws) response = conv(response); else try {
                response = conv(response);
            } catch (e) {
                return {
                    state: "parsererror",
                    error: conv ? e : "No conversion from " + prev + " to " + current
                };
            }
        }
        return {
            state: "success",
            data: response
        };
    }
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : 9 === elem.nodeType && elem.defaultView;
    }
    var arr = [], document = window.document, getProto = Object.getPrototypeOf, slice = arr.slice, concat = arr.concat, push = arr.push, indexOf = arr.indexOf, class2type = {}, toString = class2type.toString, hasOwn = class2type.hasOwnProperty, fnToString = hasOwn.toString, ObjectFunctionString = fnToString.call(Object), support = {}, version = "3.1.1", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
    }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };
    jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        length: 0,
        toArray: function() {
            return slice.call(this);
        },
        get: function(num) {
            return null == num ? slice.call(this) : num < 0 ? this[num + this.length] : this[num];
        },
        pushStack: function(elems) {
            var ret = jQuery.merge(this.constructor(), elems);
            return ret.prevObject = this, ret;
        },
        each: function(callback) {
            return jQuery.each(this, callback);
        },
        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },
        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
            return this.eq(0);
        },
        last: function() {
            return this.eq(-1);
        },
        eq: function(i) {
            var len = this.length, j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [ this[j] ] : []);
        },
        end: function() {
            return this.prevObject || this.constructor();
        },
        push: push,
        sort: arr.sort,
        splice: arr.splice
    }, jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
        for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, 
        i++), "object" == typeof target || jQuery.isFunction(target) || (target = {}), i === length && (target = this, 
        i--); i < length; i++) if (null != (options = arguments[i])) for (name in options) src = target[name], 
        copy = options[name], target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, 
        clone = src && jQuery.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, 
        target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
        return target;
    }, jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(msg) {
            throw new Error(msg);
        },
        noop: function() {},
        isFunction: function(obj) {
            return "function" === jQuery.type(obj);
        },
        isArray: Array.isArray,
        isWindow: function(obj) {
            return null != obj && obj === obj.window;
        },
        isNumeric: function(obj) {
            var type = jQuery.type(obj);
            return ("number" === type || "string" === type) && !isNaN(obj - parseFloat(obj));
        },
        isPlainObject: function(obj) {
            var proto, Ctor;
            return !(!obj || "[object Object]" !== toString.call(obj)) && (!(proto = getProto(obj)) || (Ctor = hasOwn.call(proto, "constructor") && proto.constructor, 
            "function" == typeof Ctor && fnToString.call(Ctor) === ObjectFunctionString));
        },
        isEmptyObject: function(obj) {
            var name;
            for (name in obj) return !1;
            return !0;
        },
        type: function(obj) {
            return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj;
        },
        globalEval: function(code) {
            DOMEval(code);
        },
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },
        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },
        each: function(obj, callback) {
            var length, i = 0;
            if (isArrayLike(obj)) for (length = obj.length; i < length && callback.call(obj[i], i, obj[i]) !== !1; i++) ; else for (i in obj) if (callback.call(obj[i], i, obj[i]) === !1) break;
            return obj;
        },
        trim: function(text) {
            return null == text ? "" : (text + "").replace(rtrim, "");
        },
        makeArray: function(arr, results) {
            var ret = results || [];
            return null != arr && (isArrayLike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [ arr ] : arr) : push.call(ret, arr)), 
            ret;
        },
        inArray: function(elem, arr, i) {
            return null == arr ? -1 : indexOf.call(arr, elem, i);
        },
        merge: function(first, second) {
            for (var len = +second.length, j = 0, i = first.length; j < len; j++) first[i++] = second[j];
            return first.length = i, first;
        },
        grep: function(elems, callback, invert) {
            for (var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert; i < length; i++) callbackInverse = !callback(elems[i], i), 
            callbackInverse !== callbackExpect && matches.push(elems[i]);
            return matches;
        },
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];
            if (isArrayLike(elems)) for (length = elems.length; i < length; i++) value = callback(elems[i], i, arg), 
            null != value && ret.push(value); else for (i in elems) value = callback(elems[i], i, arg), 
            null != value && ret.push(value);
            return concat.apply([], ret);
        },
        guid: 1,
        proxy: function(fn, context) {
            var tmp, args, proxy;
            if ("string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), jQuery.isFunction(fn)) return args = slice.call(arguments, 2), 
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            }, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy;
        },
        now: Date.now,
        support: support
    }), "function" == typeof Symbol && (jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]), 
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });
    var Sizzle = function(window) {
        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
            if (results = results || [], "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType) return results;
            if (!seed && ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), 
            context = context || document, documentIsHTML)) {
                if (11 !== nodeType && (match = rquickExpr.exec(selector))) if (m = match[1]) {
                    if (9 === nodeType) {
                        if (!(elem = context.getElementById(m))) return results;
                        if (elem.id === m) return results.push(elem), results;
                    } else if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), 
                    results;
                } else {
                    if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), 
                    results;
                    if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), 
                    results;
                }
                if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                    if (1 !== nodeType) newContext = context, newSelector = selector; else if ("object" !== context.nodeName.toLowerCase()) {
                        for ((nid = context.getAttribute("id")) ? nid = nid.replace(rcssescape, fcssescape) : context.setAttribute("id", nid = expando), 
                        groups = tokenize(selector), i = groups.length; i--; ) groups[i] = "#" + nid + " " + toSelector(groups[i]);
                        newSelector = groups.join(","), newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                    }
                    if (newSelector) try {
                        return push.apply(results, newContext.querySelectorAll(newSelector)), results;
                    } catch (qsaError) {} finally {
                        nid === expando && context.removeAttribute("id");
                    }
                }
            }
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }
        function createCache() {
            function cache(key, value) {
                return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value;
            }
            var keys = [];
            return cache;
        }
        function markFunction(fn) {
            return fn[expando] = !0, fn;
        }
        function assert(fn) {
            var el = document.createElement("fieldset");
            try {
                return !!fn(el);
            } catch (e) {
                return !1;
            } finally {
                el.parentNode && el.parentNode.removeChild(el), el = null;
            }
        }
        function addHandle(attrs, handler) {
            for (var arr = attrs.split("|"), i = arr.length; i--; ) Expr.attrHandle[arr[i]] = handler;
        }
        function siblingCheck(a, b) {
            var cur = b && a, diff = cur && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
            if (diff) return diff;
            if (cur) for (;cur = cur.nextSibling; ) if (cur === b) return -1;
            return a ? 1 : -1;
        }
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return "input" === name && elem.type === type;
            };
        }
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return ("input" === name || "button" === name) && elem.type === type;
            };
        }
        function createDisabledPseudo(disabled) {
            return function(elem) {
                return "form" in elem ? elem.parentNode && elem.disabled === !1 ? "label" in elem ? "label" in elem.parentNode ? elem.parentNode.disabled === disabled : elem.disabled === disabled : elem.isDisabled === disabled || elem.isDisabled !== !disabled && disabledAncestor(elem) === disabled : elem.disabled === disabled : "label" in elem && elem.disabled === disabled;
            };
        }
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                return argument = +argument, markFunction(function(seed, matches) {
                    for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--; ) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]));
                });
            });
        }
        function testContext(context) {
            return context && "undefined" != typeof context.getElementsByTagName && context;
        }
        function setFilters() {}
        function toSelector(tokens) {
            for (var i = 0, len = tokens.length, selector = ""; i < len; i++) selector += tokens[i].value;
            return selector;
        }
        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && "parentNode" === key, doneName = done++;
            return combinator.first ? function(elem, context, xml) {
                for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml);
                return !1;
            } : function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [ dirruns, doneName ];
                if (xml) {
                    for (;elem = elem[dir]; ) if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0;
                } else for (;elem = elem[dir]; ) if (1 === elem.nodeType || checkNonElements) if (outerCache = elem[expando] || (elem[expando] = {}), 
                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {}), skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem; else {
                    if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                    if (uniqueCache[key] = newCache, newCache[2] = matcher(elem, context, xml)) return !0;
                }
                return !1;
            };
        }
        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                for (var i = matchers.length; i--; ) if (!matchers[i](elem, context, xml)) return !1;
                return !0;
            } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
            for (var i = 0, len = contexts.length; i < len; i++) Sizzle(selector, contexts[i], results);
            return results;
        }
        function condense(unmatched, map, filter, context, xml) {
            for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; i < len; i++) (elem = unmatched[i]) && (filter && !filter(elem, context, xml) || (newUnmatched.push(elem), 
            mapped && map.push(i)));
            return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), 
            postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), 
            markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [ context ] : context, []), matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter) for (temp = condense(matcherOut, postMap), 
                postFilter(temp, [], context, xml), i = temp.length; i--; ) (elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            for (temp = [], i = matcherOut.length; i--; ) (elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                            postFinder(null, matcherOut = [], temp, xml);
                        }
                        for (i = matcherOut.length; i--; ) (elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem));
                    }
                } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), 
                postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut);
            });
        }
        function matcherFromTokens(tokens) {
            for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, !0), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, !0), matchers = [ function(elem, context, xml) {
                var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                return checkContext = null, ret;
            } ]; i < len; i++) if (matcher = Expr.relative[tokens[i].type]) matchers = [ addCombinator(elementMatcher(matchers), matcher) ]; else {
                if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                    for (j = ++i; j < len && !Expr.relative[tokens[j].type]; j++) ;
                    return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                        value: " " === tokens[i - 2].type ? "*" : ""
                    })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                }
                matchers.push(matcher);
            }
            return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                for (outermost && (outermostContext = context === document || context || outermost); i !== len && null != (elem = elems[i]); i++) {
                    if (byElement && elem) {
                        for (j = 0, context || elem.ownerDocument === document || (setDocument(elem), xml = !documentIsHTML); matcher = elementMatchers[j++]; ) if (matcher(elem, context || document, xml)) {
                            results.push(elem);
                            break;
                        }
                        outermost && (dirruns = dirrunsUnique);
                    }
                    bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem));
                }
                if (matchedCount += i, bySet && i !== matchedCount) {
                    for (j = 0; matcher = setMatchers[j++]; ) matcher(unmatched, setMatched, context, xml);
                    if (seed) {
                        if (matchedCount > 0) for (;i--; ) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                        setMatched = condense(setMatched);
                    }
                    push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results);
                }
                return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), 
                unmatched;
            };
            return bySet ? markFunction(superMatcher) : superMatcher;
        }
        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            return a === b && (hasDuplicate = !0), 0;
        }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function(list, elem) {
            for (var i = 0, len = list.length; i < len; i++) if (list[i] === elem) return i;
            return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
            ID: new RegExp("^#(" + identifier + ")"),
            CLASS: new RegExp("^\\.(" + identifier + ")"),
            TAG: new RegExp("^(" + identifier + "|[*])"),
            ATTR: new RegExp("^" + attributes),
            PSEUDO: new RegExp("^" + pseudos),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + booleans + ")$", "i"),
            needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 65536;
            return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320);
        }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
            return asCodePoint ? "\0" === ch ? "" : ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " " : "\\" + ch;
        }, unloadHandler = function() {
            setDocument();
        }, disabledAncestor = addCombinator(function(elem) {
            return elem.disabled === !0 && ("form" in elem || "label" in elem);
        }, {
            dir: "parentNode",
            next: "legend"
        });
        try {
            push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), 
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ? function(target, els) {
                    push_native.apply(target, slice.call(els));
                } : function(target, els) {
                    for (var j = target.length, i = 0; target[j++] = els[i++]; ) ;
                    target.length = j - 1;
                }
            };
        }
        support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return !!documentElement && "HTML" !== documentElement.nodeName;
        }, setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
            return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, 
            docElem = document.documentElement, documentIsHTML = !isXML(document), preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow && (subWindow.addEventListener ? subWindow.addEventListener("unload", unloadHandler, !1) : subWindow.attachEvent && subWindow.attachEvent("onunload", unloadHandler)), 
            support.attributes = assert(function(el) {
                return el.className = "i", !el.getAttribute("className");
            }), support.getElementsByTagName = assert(function(el) {
                return el.appendChild(document.createComment("")), !el.getElementsByTagName("*").length;
            }), support.getElementsByClassName = rnative.test(document.getElementsByClassName), 
            support.getById = assert(function(el) {
                return docElem.appendChild(el).id = expando, !document.getElementsByName || !document.getElementsByName(expando).length;
            }), support.getById ? (Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    return elem.getAttribute("id") === attrId;
                };
            }, Expr.find.ID = function(id, context) {
                if ("undefined" != typeof context.getElementById && documentIsHTML) {
                    var elem = context.getElementById(id);
                    return elem ? [ elem ] : [];
                }
            }) : (Expr.filter.ID = function(id) {
                var attrId = id.replace(runescape, funescape);
                return function(elem) {
                    var node = "undefined" != typeof elem.getAttributeNode && elem.getAttributeNode("id");
                    return node && node.value === attrId;
                };
            }, Expr.find.ID = function(id, context) {
                if ("undefined" != typeof context.getElementById && documentIsHTML) {
                    var node, i, elems, elem = context.getElementById(id);
                    if (elem) {
                        if (node = elem.getAttributeNode("id"), node && node.value === id) return [ elem ];
                        for (elems = context.getElementsByName(id), i = 0; elem = elems[i++]; ) if (node = elem.getAttributeNode("id"), 
                        node && node.value === id) return [ elem ];
                    }
                    return [];
                }
            }), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                return "undefined" != typeof context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0;
            } : function(tag, context) {
                var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                if ("*" === tag) {
                    for (;elem = results[i++]; ) 1 === elem.nodeType && tmp.push(elem);
                    return tmp;
                }
                return results;
            }, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                if ("undefined" != typeof context.getElementsByClassName && documentIsHTML) return context.getElementsByClassName(className);
            }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(document.querySelectorAll)) && (assert(function(el) {
                docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>", 
                el.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), 
                el.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), 
                el.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), el.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), 
                el.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]");
            }), assert(function(el) {
                el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var input = document.createElement("input");
                input.setAttribute("type", "hidden"), el.appendChild(input).setAttribute("name", "D"), 
                el.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), 
                2 !== el.querySelectorAll(":enabled").length && rbuggyQSA.push(":enabled", ":disabled"), 
                docElem.appendChild(el).disabled = !0, 2 !== el.querySelectorAll(":disabled").length && rbuggyQSA.push(":enabled", ":disabled"), 
                el.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:");
            })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function(el) {
                support.disconnectedMatch = matches.call(el, "*"), matches.call(el, "[s!='']:x"), 
                rbuggyMatches.push("!=", pseudos);
            }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), 
            hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)));
            } : function(a, b) {
                if (b) for (;b = b.parentNode; ) if (b === a) return !0;
                return !1;
            }, sortOrder = hasCompare ? function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                return compare ? compare : (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 
                1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1);
            } : function(a, b) {
                if (a === b) return hasDuplicate = !0, 0;
                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [ a ], bp = [ b ];
                if (!aup || !bup) return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                if (aup === bup) return siblingCheck(a, b);
                for (cur = a; cur = cur.parentNode; ) ap.unshift(cur);
                for (cur = b; cur = cur.parentNode; ) bp.unshift(cur);
                for (;ap[i] === bp[i]; ) i++;
                return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            }, document) : document;
        }, Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        }, Sizzle.matchesSelector = function(elem, expr) {
            if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), 
            support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                var ret = matches.call(elem, expr);
                if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret;
            } catch (e) {}
            return Sizzle(expr, document, null, [ elem ]).length > 0;
        }, Sizzle.contains = function(context, elem) {
            return (context.ownerDocument || context) !== document && setDocument(context), 
            contains(context, elem);
        }, Sizzle.attr = function(elem, name) {
            (elem.ownerDocument || elem) !== document && setDocument(elem);
            var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
            return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }, Sizzle.escape = function(sel) {
            return (sel + "").replace(rcssescape, fcssescape);
        }, Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        }, Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;
            if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), 
            results.sort(sortOrder), hasDuplicate) {
                for (;elem = results[i++]; ) elem === results[i] && (j = duplicates.push(i));
                for (;j--; ) results.splice(duplicates[j], 1);
            }
            return sortInput = null, results;
        }, getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;
            if (nodeType) {
                if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                    if ("string" == typeof elem.textContent) return elem.textContent;
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem);
                } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue;
            } else for (;node = elem[i++]; ) ret += getText(node);
            return ret;
        }, Expr = Sizzle.selectors = {
            cacheLength: 50,
            createPseudo: markFunction,
            match: matchExpr,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(match) {
                    return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), 
                    "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4);
                },
                CHILD: function(match) {
                    return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), 
                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), 
                    match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), 
                    match;
                },
                PSEUDO: function(match) {
                    var excess, unquoted = !match[6] && match[2];
                    return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), 
                    match[2] = unquoted.slice(0, excess)), match.slice(0, 3));
                }
            },
            filter: {
                TAG: function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return "*" === nodeNameSelector ? function() {
                        return !0;
                    } : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    };
                },
                CLASS: function(className) {
                    var pattern = classCache[className + " "];
                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test("string" == typeof elem.className && elem.className || "undefined" != typeof elem.getAttribute && elem.getAttribute("class") || "");
                    });
                },
                ATTR: function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);
                        return null == result ? "!=" === operator : !operator || (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator && (result === check || result.slice(0, check.length + 1) === check + "-"));
                    };
                },
                CHILD: function(type, what, argument, first, last) {
                    var simple = "nth" !== type.slice(0, 3), forward = "last" !== type.slice(-4), ofType = "of-type" === what;
                    return 1 === first && 0 === last ? function(elem) {
                        return !!elem.parentNode;
                    } : function(elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = !1;
                        if (parent) {
                            if (simple) {
                                for (;dir; ) {
                                    for (node = elem; node = node[dir]; ) if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                    start = dir = "only" === type && !start && "nextSibling";
                                }
                                return !0;
                            }
                            if (start = [ forward ? parent.firstChild : parent.lastChild ], forward && useCache) {
                                for (node = parent, outerCache = node[expando] || (node[expando] = {}), uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), 
                                cache = uniqueCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex && cache[2], 
                                node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop(); ) if (1 === node.nodeType && ++diff && node === elem) {
                                    uniqueCache[type] = [ dirruns, nodeIndex, diff ];
                                    break;
                                }
                            } else if (useCache && (node = elem, outerCache = node[expando] || (node[expando] = {}), 
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), cache = uniqueCache[type] || [], 
                            nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex), diff === !1) for (;(node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && (outerCache = node[expando] || (node[expando] = {}), 
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), uniqueCache[type] = [ dirruns, diff ]), 
                            node !== elem)); ) ;
                            return diff -= last, diff === first || diff % first === 0 && diff / first >= 0;
                        }
                    };
                },
                PSEUDO: function(pseudo, argument) {
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                    return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [ pseudo, pseudo, "", argument ], 
                    Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                        for (var idx, matched = fn(seed, argument), i = matched.length; i--; ) idx = indexOf(seed, matched[i]), 
                        seed[idx] = !(matches[idx] = matched[i]);
                    }) : function(elem) {
                        return fn(elem, 0, args);
                    }) : fn;
                }
            },
            pseudos: {
                not: markFunction(function(selector) {
                    var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--; ) (elem = unmatched[i]) && (seed[i] = !(matches[i] = elem));
                    }) : function(elem, context, xml) {
                        return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop();
                    };
                }),
                has: markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    };
                }),
                contains: markFunction(function(text) {
                    return text = text.replace(runescape, funescape), function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    };
                }),
                lang: markFunction(function(lang) {
                    return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), 
                    lang = lang.replace(runescape, funescape).toLowerCase(), function(elem) {
                        var elemLang;
                        do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return elemLang = elemLang.toLowerCase(), 
                        elemLang === lang || 0 === elemLang.indexOf(lang + "-"); while ((elem = elem.parentNode) && 1 === elem.nodeType);
                        return !1;
                    };
                }),
                target: function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },
                root: function(elem) {
                    return elem === docElem;
                },
                focus: function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },
                enabled: createDisabledPseudo(!1),
                disabled: createDisabledPseudo(!0),
                checked: function(elem) {
                    var nodeName = elem.nodeName.toLowerCase();
                    return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected;
                },
                selected: function(elem) {
                    return elem.parentNode && elem.parentNode.selectedIndex, elem.selected === !0;
                },
                empty: function(elem) {
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) if (elem.nodeType < 6) return !1;
                    return !0;
                },
                parent: function(elem) {
                    return !Expr.pseudos.empty(elem);
                },
                header: function(elem) {
                    return rheader.test(elem.nodeName);
                },
                input: function(elem) {
                    return rinputs.test(elem.nodeName);
                },
                button: function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return "input" === name && "button" === elem.type || "button" === name;
                },
                text: function(elem) {
                    var attr;
                    return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase());
                },
                first: createPositionalPseudo(function() {
                    return [ 0 ];
                }),
                last: createPositionalPseudo(function(matchIndexes, length) {
                    return [ length - 1 ];
                }),
                eq: createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [ argument < 0 ? argument + length : argument ];
                }),
                even: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 0; i < length; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                odd: createPositionalPseudo(function(matchIndexes, length) {
                    for (var i = 1; i < length; i += 2) matchIndexes.push(i);
                    return matchIndexes;
                }),
                lt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; --i >= 0; ) matchIndexes.push(i);
                    return matchIndexes;
                }),
                gt: createPositionalPseudo(function(matchIndexes, length, argument) {
                    for (var i = argument < 0 ? argument + length : argument; ++i < length; ) matchIndexes.push(i);
                    return matchIndexes;
                })
            }
        }, Expr.pseudos.nth = Expr.pseudos.eq;
        for (i in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) Expr.pseudos[i] = createInputPseudo(i);
        for (i in {
            submit: !0,
            reset: !0
        }) Expr.pseudos[i] = createButtonPseudo(i);
        return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters(), 
        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
            if (cached) return parseOnly ? 0 : cached.slice(0);
            for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar; ) {
                matched && !(match = rcomma.exec(soFar)) || (match && (soFar = soFar.slice(match[0].length) || soFar), 
                groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), 
                tokens.push({
                    value: matched,
                    type: match[0].replace(rtrim, " ")
                }), soFar = soFar.slice(matched.length));
                for (type in Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), 
                tokens.push({
                    value: matched,
                    type: type,
                    matches: match
                }), soFar = soFar.slice(matched.length));
                if (!matched) break;
            }
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
        }, compile = Sizzle.compile = function(selector, match) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
            if (!cached) {
                for (match || (match = tokenize(selector)), i = match.length; i--; ) cached = matcherFromTokens(match[i]), 
                cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), 
                cached.selector = selector;
            }
            return cached;
        }, select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
            if (results = results || [], 1 === match.length) {
                if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                    if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], 
                    !context) return results;
                    compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length);
                }
                for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], 
                !Expr.relative[type = token.type]); ) if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                    if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector) return push.apply(results, seed), 
                    results;
                    break;
                }
            }
            return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context), 
            results;
        }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, 
        support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function(el) {
            return 1 & el.compareDocumentPosition(document.createElement("fieldset"));
        }), assert(function(el) {
            return el.innerHTML = "<a href='#'></a>", "#" === el.firstChild.getAttribute("href");
        }) || addHandle("type|href|height|width", function(elem, name, isXML) {
            if (!isXML) return elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2);
        }), support.attributes && assert(function(el) {
            return el.innerHTML = "<input/>", el.firstChild.setAttribute("value", ""), "" === el.firstChild.getAttribute("value");
        }) || addHandle("value", function(elem, name, isXML) {
            if (!isXML && "input" === elem.nodeName.toLowerCase()) return elem.defaultValue;
        }), assert(function(el) {
            return null == el.getAttribute("disabled");
        }) || addHandle(booleans, function(elem, name, isXML) {
            var val;
            if (!isXML) return elem[name] === !0 ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }), Sizzle;
    }(window);
    jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, 
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, 
    jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains, jQuery.escapeSelector = Sizzle.escape;
    var dir = function(elem, dir, until) {
        for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType; ) if (1 === elem.nodeType) {
            if (truncate && jQuery(elem).is(until)) break;
            matched.push(elem);
        }
        return matched;
    }, siblings = function(n, elem) {
        for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
        return matched;
    }, rneedsContext = jQuery.expr.match.needsContext, rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i, risSimple = /^.[^:#\[\.,]*$/;
    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [ elem ] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return 1 === elem.nodeType;
        }));
    }, jQuery.fn.extend({
        find: function(selector) {
            var i, ret, len = this.length, self = this;
            if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter(function() {
                for (i = 0; i < len; i++) if (jQuery.contains(self[i], this)) return !0;
            }));
            for (ret = this.pushStack([]), i = 0; i < len; i++) jQuery.find(selector, self[i], ret);
            return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], !1));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], !0));
        },
        is: function(selector) {
            return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length;
        }
    });
    var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        if (!selector) return this;
        if (root = root || rootjQuery, "string" == typeof selector) {
            if (match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [ null, selector, null ] : rquickExpr.exec(selector), 
            !match || !match[1] && context) return !context || context.jquery ? (context || root).find(selector) : this.constructor(context).find(selector);
            if (match[1]) {
                if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), 
                rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) for (match in context) jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                return this;
            }
            return elem = document.getElementById(match[2]), elem && (this[0] = elem, this.length = 1), 
            this;
        }
        return selector.nodeType ? (this[0] = selector, this.length = 1, this) : jQuery.isFunction(selector) ? void 0 !== root.ready ? root.ready(selector) : selector(jQuery) : jQuery.makeArray(selector, this);
    };
    init.prototype = jQuery.fn, rootjQuery = jQuery(document);
    var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this), l = targets.length;
            return this.filter(function() {
                for (var i = 0; i < l; i++) if (jQuery.contains(this, targets[i])) return !0;
            });
        },
        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], targets = "string" != typeof selectors && jQuery(selectors);
            if (!rneedsContext.test(selectors)) for (;i < l; i++) for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                matched.push(cur);
                break;
            }
            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function(elem) {
            return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
        },
        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
            return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector));
        }
    }), jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && 11 !== parent.nodeType ? parent : null;
        },
        parents: function(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);
            return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), 
            this.length > 1 && (guaranteedUnique[name] || jQuery.uniqueSort(matched), rparentsprev.test(name) && matched.reverse()), 
            this.pushStack(matched);
        };
    });
    var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    jQuery.Callbacks = function(options) {
        options = "string" == typeof options ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
            for (locked = options.once, fired = firing = !0; queue.length; firingIndex = -1) for (memory = queue.shift(); ++firingIndex < list.length; ) list[firingIndex].apply(memory[0], memory[1]) === !1 && options.stopOnFalse && (firingIndex = list.length, 
            memory = !1);
            options.memory || (memory = !1), firing = !1, locked && (list = memory ? [] : "");
        }, self = {
            add: function() {
                return list && (memory && !firing && (firingIndex = list.length - 1, queue.push(memory)), 
                function add(args) {
                    jQuery.each(args, function(_, arg) {
                        jQuery.isFunction(arg) ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== jQuery.type(arg) && add(arg);
                    });
                }(arguments), memory && !firing && fire()), this;
            },
            remove: function() {
                return jQuery.each(arguments, function(_, arg) {
                    for (var index; (index = jQuery.inArray(arg, list, index)) > -1; ) list.splice(index, 1), 
                    index <= firingIndex && firingIndex--;
                }), this;
            },
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },
            empty: function() {
                return list && (list = []), this;
            },
            disable: function() {
                return locked = queue = [], list = memory = "", this;
            },
            disabled: function() {
                return !list;
            },
            lock: function() {
                return locked = queue = [], memory || firing || (list = memory = ""), this;
            },
            locked: function() {
                return !!locked;
            },
            fireWith: function(context, args) {
                return locked || (args = args || [], args = [ context, args.slice ? args.slice() : args ], 
                queue.push(args), firing || fire()), this;
            },
            fire: function() {
                return self.fireWith(this, arguments), this;
            },
            fired: function() {
                return !!fired;
            }
        };
        return self;
    }, jQuery.extend({
        Deferred: function(func) {
            var tuples = [ [ "notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2 ], [ "resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved" ], [ "reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected" ] ], state = "pending", promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    return deferred.done(arguments).fail(arguments), this;
                },
                catch: function(fn) {
                    return promise.then(null, fn);
                },
                pipe: function() {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                returned && jQuery.isFunction(returned.promise) ? returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject) : newDefer[tuple[0] + "With"](this, fn ? [ returned ] : arguments);
                            });
                        }), fns = null;
                    }).promise();
                },
                then: function(onFulfilled, onRejected, onProgress) {
                    function resolve(depth, deferred, handler, special) {
                        return function() {
                            var that = this, args = arguments, mightThrow = function() {
                                var returned, then;
                                if (!(depth < maxDepth)) {
                                    if (returned = handler.apply(that, args), returned === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                    then = returned && ("object" == typeof returned || "function" == typeof returned) && returned.then, 
                                    jQuery.isFunction(then) ? special ? then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)) : (maxDepth++, 
                                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))) : (handler !== Identity && (that = void 0, 
                                    args = [ returned ]), (special || deferred.resolveWith)(that, args));
                                }
                            }, process = special ? mightThrow : function() {
                                try {
                                    mightThrow();
                                } catch (e) {
                                    jQuery.Deferred.exceptionHook && jQuery.Deferred.exceptionHook(e, process.stackTrace), 
                                    depth + 1 >= maxDepth && (handler !== Thrower && (that = void 0, args = [ e ]), 
                                    deferred.rejectWith(that, args));
                                }
                            };
                            depth ? process() : (jQuery.Deferred.getStackHook && (process.stackTrace = jQuery.Deferred.getStackHook()), 
                            window.setTimeout(process));
                        };
                    }
                    var maxDepth = 0;
                    return jQuery.Deferred(function(newDefer) {
                        tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)), 
                        tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity)), 
                        tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower));
                    }).promise();
                },
                promise: function(obj) {
                    return null != obj ? jQuery.extend(obj, promise) : promise;
                }
            }, deferred = {};
            return jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2], stateString = tuple[5];
                promise[tuple[1]] = list.add, stateString && list.add(function() {
                    state = stateString;
                }, tuples[3 - i][2].disable, tuples[0][2].lock), list.add(tuple[3].fire), deferred[tuple[0]] = function() {
                    return deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments), 
                    this;
                }, deferred[tuple[0] + "With"] = list.fireWith;
            }), promise.promise(deferred), func && func.call(deferred, deferred), deferred;
        },
        when: function(singleValue) {
            var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function(i) {
                return function(value) {
                    resolveContexts[i] = this, resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value, 
                    --remaining || master.resolveWith(resolveContexts, resolveValues);
                };
            };
            if (remaining <= 1 && (adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject), 
            "pending" === master.state() || jQuery.isFunction(resolveValues[i] && resolveValues[i].then))) return master.then();
            for (;i--; ) adoptValue(resolveValues[i], updateFunc(i), master.reject);
            return master.promise();
        }
    });
    var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    jQuery.Deferred.exceptionHook = function(error, stack) {
        window.console && window.console.warn && error && rerrorNames.test(error.name) && window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }, jQuery.readyException = function(error) {
        window.setTimeout(function() {
            throw error;
        });
    };
    var readyList = jQuery.Deferred();
    jQuery.fn.ready = function(fn) {
        return readyList.then(fn).catch(function(error) {
            jQuery.readyException(error);
        }), this;
    }, jQuery.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(hold) {
            hold ? jQuery.readyWait++ : jQuery.ready(!0);
        },
        ready: function(wait) {
            (wait === !0 ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, wait !== !0 && --jQuery.readyWait > 0 || readyList.resolveWith(document, [ jQuery ]));
        }
    }), jQuery.ready.then = readyList.then, "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed), 
    window.addEventListener("load", completed));
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = null == key;
        if ("object" === jQuery.type(key)) {
            chainable = !0;
            for (i in key) access(elems, fn, i, key[i], !0, emptyGet, raw);
        } else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), 
        bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
        })), fn)) for (;i < len; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    }, acceptData = function(owner) {
        return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType;
    };
    Data.uid = 1, Data.prototype = {
        cache: function(owner) {
            var value = owner[this.expando];
            return value || (value = {}, acceptData(owner) && (owner.nodeType ? owner[this.expando] = value : Object.defineProperty(owner, this.expando, {
                value: value,
                configurable: !0
            }))), value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);
            if ("string" == typeof data) cache[jQuery.camelCase(data)] = value; else for (prop in data) cache[jQuery.camelCase(prop)] = data[prop];
            return cache;
        },
        get: function(owner, key) {
            return void 0 === key ? this.cache(owner) : owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
        },
        access: function(owner, key, value) {
            return void 0 === key || key && "string" == typeof key && void 0 === value ? this.get(owner, key) : (this.set(owner, key, value), 
            void 0 !== value ? value : key);
        },
        remove: function(owner, key) {
            var i, cache = owner[this.expando];
            if (void 0 !== cache) {
                if (void 0 !== key) {
                    jQuery.isArray(key) ? key = key.map(jQuery.camelCase) : (key = jQuery.camelCase(key), 
                    key = key in cache ? [ key ] : key.match(rnothtmlwhite) || []), i = key.length;
                    for (;i--; ) delete cache[key[i]];
                }
                (void 0 === key || jQuery.isEmptyObject(cache)) && (owner.nodeType ? owner[this.expando] = void 0 : delete owner[this.expando]);
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return void 0 !== cache && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data(), dataUser = new Data(), rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    }), jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;
            if (void 0 === key) {
                if (this.length && (data = dataUser.get(elem), 1 === elem.nodeType && !dataPriv.get(elem, "hasDataAttrs"))) {
                    for (i = attrs.length; i--; ) attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), 
                    dataAttr(elem, name, data[name])));
                    dataPriv.set(elem, "hasDataAttrs", !0);
                }
                return data;
            }
            return "object" == typeof key ? this.each(function() {
                dataUser.set(this, key);
            }) : access(this, function(value) {
                var data;
                if (elem && void 0 === value) {
                    if (data = dataUser.get(elem, key), void 0 !== data) return data;
                    if (data = dataAttr(elem, key), void 0 !== data) return data;
                } else this.each(function() {
                    dataUser.set(this, key, value);
                });
            }, null, value, arguments.length > 1, null, !0);
        },
        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    }), jQuery.extend({
        queue: function(elem, type, data) {
            var queue;
            if (elem) return type = (type || "fx") + "queue", queue = dataPriv.get(elem, type), 
            data && (!queue || jQuery.isArray(data) ? queue = dataPriv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), 
            queue || [];
        },
        dequeue: function(elem, type) {
            type = type || "fx";
            var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
                jQuery.dequeue(elem, type);
            };
            "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), 
            delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire();
        },
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [ type + "queue", key ]);
                })
            });
        }
    }), jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;
            return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);
                jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type);
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                --count || defer.resolveWith(elements, [ elements ]);
            };
            for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--; ) tmp = dataPriv.get(elements[i], type + "queueHooks"), 
            tmp && tmp.empty && (count++, tmp.empty.add(resolve));
            return resolve(), defer.promise(obj);
        }
    });
    var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), cssExpand = [ "Top", "Right", "Bottom", "Left" ], isHiddenWithinTree = function(elem, el) {
        return elem = el || elem, "none" === elem.style.display || "" === elem.style.display && jQuery.contains(elem.ownerDocument, elem) && "none" === jQuery.css(elem, "display");
    }, swap = function(elem, options, callback, args) {
        var ret, name, old = {};
        for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
        ret = callback.apply(elem, args || []);
        for (name in options) elem.style[name] = old[name];
        return ret;
    }, defaultDisplayMap = {};
    jQuery.fn.extend({
        show: function() {
            return showHide(this, !0);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function() {
                isHiddenWithinTree(this) ? jQuery(this).show() : jQuery(this).hide();
            });
        }
    });
    var rcheckableType = /^(?:checkbox|radio)$/i, rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, rscriptType = /^$|\/(?:java|ecma)script/i, wrapMap = {
        option: [ 1, "<select multiple='multiple'>", "</select>" ],
        thead: [ 1, "<table>", "</table>" ],
        col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
        tr: [ 2, "<table><tbody>", "</tbody></table>" ],
        td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
        _default: [ 0, "", "" ]
    };
    wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, 
    wrapMap.th = wrapMap.td;
    var rhtml = /<|&#?\w+;/;
    !function() {
        var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
        input.setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), 
        div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, 
        div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue;
    }();
    var documentElement = document.documentElement, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
    jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
            if (elemData) for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, 
            selector = handleObjIn.selector), selector && jQuery.find.matchesSelector(documentElement, selector), 
            handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}), 
            (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
                return "undefined" != typeof jQuery && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
            }), types = (types || "").match(rnothtmlwhite) || [ "" ], t = types.length; t--; ) tmp = rtypenamespace.exec(types[t]) || [], 
            type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, 
            type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, 
            handleObj = jQuery.extend({
                type: type,
                origType: origType,
                data: data,
                handler: handler,
                guid: handler.guid,
                selector: selector,
                needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                namespace: namespaces.join(".")
            }, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, 
            special.setup && special.setup.call(elem, data, namespaces, eventHandle) !== !1 || elem.addEventListener && elem.addEventListener(type, eventHandle)), 
            special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), 
            selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), 
            jQuery.event.global[type] = !0);
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
            if (elemData && (events = elemData.events)) {
                for (types = (types || "").match(rnothtmlwhite) || [ "" ], t = types.length; t--; ) if (tmp = rtypenamespace.exec(types[t]) || [], 
                type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                    for (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, 
                    handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), 
                    origCount = j = handlers.length; j--; ) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), 
                    handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                    origCount && !handlers.length && (special.teardown && special.teardown.call(elem, namespaces, elemData.handle) !== !1 || jQuery.removeEvent(elem, type, elemData.handle), 
                    delete events[type]);
                } else for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                jQuery.isEmptyObject(events) && dataPriv.remove(elem, "handle events");
            }
        },
        dispatch: function(nativeEvent) {
            var i, j, ret, matched, handleObj, handlerQueue, event = jQuery.event.fix(nativeEvent), args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
            for (args[0] = event, i = 1; i < arguments.length; i++) args[i] = arguments[i];
            if (event.delegateTarget = this, !special.preDispatch || special.preDispatch.call(this, event) !== !1) {
                for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped(); ) for (event.currentTarget = matched.elem, 
                j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped(); ) event.rnamespace && !event.rnamespace.test(handleObj.namespace) || (event.handleObj = handleObj, 
                event.data = handleObj.data, ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args), 
                void 0 !== ret && (event.result = ret) === !1 && (event.preventDefault(), event.stopPropagation()));
                return special.postDispatch && special.postDispatch.call(this, event), event.result;
            }
        },
        handlers: function(event, handlers) {
            var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
            if (delegateCount && cur.nodeType && !("click" === event.type && event.button >= 1)) for (;cur !== this; cur = cur.parentNode || this) if (1 === cur.nodeType && ("click" !== event.type || cur.disabled !== !0)) {
                for (matchedHandlers = [], matchedSelectors = {}, i = 0; i < delegateCount; i++) handleObj = handlers[i], 
                sel = handleObj.selector + " ", void 0 === matchedSelectors[sel] && (matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [ cur ]).length), 
                matchedSelectors[sel] && matchedHandlers.push(handleObj);
                matchedHandlers.length && handlerQueue.push({
                    elem: cur,
                    handlers: matchedHandlers
                });
            }
            return cur = this, delegateCount < handlers.length && handlerQueue.push({
                elem: cur,
                handlers: handlers.slice(delegateCount)
            }), handlerQueue;
        },
        addProp: function(name, hook) {
            Object.defineProperty(jQuery.Event.prototype, name, {
                enumerable: !0,
                configurable: !0,
                get: jQuery.isFunction(hook) ? function() {
                    if (this.originalEvent) return hook(this.originalEvent);
                } : function() {
                    if (this.originalEvent) return this.originalEvent[name];
                },
                set: function(value) {
                    Object.defineProperty(this, name, {
                        enumerable: !0,
                        configurable: !0,
                        writable: !0,
                        value: value
                    });
                }
            });
        },
        fix: function(originalEvent) {
            return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) return this.focus(), !1;
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) return this.blur(), !1;
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    if ("checkbox" === this.type && this.click && jQuery.nodeName(this, "input")) return this.click(), 
                    !1;
                },
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },
            beforeunload: {
                postDispatch: function(event) {
                    void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result);
                }
            }
        }
    }, jQuery.removeEvent = function(elem, type, handle) {
        elem.removeEventListener && elem.removeEventListener(type, handle);
    }, jQuery.Event = function(src, props) {
        return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, 
        this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && src.returnValue === !1 ? returnTrue : returnFalse, 
        this.target = src.target && 3 === src.target.nodeType ? src.target.parentNode : src.target, 
        this.currentTarget = src.currentTarget, this.relatedTarget = src.relatedTarget) : this.type = src, 
        props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), 
        void (this[jQuery.expando] = !0)) : new jQuery.Event(src, props);
    }, jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: !1,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = returnTrue, e && !this.isSimulated && e.preventDefault();
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = returnTrue, e && !this.isSimulated && e.stopPropagation();
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = returnTrue, e && !this.isSimulated && e.stopImmediatePropagation(), 
            this.stopPropagation();
        }
    }, jQuery.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function(event) {
            var button = event.button;
            return null == event.which && rkeyEvent.test(event.type) ? null != event.charCode ? event.charCode : event.keyCode : !event.which && void 0 !== button && rmouseEvent.test(event.type) ? 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0 : event.which;
        }
    }, jQuery.event.addProp), jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,
            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                return related && (related === target || jQuery.contains(target, related)) || (event.type = handleObj.origType, 
                ret = handleObj.handler.apply(this, arguments), event.type = fix), ret;
            }
        };
    }), jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj, 
            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), 
            this;
            if ("object" == typeof types) {
                for (type in types) this.off(type, selector, types[type]);
                return this;
            }
            return selector !== !1 && "function" != typeof selector || (fn = selector, selector = void 0), 
            fn === !1 && (fn = returnFalse), this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });
    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    jQuery.extend({
        htmlPrefilter: function(html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = jQuery.contains(elem.ownerDocument, elem);
            if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem))) for (destElements = getAll(clone), 
            srcElements = getAll(elem), i = 0, l = srcElements.length; i < l; i++) fixInput(srcElements[i], destElements[i]);
            if (dataAndEvents) if (deepDataAndEvents) for (srcElements = srcElements || getAll(elem), 
            destElements = destElements || getAll(clone), i = 0, l = srcElements.length; i < l; i++) cloneCopyEvent(srcElements[i], destElements[i]); else cloneCopyEvent(elem, clone);
            return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), 
            clone;
        },
        cleanData: function(elems) {
            for (var data, elem, type, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++) if (acceptData(elem)) {
                if (data = elem[dataPriv.expando]) {
                    if (data.events) for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                    elem[dataPriv.expando] = void 0;
                }
                elem[dataUser.expando] && (elem[dataUser.expando] = void 0);
            }
        }
    }), jQuery.fn.extend({
        detach: function(selector) {
            return remove(this, selector, !0);
        },
        remove: function(selector) {
            return remove(this, selector);
        },
        text: function(value) {
            return access(this, function(value) {
                return void 0 === value ? jQuery.text(this) : this.empty().each(function() {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = value);
                });
            }, null, value, arguments.length);
        },
        append: function() {
            return domManip(this, arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },
        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },
        before: function() {
            return domManip(this, arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this);
            });
        },
        after: function() {
            return domManip(this, arguments, function(elem) {
                this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling);
            });
        },
        empty: function() {
            for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
            elem.textContent = "");
            return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
            return dataAndEvents = null != dataAndEvents && dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, 
            this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },
        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}, i = 0, l = this.length;
                if (void 0 === value && 1 === elem.nodeType) return elem.innerHTML;
                if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [ "", "" ])[1].toLowerCase()]) {
                    value = jQuery.htmlPrefilter(value);
                    try {
                        for (;i < l; i++) elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), 
                        elem.innerHTML = value);
                        elem = 0;
                    } catch (e) {}
                }
                elem && this.empty().append(value);
            }, null, value, arguments.length);
        },
        replaceWith: function() {
            var ignored = [];
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;
                jQuery.inArray(this, ignored) < 0 && (jQuery.cleanData(getAll(this)), parent && parent.replaceChild(elem, this));
            }, ignored);
        }
    }), jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; i <= last; i++) elems = i === last ? this : this.clone(!0), 
            jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
            return this.pushStack(ret);
        };
    });
    var rmargin = /^margin/, rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        return view && view.opener || (view = window), view.getComputedStyle(elem);
    };
    !function() {
        function computeStyleTests() {
            if (div) {
                div.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", 
                div.innerHTML = "", documentElement.appendChild(container);
                var divStyle = window.getComputedStyle(div);
                pixelPositionVal = "1%" !== divStyle.top, reliableMarginLeftVal = "2px" === divStyle.marginLeft, 
                boxSizingReliableVal = "4px" === divStyle.width, div.style.marginRight = "50%", 
                pixelMarginRightVal = "4px" === divStyle.marginRight, documentElement.removeChild(container), 
                div = null;
            }
        }
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
        div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", 
        support.clearCloneStyle = "content-box" === div.style.backgroundClip, container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", 
        container.appendChild(div), jQuery.extend(support, {
            pixelPosition: function() {
                return computeStyleTests(), pixelPositionVal;
            },
            boxSizingReliable: function() {
                return computeStyleTests(), boxSizingReliableVal;
            },
            pixelMarginRight: function() {
                return computeStyleTests(), pixelMarginRightVal;
            },
            reliableMarginLeft: function() {
                return computeStyleTests(), reliableMarginLeftVal;
            }
        }));
    }();
    var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }, cssPrefixes = [ "Webkit", "Moz", "ms" ], emptyStyle = document.createElement("div").style;
    jQuery.extend({
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {
                        var ret = curCSS(elem, "opacity");
                        return "" === ret ? "1" : ret;
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            float: "cssFloat"
        },
        style: function(elem, name, value, extra) {
            if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName), 
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value ? hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name] : (type = typeof value, 
                "string" === type && (ret = rcssNum.exec(value)) && ret[1] && (value = adjustCSS(elem, name, ret), 
                type = "number"), null != value && value === value && ("number" === type && (value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")), 
                support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), 
                hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (style[name] = value)), 
                void 0);
            }
        },
        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);
            return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName), 
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)), 
            void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), 
            "" === extra || extra ? (num = parseFloat(val), extra === !0 || isFinite(num) ? num || 0 : val) : val;
        }
    }), jQuery.each([ "height", "width" ], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) return !rdisplayswap.test(jQuery.css(elem, "display")) || elem.getClientRects().length && elem.getBoundingClientRect().width ? getWidthOrHeight(elem, name, extra) : swap(elem, cssShow, function() {
                    return getWidthOrHeight(elem, name, extra);
                });
            },
            set: function(elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles);
                return subtract && (matches = rcssNum.exec(value)) && "px" !== (matches[3] || "px") && (elem.style[name] = value, 
                value = jQuery.css(elem, name)), setPositiveNumber(elem, value, subtract);
            }
        };
    }), jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
            marginLeft: 0
        }, function() {
            return elem.getBoundingClientRect().left;
        })) + "px";
    }), jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [ value ]; i < 4; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                return expanded;
            }
        }, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber);
    }), jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;
                if (jQuery.isArray(name)) {
                    for (styles = getStyles(elem), len = name.length; i < len; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                    return map;
                }
                return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        }
    }), jQuery.Tween = Tween, Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem, this.prop = prop, this.easing = easing || jQuery.easing._default, 
            this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];
            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];
            return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, 
            this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), 
            hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this;
        }
    }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;
                return 1 !== tween.elem.nodeType || null != tween.elem[tween.prop] && null == tween.elem.style[tween.prop] ? tween.elem[tween.prop] : (result = jQuery.css(tween.elem, tween.prop, ""), 
                result && "auto" !== result ? result : 0);
            },
            set: function(tween) {
                jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : 1 !== tween.elem.nodeType || null == tween.elem.style[jQuery.cssProps[tween.prop]] && !jQuery.cssHooks[tween.prop] ? tween.elem[tween.prop] = tween.now : jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            }
        }
    }, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now);
        }
    }, jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return .5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [ function(prop, value) {
                var tween = this.createTween(prop, value);
                return adjustCSS(tween.elem, prop, rcssNum.exec(value), tween), tween;
            } ]
        },
        tweener: function(props, callback) {
            jQuery.isFunction(props) ? (callback = props, props = [ "*" ]) : props = props.match(rnothtmlwhite);
            for (var prop, index = 0, length = props.length; index < length; index++) prop = props[index], 
            Animation.tweeners[prop] = Animation.tweeners[prop] || [], Animation.tweeners[prop].unshift(callback);
        },
        prefilters: [ defaultPrefilter ],
        prefilter: function(callback, prepend) {
            prepend ? Animation.prefilters.unshift(callback) : Animation.prefilters.push(callback);
        }
    }), jQuery.speed = function(speed, easing, fn) {
        var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };
        return jQuery.fx.off || document.hidden ? opt.duration = 0 : "number" != typeof opt.duration && (opt.duration in jQuery.fx.speeds ? opt.duration = jQuery.fx.speeds[opt.duration] : opt.duration = jQuery.fx.speeds._default), 
        null != opt.queue && opt.queue !== !0 || (opt.queue = "fx"), opt.old = opt.complete, 
        opt.complete = function() {
            jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue);
        }, opt;
    }, jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
            return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
                var anim = Animation(this, jQuery.extend({}, prop), optall);
                (empty || dataPriv.get(this, "finish")) && anim.stop(!0);
            };
            return doAnimation.finish = doAnimation, empty || optall.queue === !1 ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop, stop(gotoEnd);
            };
            return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), 
            clearQueue && type !== !1 && this.queue(type || "fx", []), this.each(function() {
                var dequeue = !0, index = null != type && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                if (index) data[index] && data[index].stop && stopQueue(data[index]); else for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                for (index = timers.length; index--; ) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), 
                dequeue = !1, timers.splice(index, 1));
                !dequeue && gotoEnd || jQuery.dequeue(this, type);
            });
        },
        finish: function(type) {
            return type !== !1 && (type = type || "fx"), this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), 
                index = timers.length; index--; ) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), 
                timers.splice(index, 1));
                for (index = 0; index < length; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                delete data.finish;
            });
        }
    }), jQuery.each([ "toggle", "show", "hide" ], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback);
        };
    }), jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        };
    }), jQuery.timers = [], jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        for (fxNow = jQuery.now(); i < timers.length; i++) timer = timers[i], timer() || timers[i] !== timer || timers.splice(i--, 1);
        timers.length || jQuery.fx.stop(), fxNow = void 0;
    }, jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer), timer() ? jQuery.fx.start() : jQuery.timers.pop();
    }, jQuery.fx.interval = 13, jQuery.fx.start = function() {
        timerId || (timerId = window.requestAnimationFrame ? window.requestAnimationFrame(raf) : window.setInterval(jQuery.fx.tick, jQuery.fx.interval));
    }, jQuery.fx.stop = function() {
        window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : window.clearInterval(timerId), 
        timerId = null;
    }, jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    }, jQuery.fn.delay = function(time, type) {
        return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time, type = type || "fx", 
        this.queue(type, function(next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function() {
                window.clearTimeout(timeout);
            };
        });
    }, function() {
        var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
        input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, 
        input = document.createElement("input"), input.value = "t", input.type = "radio", 
        support.radioValue = "t" === input.value;
    }();
    var boolHook, attrHandle = jQuery.expr.attrHandle;
    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    }), jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (3 !== nType && 8 !== nType && 2 !== nType) return "undefined" == typeof elem.getAttribute ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0)), 
            void 0 !== value ? null === value ? void jQuery.removeAttr(elem, name) : hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), 
            value) : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name), 
            null == ret ? void 0 : ret));
        },
        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        return elem.setAttribute("type", value), val && (elem.value = val), value;
                    }
                }
            }
        },
        removeAttr: function(elem, value) {
            var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
            if (attrNames && 1 === elem.nodeType) for (;name = attrNames[i++]; ) elem.removeAttribute(name);
        }
    }), boolHook = {
        set: function(elem, value, name) {
            return value === !1 ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name), 
            name;
        }
    }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle, lowercaseName = name.toLowerCase();
            return isXML || (handle = attrHandle[lowercaseName], attrHandle[lowercaseName] = ret, 
            ret = null != getter(elem, name, isXML) ? lowercaseName : null, attrHandle[lowercaseName] = handle), 
            ret;
        };
    });
    var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    }), jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;
            if (3 !== nType && 8 !== nType && 2 !== nType) return 1 === nType && jQuery.isXMLDoc(elem) || (name = jQuery.propFix[name] || name, 
            hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name];
        },
        propHooks: {
            tabIndex: {
                get: function(elem) {
                    var tabindex = jQuery.find.attr(elem, "tabindex");
                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        },
        propFix: {
            for: "htmlFor",
            class: "className"
        }
    }), support.optSelected || (jQuery.propHooks.selected = {
        get: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.parentNode && parent.parentNode.selectedIndex, null;
        },
        set: function(elem) {
            var parent = elem.parentNode;
            parent && (parent.selectedIndex, parent.parentNode && parent.parentNode.selectedIndex);
        }
    }), jQuery.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    }), jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
            if ("string" == typeof value && value) for (classes = value.match(rnothtmlwhite) || []; elem = this[i++]; ) if (curValue = getClass(elem), 
            cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                for (j = 0; clazz = classes[j++]; ) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                finalValue = stripAndCollapse(cur), curValue !== finalValue && elem.setAttribute("class", finalValue);
            }
            return this;
        },
        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
            if (jQuery.isFunction(value)) return this.each(function(j) {
                jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
            if (!arguments.length) return this.attr("class", "");
            if ("string" == typeof value && value) for (classes = value.match(rnothtmlwhite) || []; elem = this[i++]; ) if (curValue = getClass(elem), 
            cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                for (j = 0; clazz = classes[j++]; ) for (;cur.indexOf(" " + clazz + " ") > -1; ) cur = cur.replace(" " + clazz + " ", " ");
                finalValue = stripAndCollapse(cur), curValue !== finalValue && elem.setAttribute("class", finalValue);
            }
            return this;
        },
        toggleClass: function(value, stateVal) {
            var type = typeof value;
            return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : jQuery.isFunction(value) ? this.each(function(i) {
                jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
            }) : this.each(function() {
                var className, i, self, classNames;
                if ("string" === type) for (i = 0, self = jQuery(this), classNames = value.match(rnothtmlwhite) || []; className = classNames[i++]; ) self.hasClass(className) ? self.removeClass(className) : self.addClass(className); else void 0 !== value && "boolean" !== type || (className = getClass(this), 
                className && dataPriv.set(this, "__className__", className), this.setAttribute && this.setAttribute("class", className || value === !1 ? "" : dataPriv.get(this, "__className__") || ""));
            });
        },
        hasClass: function(selector) {
            var className, elem, i = 0;
            for (className = " " + selector + " "; elem = this[i++]; ) if (1 === elem.nodeType && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return !0;
            return !1;
        }
    });
    var rreturn = /\r/g;
    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];
            {
                if (arguments.length) return isFunction = jQuery.isFunction(value), this.each(function(i) {
                    var val;
                    1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value, 
                    null == val ? val = "" : "number" == typeof val ? val += "" : jQuery.isArray(val) && (val = jQuery.map(val, function(value) {
                        return null == value ? "" : value + "";
                    })), hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()], 
                    hooks && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val));
                });
                if (elem) return hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()], 
                hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value, 
                "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret);
            }
        }
    }), jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {
                    var val = jQuery.find.attr(elem, "value");
                    return null != val ? val : stripAndCollapse(jQuery.text(elem));
                }
            },
            select: {
                get: function(elem) {
                    var value, option, i, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type, values = one ? null : [], max = one ? index + 1 : options.length;
                    for (i = index < 0 ? max : one ? index : 0; i < max; i++) if (option = options[i], 
                    (option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                        if (value = jQuery(option).val(), one) return value;
                        values.push(value);
                    }
                    return values;
                },
                set: function(elem, value) {
                    for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--; ) option = options[i], 
                    (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) && (optionSet = !0);
                    return optionSet || (elem.selectedIndex = -1), values;
                }
            }
        }
    }), jQuery.each([ "radio", "checkbox" ], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
        }, support.checkOn || (jQuery.valHooks[this].get = function(elem) {
            return null === elem.getAttribute("value") ? "on" : elem.value;
        });
    });
    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
    jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [ elem || document ], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
            if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") > -1 && (namespaces = type.split("."), 
            type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, 
            event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event), 
            event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), 
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, 
            event.result = void 0, event.target || (event.target = elem), data = null == data ? [ event ] : jQuery.makeArray(data, [ event ]), 
            special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || special.trigger.apply(elem, data) !== !1)) {
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), 
                    tmp = cur;
                    tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
                for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped(); ) event.type = i > 1 ? bubbleType : special.bindType || type, 
                handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle"), 
                handle && handle.apply(cur, data), handle = ontype && cur[ontype], handle && handle.apply && acceptData(cur) && (event.result = handle.apply(cur, data), 
                event.result === !1 && event.preventDefault());
                return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && special._default.apply(eventPath.pop(), data) !== !1 || !acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype], 
                tmp && (elem[ontype] = null), jQuery.event.triggered = type, elem[type](), jQuery.event.triggered = void 0, 
                tmp && (elem[ontype] = tmp)), event.result;
            }
        },
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: !0
            });
            jQuery.event.trigger(e, null, elem);
        }
    }), jQuery.fn.extend({
        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) return jQuery.event.trigger(type, data, elem, !0);
        }
    }), jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(i, name) {
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
    }), jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    }), support.focusin = "onfocusin" in window, support.focusin || jQuery.each({
        focus: "focusin",
        blur: "focusout"
    }, function(orig, fix) {
        var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
        };
        jQuery.event.special[fix] = {
            setup: function() {
                var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                attaches || doc.addEventListener(orig, handler, !0), dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
                var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                attaches ? dataPriv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), 
                dataPriv.remove(doc, fix));
            }
        };
    });
    var location = window.location, nonce = jQuery.now(), rquery = /\?/;
    jQuery.parseXML = function(data) {
        var xml;
        if (!data || "string" != typeof data) return null;
        try {
            xml = new window.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
            xml = void 0;
        }
        return xml && !xml.getElementsByTagName("parsererror").length || jQuery.error("Invalid XML: " + data), 
        xml;
    };
    var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
            var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(null == value ? "" : value);
        };
        if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function() {
            add(this.name, this.value);
        }); else for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
        return s.join("&");
    }, jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();
                return null == val ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });
    var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document.createElement("a");
    originAnchor.href = location.href, jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": JSON.parse,
                "text xml": jQuery.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(target, settings) {
            return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                completed || (completed = !0, timeoutTimer && window.clearTimeout(timeoutTimer), 
                transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, 
                isSuccess = status >= 200 && status < 300 || 304 === status, responses && (response = ajaxHandleResponses(s, jqXHR, responses)), 
                response = ajaxConvert(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), 
                modified && (jQuery.lastModified[cacheURL] = modified), modified = jqXHR.getResponseHeader("etag"), 
                modified && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, 
                success = response.data, error = response.error, isSuccess = !error)) : (error = statusText, 
                !status && statusText || (statusText = "error", status < 0 && (status = 0))), jqXHR.status = status, 
                jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [ success, statusText, jqXHR ]) : deferred.rejectWith(callbackContext, [ jqXHR, statusText, error ]), 
                jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [ jqXHR, s, isSuccess ? success : error ]), 
                completeDeferred.fireWith(callbackContext, [ jqXHR, statusText ]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [ jqXHR, s ]), 
                --jQuery.active || jQuery.event.trigger("ajaxStop")));
            }
            "object" == typeof url && (options = url, url = void 0), options = options || {};
            var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
                readyState: 0,
                getResponseHeader: function(key) {
                    var match;
                    if (completed) {
                        if (!responseHeaders) for (responseHeaders = {}; match = rheaders.exec(responseHeadersString); ) responseHeaders[match[1].toLowerCase()] = match[2];
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return null == match ? null : match;
                },
                getAllResponseHeaders: function() {
                    return completed ? responseHeadersString : null;
                },
                setRequestHeader: function(name, value) {
                    return null == completed && (name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name, 
                    requestHeaders[name] = value), this;
                },
                overrideMimeType: function(type) {
                    return null == completed && (s.mimeType = type), this;
                },
                statusCode: function(map) {
                    var code;
                    if (map) if (completed) jqXHR.always(map[jqXHR.status]); else for (code in map) statusCode[code] = [ statusCode[code], map[code] ];
                    return this;
                },
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    return transport && transport.abort(finalText), done(0, finalText), this;
                }
            };
            if (deferred.promise(jqXHR), s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"), 
            s.type = options.method || options.type || s.method || s.type, s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [ "" ], 
            null == s.crossDomain) {
                urlAnchor = document.createElement("a");
                try {
                    urlAnchor.href = s.url, urlAnchor.href = urlAnchor.href, s.crossDomain = originAnchor.protocol + "//" + originAnchor.host != urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {
                    s.crossDomain = !0;
                }
            }
            if (s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), 
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), completed) return jqXHR;
            fireGlobals = jQuery.event && s.global, fireGlobals && 0 === jQuery.active++ && jQuery.event.trigger("ajaxStart"), 
            s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url.replace(rhash, ""), 
            s.hasContent ? s.data && s.processData && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && (s.data = s.data.replace(r20, "+")) : (uncached = s.url.slice(cacheURL.length), 
            s.data && (cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), 
            s.cache === !1 && (cacheURL = cacheURL.replace(rantiCache, "$1"), uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached), 
            s.url = cacheURL + uncached), s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), 
            jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), 
            (s.data && s.hasContent && s.contentType !== !1 || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), 
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
            for (i in s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === !1 || completed)) return jqXHR.abort();
            if (strAbort = "abort", completeDeferred.add(s.complete), jqXHR.done(s.success), 
            jqXHR.fail(s.error), transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                if (jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [ jqXHR, s ]), 
                completed) return jqXHR;
                s.async && s.timeout > 0 && (timeoutTimer = window.setTimeout(function() {
                    jqXHR.abort("timeout");
                }, s.timeout));
                try {
                    completed = !1, transport.send(requestHeaders, done);
                } catch (e) {
                    if (completed) throw e;
                    done(-1, e);
                }
            } else done(-1, "No Transport");
            return jqXHR;
        },
        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
            return jQuery.get(url, void 0, callback, "script");
        }
    }), jQuery.each([ "get", "post" ], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {
            return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), 
            jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        };
    }), jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,
            type: "GET",
            dataType: "script",
            cache: !0,
            async: !1,
            global: !1,
            throws: !0
        });
    }, jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;
            return this[0] && (jQuery.isFunction(html) && (html = html.call(this[0])), wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), 
            this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function() {
                for (var elem = this; elem.firstElementChild; ) elem = elem.firstElementChild;
                return elem;
            }).append(this)), this;
        },
        wrapInner: function(html) {
            return jQuery.isFunction(html) ? this.each(function(i) {
                jQuery(this).wrapInner(html.call(this, i));
            }) : this.each(function() {
                var self = jQuery(this), contents = self.contents();
                contents.length ? contents.wrapAll(html) : self.append(html);
            });
        },
        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);
            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },
        unwrap: function(selector) {
            return this.parent(selector).not("body").each(function() {
                jQuery(this).replaceWith(this.childNodes);
            }), this;
        }
    }), jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
    }, jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
    }, jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    };
    var xhrSuccessStatus = {
        0: 200,
        1223: 204
    }, xhrSupported = jQuery.ajaxSettings.xhr();
    support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, 
    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) return {
            send: function(headers, complete) {
                var i, xhr = options.xhr();
                if (xhr.open(options.type, options.url, options.async, options.username, options.password), 
                options.xhrFields) for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), 
                options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                for (i in headers) xhr.setRequestHeader(i, headers[i]);
                callback = function(type) {
                    return function() {
                        callback && (callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null, 
                        "abort" === type ? xhr.abort() : "error" === type ? "number" != typeof xhr.status ? complete(0, "error") : complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "text" !== (xhr.responseType || "text") || "string" != typeof xhr.responseText ? {
                            binary: xhr.response
                        } : {
                            text: xhr.responseText
                        }, xhr.getAllResponseHeaders()));
                    };
                }, xhr.onload = callback(), errorCallback = xhr.onerror = callback("error"), void 0 !== xhr.onabort ? xhr.onabort = errorCallback : xhr.onreadystatechange = function() {
                    4 === xhr.readyState && window.setTimeout(function() {
                        callback && errorCallback();
                    });
                }, callback = callback("abort");
                try {
                    xhr.send(options.hasContent && options.data || null);
                } catch (e) {
                    if (callback) throw e;
                }
            },
            abort: function() {
                callback && callback();
            }
        };
    }), jQuery.ajaxPrefilter(function(s) {
        s.crossDomain && (s.contents.script = !1);
    }), jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                return jQuery.globalEval(text), text;
            }
        }
    }), jQuery.ajaxPrefilter("script", function(s) {
        void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET");
    }), jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type);
                    }), document.head.appendChild(script[0]);
                },
                abort: function() {
                    callback && callback();
                }
            };
        }
    });
    var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
            return this[callback] = !0, callback;
        }
    }), jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== !1 && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
        if (jsonProp || "jsonp" === s.dataTypes[0]) return callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, 
        jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : s.jsonp !== !1 && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), 
        s.converters["script json"] = function() {
            return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0];
        }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function() {
            responseContainer = arguments;
        }, jqXHR.always(function() {
            void 0 === overwritten ? jQuery(window).removeProp(callbackName) : window[callbackName] = overwritten, 
            s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)), 
            responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), 
            responseContainer = overwritten = void 0;
        }), "script";
    }), support.createHTMLDocument = function() {
        var body = document.implementation.createHTMLDocument("").body;
        return body.innerHTML = "<form></form><form></form>", 2 === body.childNodes.length;
    }(), jQuery.parseHTML = function(data, context, keepScripts) {
        if ("string" != typeof data) return [];
        "boolean" == typeof context && (keepScripts = context, context = !1);
        var base, parsed, scripts;
        return context || (support.createHTMLDocument ? (context = document.implementation.createHTMLDocument(""), 
        base = context.createElement("base"), base.href = document.location.href, context.head.appendChild(base)) : context = document), 
        parsed = rsingleTag.exec(data), scripts = !keepScripts && [], parsed ? [ context.createElement(parsed[1]) ] : (parsed = buildFragment([ data ], context, scripts), 
        scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes));
    }, jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self = this, off = url.indexOf(" ");
        return off > -1 && (selector = stripAndCollapse(url.slice(off)), url = url.slice(0, off)), 
        jQuery.isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), 
        self.length > 0 && jQuery.ajax({
            url: url,
            type: type || "GET",
            dataType: "html",
            data: params
        }).done(function(responseText) {
            response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
        }).always(callback && function(jqXHR, status) {
            self.each(function() {
                callback.apply(this, response || [ jqXHR.responseText, status, jqXHR ]);
            });
        }), this;
    }, jQuery.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        };
    }), jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    }, jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
            "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), 
            curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1, 
            calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, 
            curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), 
            jQuery.isFunction(options) && (options = options.call(elem, i, jQuery.extend({}, curOffset))), 
            null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft), 
            "using" in options ? options.using.call(elem, props) : curElem.css(props);
        }
    }, jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) return void 0 === options ? this : this.each(function(i) {
                jQuery.offset.setOffset(this, options, i);
            });
            var docElem, win, rect, doc, elem = this[0];
            if (elem) return elem.getClientRects().length ? (rect = elem.getBoundingClientRect(), 
            rect.width || rect.height ? (doc = elem.ownerDocument, win = getWindow(doc), docElem = doc.documentElement, 
            {
                top: rect.top + win.pageYOffset - docElem.clientTop,
                left: rect.left + win.pageXOffset - docElem.clientLeft
            }) : rect) : {
                top: 0,
                left: 0
            };
        },
        position: function() {
            if (this[0]) {
                var offsetParent, offset, elem = this[0], parentOffset = {
                    top: 0,
                    left: 0
                };
                return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), 
                offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), 
                parentOffset = {
                    top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", !0),
                    left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", !0)
                }), {
                    top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                    left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                };
            }
        },
        offsetParent: function() {
            return this.map(function() {
                for (var offsetParent = this.offsetParent; offsetParent && "static" === jQuery.css(offsetParent, "position"); ) offsetParent = offsetParent.offsetParent;
                return offsetParent || documentElement;
            });
        }
    }), jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;
        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);
                return void 0 === val ? win ? win[prop] : elem[method] : void (win ? win.scrollTo(top ? win.pageXOffset : val, top ? val : win.pageYOffset) : elem[method] = val);
            }, method, val, arguments.length);
        };
    }), jQuery.each([ "top", "left" ], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) return computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
        });
    }), jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin), extra = defaultExtra || (margin === !0 || value === !0 ? "margin" : "border");
                return access(this, function(elem, type, value) {
                    var doc;
                    return jQuery.isWindow(elem) ? 0 === funcName.indexOf("outer") ? elem["inner" + name] : elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, 
                    Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : void 0, chainable);
            };
        });
    }), jQuery.fn.extend({
        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
            return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        }
    }), jQuery.parseJSON = JSON.parse, "function" == typeof define && define.amd && define("jquery", [], function() {
        return jQuery;
    });
    var _jQuery = window.jQuery, _$ = window.$;
    return jQuery.noConflict = function(deep) {
        return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), 
        jQuery;
    }, noGlobal || (window.jQuery = window.$ = jQuery), jQuery;
}), function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : factory("object" == typeof exports ? require("jquery") : jQuery);
}(function(jQuery) {
    var S2 = function() {
        if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) var S2 = jQuery.fn.select2.amd;
        var S2;
        return function() {
            if (!S2 || !S2.requirejs) {
                S2 ? require = S2 : S2 = {};
                var requirejs, require, define;
                !function(undef) {
                    function hasProp(obj, prop) {
                        return hasOwn.call(obj, prop);
                    }
                    function normalize(name, baseName) {
                        var nameParts, nameSegment, mapValue, foundMap, lastIndex, foundI, foundStarMap, starI, i, j, part, baseParts = baseName && baseName.split("/"), map = config.map, starMap = map && map["*"] || {};
                        if (name && "." === name.charAt(0)) if (baseName) {
                            for (name = name.split("/"), lastIndex = name.length - 1, config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex]) && (name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, "")), 
                            name = baseParts.slice(0, baseParts.length - 1).concat(name), i = 0; i < name.length; i += 1) if (part = name[i], 
                            "." === part) name.splice(i, 1), i -= 1; else if (".." === part) {
                                if (1 === i && (".." === name[2] || ".." === name[0])) break;
                                i > 0 && (name.splice(i - 1, 2), i -= 2);
                            }
                            name = name.join("/");
                        } else 0 === name.indexOf("./") && (name = name.substring(2));
                        if ((baseParts || starMap) && map) {
                            for (nameParts = name.split("/"), i = nameParts.length; i > 0; i -= 1) {
                                if (nameSegment = nameParts.slice(0, i).join("/"), baseParts) for (j = baseParts.length; j > 0; j -= 1) if (mapValue = map[baseParts.slice(0, j).join("/")], 
                                mapValue && (mapValue = mapValue[nameSegment])) {
                                    foundMap = mapValue, foundI = i;
                                    break;
                                }
                                if (foundMap) break;
                                !foundStarMap && starMap && starMap[nameSegment] && (foundStarMap = starMap[nameSegment], 
                                starI = i);
                            }
                            !foundMap && foundStarMap && (foundMap = foundStarMap, foundI = starI), foundMap && (nameParts.splice(0, foundI, foundMap), 
                            name = nameParts.join("/"));
                        }
                        return name;
                    }
                    function makeRequire(relName, forceSync) {
                        return function() {
                            var args = aps.call(arguments, 0);
                            return "string" != typeof args[0] && 1 === args.length && args.push(null), req.apply(undef, args.concat([ relName, forceSync ]));
                        };
                    }
                    function makeNormalize(relName) {
                        return function(name) {
                            return normalize(name, relName);
                        };
                    }
                    function makeLoad(depName) {
                        return function(value) {
                            defined[depName] = value;
                        };
                    }
                    function callDep(name) {
                        if (hasProp(waiting, name)) {
                            var args = waiting[name];
                            delete waiting[name], defining[name] = !0, main.apply(undef, args);
                        }
                        if (!hasProp(defined, name) && !hasProp(defining, name)) throw new Error("No " + name);
                        return defined[name];
                    }
                    function splitPrefix(name) {
                        var prefix, index = name ? name.indexOf("!") : -1;
                        return index > -1 && (prefix = name.substring(0, index), name = name.substring(index + 1, name.length)), 
                        [ prefix, name ];
                    }
                    function makeConfig(name) {
                        return function() {
                            return config && config.config && config.config[name] || {};
                        };
                    }
                    var main, req, makeMap, handlers, defined = {}, waiting = {}, config = {}, defining = {}, hasOwn = Object.prototype.hasOwnProperty, aps = [].slice, jsSuffixRegExp = /\.js$/;
                    makeMap = function(name, relName) {
                        var plugin, parts = splitPrefix(name), prefix = parts[0];
                        return name = parts[1], prefix && (prefix = normalize(prefix, relName), plugin = callDep(prefix)), 
                        prefix ? name = plugin && plugin.normalize ? plugin.normalize(name, makeNormalize(relName)) : normalize(name, relName) : (name = normalize(name, relName), 
                        parts = splitPrefix(name), prefix = parts[0], name = parts[1], prefix && (plugin = callDep(prefix))), 
                        {
                            f: prefix ? prefix + "!" + name : name,
                            n: name,
                            pr: prefix,
                            p: plugin
                        };
                    }, handlers = {
                        require: function(name) {
                            return makeRequire(name);
                        },
                        exports: function(name) {
                            var e = defined[name];
                            return "undefined" != typeof e ? e : defined[name] = {};
                        },
                        module: function(name) {
                            return {
                                id: name,
                                uri: "",
                                exports: defined[name],
                                config: makeConfig(name)
                            };
                        }
                    }, main = function(name, deps, callback, relName) {
                        var cjsModule, depName, ret, map, i, usingExports, args = [], callbackType = typeof callback;
                        if (relName = relName || name, "undefined" === callbackType || "function" === callbackType) {
                            for (deps = !deps.length && callback.length ? [ "require", "exports", "module" ] : deps, 
                            i = 0; i < deps.length; i += 1) if (map = makeMap(deps[i], relName), depName = map.f, 
                            "require" === depName) args[i] = handlers.require(name); else if ("exports" === depName) args[i] = handlers.exports(name), 
                            usingExports = !0; else if ("module" === depName) cjsModule = args[i] = handlers.module(name); else if (hasProp(defined, depName) || hasProp(waiting, depName) || hasProp(defining, depName)) args[i] = callDep(depName); else {
                                if (!map.p) throw new Error(name + " missing " + depName);
                                map.p.load(map.n, makeRequire(relName, !0), makeLoad(depName), {}), args[i] = defined[depName];
                            }
                            ret = callback ? callback.apply(defined[name], args) : void 0, name && (cjsModule && cjsModule.exports !== undef && cjsModule.exports !== defined[name] ? defined[name] = cjsModule.exports : ret === undef && usingExports || (defined[name] = ret));
                        } else name && (defined[name] = callback);
                    }, requirejs = require = req = function(deps, callback, relName, forceSync, alt) {
                        if ("string" == typeof deps) return handlers[deps] ? handlers[deps](callback) : callDep(makeMap(deps, callback).f);
                        if (!deps.splice) {
                            if (config = deps, config.deps && req(config.deps, config.callback), !callback) return;
                            callback.splice ? (deps = callback, callback = relName, relName = null) : deps = undef;
                        }
                        return callback = callback || function() {}, "function" == typeof relName && (relName = forceSync, 
                        forceSync = alt), forceSync ? main(undef, deps, callback, relName) : setTimeout(function() {
                            main(undef, deps, callback, relName);
                        }, 4), req;
                    }, req.config = function(cfg) {
                        return req(cfg);
                    }, requirejs._defined = defined, define = function(name, deps, callback) {
                        if ("string" != typeof name) throw new Error("See almond README: incorrect module build, no module name");
                        deps.splice || (callback = deps, deps = []), hasProp(defined, name) || hasProp(waiting, name) || (waiting[name] = [ name, deps, callback ]);
                    }, define.amd = {
                        jQuery: !0
                    };
                }(), S2.requirejs = requirejs, S2.require = require, S2.define = define;
            }
        }(), S2.define("almond", function() {}), S2.define("jquery", [], function() {
            var _$ = jQuery || $;
            return null == _$ && console && console.error && console.error("Select2: An instance of jQuery or a jQuery-compatible library was not found. Make sure that you are including jQuery before Select2 on your web page."), 
            _$;
        }), S2.define("select2/utils", [ "jquery" ], function($) {
            function getMethods(theClass) {
                var proto = theClass.prototype, methods = [];
                for (var methodName in proto) {
                    var m = proto[methodName];
                    "function" == typeof m && "constructor" !== methodName && methods.push(methodName);
                }
                return methods;
            }
            var Utils = {};
            Utils.Extend = function(ChildClass, SuperClass) {
                function BaseConstructor() {
                    this.constructor = ChildClass;
                }
                var __hasProp = {}.hasOwnProperty;
                for (var key in SuperClass) __hasProp.call(SuperClass, key) && (ChildClass[key] = SuperClass[key]);
                return BaseConstructor.prototype = SuperClass.prototype, ChildClass.prototype = new BaseConstructor(), 
                ChildClass.__super__ = SuperClass.prototype, ChildClass;
            }, Utils.Decorate = function(SuperClass, DecoratorClass) {
                function DecoratedClass() {
                    var unshift = Array.prototype.unshift, argCount = DecoratorClass.prototype.constructor.length, calledConstructor = SuperClass.prototype.constructor;
                    argCount > 0 && (unshift.call(arguments, SuperClass.prototype.constructor), calledConstructor = DecoratorClass.prototype.constructor), 
                    calledConstructor.apply(this, arguments);
                }
                function ctr() {
                    this.constructor = DecoratedClass;
                }
                var decoratedMethods = getMethods(DecoratorClass), superMethods = getMethods(SuperClass);
                DecoratorClass.displayName = SuperClass.displayName, DecoratedClass.prototype = new ctr();
                for (var m = 0; m < superMethods.length; m++) {
                    var superMethod = superMethods[m];
                    DecoratedClass.prototype[superMethod] = SuperClass.prototype[superMethod];
                }
                for (var calledMethod = (function(methodName) {
                    var originalMethod = function() {};
                    methodName in DecoratedClass.prototype && (originalMethod = DecoratedClass.prototype[methodName]);
                    var decoratedMethod = DecoratorClass.prototype[methodName];
                    return function() {
                        var unshift = Array.prototype.unshift;
                        return unshift.call(arguments, originalMethod), decoratedMethod.apply(this, arguments);
                    };
                }), d = 0; d < decoratedMethods.length; d++) {
                    var decoratedMethod = decoratedMethods[d];
                    DecoratedClass.prototype[decoratedMethod] = calledMethod(decoratedMethod);
                }
                return DecoratedClass;
            };
            var Observable = function() {
                this.listeners = {};
            };
            return Observable.prototype.on = function(event, callback) {
                this.listeners = this.listeners || {}, event in this.listeners ? this.listeners[event].push(callback) : this.listeners[event] = [ callback ];
            }, Observable.prototype.trigger = function(event) {
                var slice = Array.prototype.slice, params = slice.call(arguments, 1);
                this.listeners = this.listeners || {}, null == params && (params = []), 0 === params.length && params.push({}), 
                params[0]._type = event, event in this.listeners && this.invoke(this.listeners[event], slice.call(arguments, 1)), 
                "*" in this.listeners && this.invoke(this.listeners["*"], arguments);
            }, Observable.prototype.invoke = function(listeners, params) {
                for (var i = 0, len = listeners.length; i < len; i++) listeners[i].apply(this, params);
            }, Utils.Observable = Observable, Utils.generateChars = function(length) {
                for (var chars = "", i = 0; i < length; i++) {
                    var randomChar = Math.floor(36 * Math.random());
                    chars += randomChar.toString(36);
                }
                return chars;
            }, Utils.bind = function(func, context) {
                return function() {
                    func.apply(context, arguments);
                };
            }, Utils._convertData = function(data) {
                for (var originalKey in data) {
                    var keys = originalKey.split("-"), dataLevel = data;
                    if (1 !== keys.length) {
                        for (var k = 0; k < keys.length; k++) {
                            var key = keys[k];
                            key = key.substring(0, 1).toLowerCase() + key.substring(1), key in dataLevel || (dataLevel[key] = {}), 
                            k == keys.length - 1 && (dataLevel[key] = data[originalKey]), dataLevel = dataLevel[key];
                        }
                        delete data[originalKey];
                    }
                }
                return data;
            }, Utils.hasScroll = function(index, el) {
                var $el = $(el), overflowX = el.style.overflowX, overflowY = el.style.overflowY;
                return (overflowX !== overflowY || "hidden" !== overflowY && "visible" !== overflowY) && ("scroll" === overflowX || "scroll" === overflowY || ($el.innerHeight() < el.scrollHeight || $el.innerWidth() < el.scrollWidth));
            }, Utils.escapeMarkup = function(markup) {
                var replaceMap = {
                    "\\": "&#92;",
                    "&": "&amp;",
                    "<": "&lt;",
                    ">": "&gt;",
                    '"': "&quot;",
                    "'": "&#39;",
                    "/": "&#47;"
                };
                return "string" != typeof markup ? markup : String(markup).replace(/[&<>"'\/\\]/g, function(match) {
                    return replaceMap[match];
                });
            }, Utils.appendMany = function($element, $nodes) {
                if ("1.7" === $.fn.jquery.substr(0, 3)) {
                    var $jqNodes = $();
                    $.map($nodes, function(node) {
                        $jqNodes = $jqNodes.add(node);
                    }), $nodes = $jqNodes;
                }
                $element.append($nodes);
            }, Utils;
        }), S2.define("select2/results", [ "jquery", "./utils" ], function($, Utils) {
            function Results($element, options, dataAdapter) {
                this.$element = $element, this.data = dataAdapter, this.options = options, Results.__super__.constructor.call(this);
            }
            return Utils.Extend(Results, Utils.Observable), Results.prototype.render = function() {
                var $results = $('<ul class="select2-results__options" role="tree"></ul>');
                return this.options.get("multiple") && $results.attr("aria-multiselectable", "true"), 
                this.$results = $results, $results;
            }, Results.prototype.clear = function() {
                this.$results.empty();
            }, Results.prototype.displayMessage = function(params) {
                var escapeMarkup = this.options.get("escapeMarkup");
                this.clear(), this.hideLoading();
                var $message = $('<li role="treeitem" aria-live="assertive" class="select2-results__option"></li>'), message = this.options.get("translations").get(params.message);
                $message.append(escapeMarkup(message(params.args))), $message[0].className += " select2-results__message", 
                this.$results.append($message);
            }, Results.prototype.hideMessages = function() {
                this.$results.find(".select2-results__message").remove();
            }, Results.prototype.append = function(data) {
                this.hideLoading();
                var $options = [];
                if (null == data.results || 0 === data.results.length) return void (0 === this.$results.children().length && this.trigger("results:message", {
                    message: "noResults"
                }));
                data.results = this.sort(data.results);
                for (var d = 0; d < data.results.length; d++) {
                    var item = data.results[d], $option = this.option(item);
                    $options.push($option);
                }
                this.$results.append($options);
            }, Results.prototype.position = function($results, $dropdown) {
                var $resultsContainer = $dropdown.find(".select2-results");
                $resultsContainer.append($results);
            }, Results.prototype.sort = function(data) {
                var sorter = this.options.get("sorter");
                return sorter(data);
            }, Results.prototype.highlightFirstItem = function() {
                var $options = this.$results.find(".select2-results__option[aria-selected]"), $selected = $options.filter("[aria-selected=true]");
                $selected.length > 0 ? $selected.first().trigger("mouseenter") : $options.first().trigger("mouseenter"), 
                this.ensureHighlightVisible();
            }, Results.prototype.setClasses = function() {
                var self = this;
                this.data.current(function(selected) {
                    var selectedIds = $.map(selected, function(s) {
                        return s.id.toString();
                    }), $options = self.$results.find(".select2-results__option[aria-selected]");
                    $options.each(function() {
                        var $option = $(this), item = $.data(this, "data"), id = "" + item.id;
                        null != item.element && item.element.selected || null == item.element && $.inArray(id, selectedIds) > -1 ? $option.attr("aria-selected", "true") : $option.attr("aria-selected", "false");
                    });
                });
            }, Results.prototype.showLoading = function(params) {
                this.hideLoading();
                var loadingMore = this.options.get("translations").get("searching"), loading = {
                    disabled: !0,
                    loading: !0,
                    text: loadingMore(params)
                }, $loading = this.option(loading);
                $loading.className += " loading-results", this.$results.prepend($loading);
            }, Results.prototype.hideLoading = function() {
                this.$results.find(".loading-results").remove();
            }, Results.prototype.option = function(data) {
                var option = document.createElement("li");
                option.className = "select2-results__option";
                var attrs = {
                    role: "treeitem",
                    "aria-selected": "false"
                };
                data.disabled && (delete attrs["aria-selected"], attrs["aria-disabled"] = "true"), 
                null == data.id && delete attrs["aria-selected"], null != data._resultId && (option.id = data._resultId), 
                data.title && (option.title = data.title), data.children && (attrs.role = "group", 
                attrs["aria-label"] = data.text, delete attrs["aria-selected"]);
                for (var attr in attrs) {
                    var val = attrs[attr];
                    option.setAttribute(attr, val);
                }
                if (data.children) {
                    var $option = $(option), label = document.createElement("strong");
                    label.className = "select2-results__group";
                    $(label);
                    this.template(data, label);
                    for (var $children = [], c = 0; c < data.children.length; c++) {
                        var child = data.children[c], $child = this.option(child);
                        $children.push($child);
                    }
                    var $childrenContainer = $("<ul></ul>", {
                        class: "select2-results__options select2-results__options--nested"
                    });
                    $childrenContainer.append($children), $option.append(label), $option.append($childrenContainer);
                } else this.template(data, option);
                return $.data(option, "data", data), option;
            }, Results.prototype.bind = function(container, $container) {
                var self = this, id = container.id + "-results";
                this.$results.attr("id", id), container.on("results:all", function(params) {
                    self.clear(), self.append(params.data), container.isOpen() && (self.setClasses(), 
                    self.highlightFirstItem());
                }), container.on("results:append", function(params) {
                    self.append(params.data), container.isOpen() && self.setClasses();
                }), container.on("query", function(params) {
                    self.hideMessages(), self.showLoading(params);
                }), container.on("select", function() {
                    container.isOpen() && (self.setClasses(), self.highlightFirstItem());
                }), container.on("unselect", function() {
                    container.isOpen() && (self.setClasses(), self.highlightFirstItem());
                }), container.on("open", function() {
                    self.$results.attr("aria-expanded", "true"), self.$results.attr("aria-hidden", "false"), 
                    self.setClasses(), self.ensureHighlightVisible();
                }), container.on("close", function() {
                    self.$results.attr("aria-expanded", "false"), self.$results.attr("aria-hidden", "true"), 
                    self.$results.removeAttr("aria-activedescendant");
                }), container.on("results:toggle", function() {
                    var $highlighted = self.getHighlightedResults();
                    0 !== $highlighted.length && $highlighted.trigger("mouseup");
                }), container.on("results:select", function() {
                    var $highlighted = self.getHighlightedResults();
                    if (0 !== $highlighted.length) {
                        var data = $highlighted.data("data");
                        "true" == $highlighted.attr("aria-selected") ? self.trigger("close", {}) : self.trigger("select", {
                            data: data
                        });
                    }
                }), container.on("results:previous", function() {
                    var $highlighted = self.getHighlightedResults(), $options = self.$results.find("[aria-selected]"), currentIndex = $options.index($highlighted);
                    if (0 !== currentIndex) {
                        var nextIndex = currentIndex - 1;
                        0 === $highlighted.length && (nextIndex = 0);
                        var $next = $options.eq(nextIndex);
                        $next.trigger("mouseenter");
                        var currentOffset = self.$results.offset().top, nextTop = $next.offset().top, nextOffset = self.$results.scrollTop() + (nextTop - currentOffset);
                        0 === nextIndex ? self.$results.scrollTop(0) : nextTop - currentOffset < 0 && self.$results.scrollTop(nextOffset);
                    }
                }), container.on("results:next", function() {
                    var $highlighted = self.getHighlightedResults(), $options = self.$results.find("[aria-selected]"), currentIndex = $options.index($highlighted), nextIndex = currentIndex + 1;
                    if (!(nextIndex >= $options.length)) {
                        var $next = $options.eq(nextIndex);
                        $next.trigger("mouseenter");
                        var currentOffset = self.$results.offset().top + self.$results.outerHeight(!1), nextBottom = $next.offset().top + $next.outerHeight(!1), nextOffset = self.$results.scrollTop() + nextBottom - currentOffset;
                        0 === nextIndex ? self.$results.scrollTop(0) : nextBottom > currentOffset && self.$results.scrollTop(nextOffset);
                    }
                }), container.on("results:focus", function(params) {
                    params.element.addClass("select2-results__option--highlighted");
                }), container.on("results:message", function(params) {
                    self.displayMessage(params);
                }), $.fn.mousewheel && this.$results.on("mousewheel", function(e) {
                    var top = self.$results.scrollTop(), bottom = self.$results.get(0).scrollHeight - top + e.deltaY, isAtTop = e.deltaY > 0 && top - e.deltaY <= 0, isAtBottom = e.deltaY < 0 && bottom <= self.$results.height();
                    isAtTop ? (self.$results.scrollTop(0), e.preventDefault(), e.stopPropagation()) : isAtBottom && (self.$results.scrollTop(self.$results.get(0).scrollHeight - self.$results.height()), 
                    e.preventDefault(), e.stopPropagation());
                }), this.$results.on("mouseup", ".select2-results__option[aria-selected]", function(evt) {
                    var $this = $(this), data = $this.data("data");
                    return "true" === $this.attr("aria-selected") ? void (self.options.get("multiple") ? self.trigger("unselect", {
                        originalEvent: evt,
                        data: data
                    }) : self.trigger("close", {})) : void self.trigger("select", {
                        originalEvent: evt,
                        data: data
                    });
                }), this.$results.on("mouseenter", ".select2-results__option[aria-selected]", function(evt) {
                    var data = $(this).data("data");
                    self.getHighlightedResults().removeClass("select2-results__option--highlighted"), 
                    self.trigger("results:focus", {
                        data: data,
                        element: $(this)
                    });
                });
            }, Results.prototype.getHighlightedResults = function() {
                var $highlighted = this.$results.find(".select2-results__option--highlighted");
                return $highlighted;
            }, Results.prototype.destroy = function() {
                this.$results.remove();
            }, Results.prototype.ensureHighlightVisible = function() {
                var $highlighted = this.getHighlightedResults();
                if (0 !== $highlighted.length) {
                    var $options = this.$results.find("[aria-selected]"), currentIndex = $options.index($highlighted), currentOffset = this.$results.offset().top, nextTop = $highlighted.offset().top, nextOffset = this.$results.scrollTop() + (nextTop - currentOffset), offsetDelta = nextTop - currentOffset;
                    nextOffset -= 2 * $highlighted.outerHeight(!1), currentIndex <= 2 ? this.$results.scrollTop(0) : (offsetDelta > this.$results.outerHeight() || offsetDelta < 0) && this.$results.scrollTop(nextOffset);
                }
            }, Results.prototype.template = function(result, container) {
                var template = this.options.get("templateResult"), escapeMarkup = this.options.get("escapeMarkup"), content = template(result, container);
                null == content ? container.style.display = "none" : "string" == typeof content ? container.innerHTML = escapeMarkup(content) : $(container).append(content);
            }, Results;
        }), S2.define("select2/keys", [], function() {
            var KEYS = {
                BACKSPACE: 8,
                TAB: 9,
                ENTER: 13,
                SHIFT: 16,
                CTRL: 17,
                ALT: 18,
                ESC: 27,
                SPACE: 32,
                PAGE_UP: 33,
                PAGE_DOWN: 34,
                END: 35,
                HOME: 36,
                LEFT: 37,
                UP: 38,
                RIGHT: 39,
                DOWN: 40,
                DELETE: 46
            };
            return KEYS;
        }), S2.define("select2/selection/base", [ "jquery", "../utils", "../keys" ], function($, Utils, KEYS) {
            function BaseSelection($element, options) {
                this.$element = $element, this.options = options, BaseSelection.__super__.constructor.call(this);
            }
            return Utils.Extend(BaseSelection, Utils.Observable), BaseSelection.prototype.render = function() {
                var $selection = $('<span class="select2-selection" role="combobox"  aria-haspopup="true" aria-expanded="false"></span>');
                return this._tabindex = 0, null != this.$element.data("old-tabindex") ? this._tabindex = this.$element.data("old-tabindex") : null != this.$element.attr("tabindex") && (this._tabindex = this.$element.attr("tabindex")), 
                $selection.attr("title", this.$element.attr("title")), $selection.attr("tabindex", this._tabindex), 
                this.$selection = $selection, $selection;
            }, BaseSelection.prototype.bind = function(container, $container) {
                var self = this, resultsId = (container.id + "-container", container.id + "-results");
                this.container = container, this.$selection.on("focus", function(evt) {
                    self.trigger("focus", evt);
                }), this.$selection.on("blur", function(evt) {
                    self._handleBlur(evt);
                }), this.$selection.on("keydown", function(evt) {
                    self.trigger("keypress", evt), evt.which === KEYS.SPACE && evt.preventDefault();
                }), container.on("results:focus", function(params) {
                    self.$selection.attr("aria-activedescendant", params.data._resultId);
                }), container.on("selection:update", function(params) {
                    self.update(params.data);
                }), container.on("open", function() {
                    self.$selection.attr("aria-expanded", "true"), self.$selection.attr("aria-owns", resultsId), 
                    self._attachCloseHandler(container);
                }), container.on("close", function() {
                    self.$selection.attr("aria-expanded", "false"), self.$selection.removeAttr("aria-activedescendant"), 
                    self.$selection.removeAttr("aria-owns"), self.$selection.focus(), self._detachCloseHandler(container);
                }), container.on("enable", function() {
                    self.$selection.attr("tabindex", self._tabindex);
                }), container.on("disable", function() {
                    self.$selection.attr("tabindex", "-1");
                });
            }, BaseSelection.prototype._handleBlur = function(evt) {
                var self = this;
                window.setTimeout(function() {
                    document.activeElement == self.$selection[0] || $.contains(self.$selection[0], document.activeElement) || self.trigger("blur", evt);
                }, 1);
            }, BaseSelection.prototype._attachCloseHandler = function(container) {
                $(document.body).on("mousedown.select2." + container.id, function(e) {
                    var $target = $(e.target), $select = $target.closest(".select2"), $all = $(".select2.select2-container--open");
                    $all.each(function() {
                        var $this = $(this);
                        if (this != $select[0]) {
                            var $element = $this.data("element");
                            $element.select2("close");
                        }
                    });
                });
            }, BaseSelection.prototype._detachCloseHandler = function(container) {
                $(document.body).off("mousedown.select2." + container.id);
            }, BaseSelection.prototype.position = function($selection, $container) {
                var $selectionContainer = $container.find(".selection");
                $selectionContainer.append($selection);
            }, BaseSelection.prototype.destroy = function() {
                this._detachCloseHandler(this.container);
            }, BaseSelection.prototype.update = function(data) {
                throw new Error("The `update` method must be defined in child classes.");
            }, BaseSelection;
        }), S2.define("select2/selection/single", [ "jquery", "./base", "../utils", "../keys" ], function($, BaseSelection, Utils, KEYS) {
            function SingleSelection() {
                SingleSelection.__super__.constructor.apply(this, arguments);
            }
            return Utils.Extend(SingleSelection, BaseSelection), SingleSelection.prototype.render = function() {
                var $selection = SingleSelection.__super__.render.call(this);
                return $selection.addClass("select2-selection--single"), $selection.html('<span class="select2-selection__rendered"></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span>'), 
                $selection;
            }, SingleSelection.prototype.bind = function(container, $container) {
                var self = this;
                SingleSelection.__super__.bind.apply(this, arguments);
                var id = container.id + "-container";
                this.$selection.find(".select2-selection__rendered").attr("id", id), this.$selection.attr("aria-labelledby", id), 
                this.$selection.on("mousedown", function(evt) {
                    1 === evt.which && self.trigger("toggle", {
                        originalEvent: evt
                    });
                }), this.$selection.on("focus", function(evt) {}), this.$selection.on("blur", function(evt) {}), 
                container.on("focus", function(evt) {
                    container.isOpen() || self.$selection.focus();
                }), container.on("selection:update", function(params) {
                    self.update(params.data);
                });
            }, SingleSelection.prototype.clear = function() {
                this.$selection.find(".select2-selection__rendered").empty();
            }, SingleSelection.prototype.display = function(data, container) {
                var template = this.options.get("templateSelection"), escapeMarkup = this.options.get("escapeMarkup");
                return escapeMarkup(template(data, container));
            }, SingleSelection.prototype.selectionContainer = function() {
                return $("<span></span>");
            }, SingleSelection.prototype.update = function(data) {
                if (0 === data.length) return void this.clear();
                var selection = data[0], $rendered = this.$selection.find(".select2-selection__rendered"), formatted = this.display(selection, $rendered);
                $rendered.empty().append(formatted), $rendered.prop("title", selection.title || selection.text);
            }, SingleSelection;
        }), S2.define("select2/selection/multiple", [ "jquery", "./base", "../utils" ], function($, BaseSelection, Utils) {
            function MultipleSelection($element, options) {
                MultipleSelection.__super__.constructor.apply(this, arguments);
            }
            return Utils.Extend(MultipleSelection, BaseSelection), MultipleSelection.prototype.render = function() {
                var $selection = MultipleSelection.__super__.render.call(this);
                return $selection.addClass("select2-selection--multiple"), $selection.html('<ul class="select2-selection__rendered"></ul>'), 
                $selection;
            }, MultipleSelection.prototype.bind = function(container, $container) {
                var self = this;
                MultipleSelection.__super__.bind.apply(this, arguments), this.$selection.on("click", function(evt) {
                    self.trigger("toggle", {
                        originalEvent: evt
                    });
                }), this.$selection.on("click", ".select2-selection__choice__remove", function(evt) {
                    if (!self.options.get("disabled")) {
                        var $remove = $(this), $selection = $remove.parent(), data = $selection.data("data");
                        self.trigger("unselect", {
                            originalEvent: evt,
                            data: data
                        });
                    }
                });
            }, MultipleSelection.prototype.clear = function() {
                this.$selection.find(".select2-selection__rendered").empty();
            }, MultipleSelection.prototype.display = function(data, container) {
                var template = this.options.get("templateSelection"), escapeMarkup = this.options.get("escapeMarkup");
                return escapeMarkup(template(data, container));
            }, MultipleSelection.prototype.selectionContainer = function() {
                var $container = $('<li class="select2-selection__choice"><span class="select2-selection__choice__remove" role="presentation">&times;</span></li>');
                return $container;
            }, MultipleSelection.prototype.update = function(data) {
                if (this.clear(), 0 !== data.length) {
                    for (var $selections = [], d = 0; d < data.length; d++) {
                        var selection = data[d], $selection = this.selectionContainer(), formatted = this.display(selection, $selection);
                        $selection.append(formatted), $selection.prop("title", selection.title || selection.text), 
                        $selection.data("data", selection), $selections.push($selection);
                    }
                    var $rendered = this.$selection.find(".select2-selection__rendered");
                    Utils.appendMany($rendered, $selections);
                }
            }, MultipleSelection;
        }), S2.define("select2/selection/placeholder", [ "../utils" ], function(Utils) {
            function Placeholder(decorated, $element, options) {
                this.placeholder = this.normalizePlaceholder(options.get("placeholder")), decorated.call(this, $element, options);
            }
            return Placeholder.prototype.normalizePlaceholder = function(_, placeholder) {
                return "string" == typeof placeholder && (placeholder = {
                    id: "",
                    text: placeholder
                }), placeholder;
            }, Placeholder.prototype.createPlaceholder = function(decorated, placeholder) {
                var $placeholder = this.selectionContainer();
                return $placeholder.html(this.display(placeholder)), $placeholder.addClass("select2-selection__placeholder").removeClass("select2-selection__choice"), 
                $placeholder;
            }, Placeholder.prototype.update = function(decorated, data) {
                var singlePlaceholder = 1 == data.length && data[0].id != this.placeholder.id, multipleSelections = data.length > 1;
                if (multipleSelections || singlePlaceholder) return decorated.call(this, data);
                this.clear();
                var $placeholder = this.createPlaceholder(this.placeholder);
                this.$selection.find(".select2-selection__rendered").append($placeholder);
            }, Placeholder;
        }), S2.define("select2/selection/allowClear", [ "jquery", "../keys" ], function($, KEYS) {
            function AllowClear() {}
            return AllowClear.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container), null == this.placeholder && this.options.get("debug") && window.console && console.error && console.error("Select2: The `allowClear` option should be used in combination with the `placeholder` option."), 
                this.$selection.on("mousedown", ".select2-selection__clear", function(evt) {
                    self._handleClear(evt);
                }), container.on("keypress", function(evt) {
                    self._handleKeyboardClear(evt, container);
                });
            }, AllowClear.prototype._handleClear = function(_, evt) {
                if (!this.options.get("disabled")) {
                    var $clear = this.$selection.find(".select2-selection__clear");
                    if (0 !== $clear.length) {
                        evt.stopPropagation();
                        for (var data = $clear.data("data"), d = 0; d < data.length; d++) {
                            var unselectData = {
                                data: data[d]
                            };
                            if (this.trigger("unselect", unselectData), unselectData.prevented) return;
                        }
                        this.$element.val(this.placeholder.id).trigger("change"), this.trigger("toggle", {});
                    }
                }
            }, AllowClear.prototype._handleKeyboardClear = function(_, evt, container) {
                container.isOpen() || evt.which != KEYS.DELETE && evt.which != KEYS.BACKSPACE || this._handleClear(evt);
            }, AllowClear.prototype.update = function(decorated, data) {
                if (decorated.call(this, data), !(this.$selection.find(".select2-selection__placeholder").length > 0 || 0 === data.length)) {
                    var $remove = $('<span class="select2-selection__clear">&times;</span>');
                    $remove.data("data", data), this.$selection.find(".select2-selection__rendered").prepend($remove);
                }
            }, AllowClear;
        }), S2.define("select2/selection/search", [ "jquery", "../utils", "../keys" ], function($, Utils, KEYS) {
            function Search(decorated, $element, options) {
                decorated.call(this, $element, options);
            }
            return Search.prototype.render = function(decorated) {
                var $search = $('<li class="select2-search select2-search--inline"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" aria-autocomplete="list" /></li>');
                this.$searchContainer = $search, this.$search = $search.find("input");
                var $rendered = decorated.call(this);
                return this._transferTabIndex(), $rendered;
            }, Search.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container), container.on("open", function() {
                    self.$search.trigger("focus");
                }), container.on("close", function() {
                    self.$search.val(""), self.$search.removeAttr("aria-activedescendant"), self.$search.trigger("focus");
                }), container.on("enable", function() {
                    self.$search.prop("disabled", !1), self._transferTabIndex();
                }), container.on("disable", function() {
                    self.$search.prop("disabled", !0);
                }), container.on("focus", function(evt) {
                    self.$search.trigger("focus");
                }), container.on("results:focus", function(params) {
                    self.$search.attr("aria-activedescendant", params.id);
                }), this.$selection.on("focusin", ".select2-search--inline", function(evt) {
                    self.trigger("focus", evt);
                }), this.$selection.on("focusout", ".select2-search--inline", function(evt) {
                    self._handleBlur(evt);
                }), this.$selection.on("keydown", ".select2-search--inline", function(evt) {
                    evt.stopPropagation(), self.trigger("keypress", evt), self._keyUpPrevented = evt.isDefaultPrevented();
                    var key = evt.which;
                    if (key === KEYS.BACKSPACE && "" === self.$search.val()) {
                        var $previousChoice = self.$searchContainer.prev(".select2-selection__choice");
                        if ($previousChoice.length > 0) {
                            var item = $previousChoice.data("data");
                            self.searchRemoveChoice(item), evt.preventDefault();
                        }
                    }
                });
                var msie = document.documentMode, disableInputEvents = msie && msie <= 11;
                this.$selection.on("input.searchcheck", ".select2-search--inline", function(evt) {
                    return disableInputEvents ? void self.$selection.off("input.search input.searchcheck") : void self.$selection.off("keyup.search");
                }), this.$selection.on("keyup.search input.search", ".select2-search--inline", function(evt) {
                    if (disableInputEvents && "input" === evt.type) return void self.$selection.off("input.search input.searchcheck");
                    var key = evt.which;
                    key != KEYS.SHIFT && key != KEYS.CTRL && key != KEYS.ALT && key != KEYS.TAB && self.handleSearch(evt);
                });
            }, Search.prototype._transferTabIndex = function(decorated) {
                this.$search.attr("tabindex", this.$selection.attr("tabindex")), this.$selection.attr("tabindex", "-1");
            }, Search.prototype.createPlaceholder = function(decorated, placeholder) {
                this.$search.attr("placeholder", placeholder.text);
            }, Search.prototype.update = function(decorated, data) {
                var searchHadFocus = this.$search[0] == document.activeElement;
                this.$search.attr("placeholder", ""), decorated.call(this, data), this.$selection.find(".select2-selection__rendered").append(this.$searchContainer), 
                this.resizeSearch(), searchHadFocus && this.$search.focus();
            }, Search.prototype.handleSearch = function() {
                if (this.resizeSearch(), !this._keyUpPrevented) {
                    var input = this.$search.val();
                    this.trigger("query", {
                        term: input
                    });
                }
                this._keyUpPrevented = !1;
            }, Search.prototype.searchRemoveChoice = function(decorated, item) {
                this.trigger("unselect", {
                    data: item
                }), this.$search.val(item.text), this.handleSearch();
            }, Search.prototype.resizeSearch = function() {
                this.$search.css("width", "25px");
                var width = "";
                if ("" !== this.$search.attr("placeholder")) width = this.$selection.find(".select2-selection__rendered").innerWidth(); else {
                    var minimumWidth = this.$search.val().length + 1;
                    width = .75 * minimumWidth + "em";
                }
                this.$search.css("width", width);
            }, Search;
        }), S2.define("select2/selection/eventRelay", [ "jquery" ], function($) {
            function EventRelay() {}
            return EventRelay.prototype.bind = function(decorated, container, $container) {
                var self = this, relayEvents = [ "open", "opening", "close", "closing", "select", "selecting", "unselect", "unselecting" ], preventableEvents = [ "opening", "closing", "selecting", "unselecting" ];
                decorated.call(this, container, $container), container.on("*", function(name, params) {
                    if ($.inArray(name, relayEvents) !== -1) {
                        params = params || {};
                        var evt = $.Event("select2:" + name, {
                            params: params
                        });
                        self.$element.trigger(evt), $.inArray(name, preventableEvents) !== -1 && (params.prevented = evt.isDefaultPrevented());
                    }
                });
            }, EventRelay;
        }), S2.define("select2/translation", [ "jquery", "require" ], function($, require) {
            function Translation(dict) {
                this.dict = dict || {};
            }
            return Translation.prototype.all = function() {
                return this.dict;
            }, Translation.prototype.get = function(key) {
                return this.dict[key];
            }, Translation.prototype.extend = function(translation) {
                this.dict = $.extend({}, translation.all(), this.dict);
            }, Translation._cache = {}, Translation.loadPath = function(path) {
                if (!(path in Translation._cache)) {
                    var translations = require(path);
                    Translation._cache[path] = translations;
                }
                return new Translation(Translation._cache[path]);
            }, Translation;
        }), S2.define("select2/diacritics", [], function() {
            var diacritics = {
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "AA",
                "": "AE",
                "": "AE",
                "": "AE",
                "": "AO",
                "": "AU",
                "": "AV",
                "": "AV",
                "": "AY",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "B",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "D",
                "": "DZ",
                "": "DZ",
                "": "Dz",
                "": "Dz",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "F",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "H",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "J",
                "": "J",
                "": "J",
                "": "J",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "K",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "LJ",
                "": "Lj",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "M",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "NJ",
                "": "Nj",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "OI",
                "": "OO",
                "": "OU",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "P",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "Q",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "R",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "T",
                "": "TZ",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "V",
                "": "VY",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "W",
                "": "X",
                "": "X",
                "": "X",
                "": "X",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Y",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "aa",
                "": "ae",
                "": "ae",
                "": "ae",
                "": "ao",
                "": "au",
                "": "av",
                "": "av",
                "": "ay",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "b",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "d",
                "": "dz",
                "": "dz",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "f",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "h",
                "": "hv",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "j",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "k",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "lj",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "m",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "nj",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "oi",
                "": "ou",
                "": "oo",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "p",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "q",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "r",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "t",
                "": "tz",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "v",
                "": "vy",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "w",
                "": "x",
                "": "x",
                "": "x",
                "": "x",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "y",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "z",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": "",
                "": ""
            };
            return diacritics;
        }), S2.define("select2/data/base", [ "../utils" ], function(Utils) {
            function BaseAdapter($element, options) {
                BaseAdapter.__super__.constructor.call(this);
            }
            return Utils.Extend(BaseAdapter, Utils.Observable), BaseAdapter.prototype.current = function(callback) {
                throw new Error("The `current` method must be defined in child classes.");
            }, BaseAdapter.prototype.query = function(params, callback) {
                throw new Error("The `query` method must be defined in child classes.");
            }, BaseAdapter.prototype.bind = function(container, $container) {}, BaseAdapter.prototype.destroy = function() {}, 
            BaseAdapter.prototype.generateResultId = function(container, data) {
                var id = container.id + "-result-";
                return id += Utils.generateChars(4), id += null != data.id ? "-" + data.id.toString() : "-" + Utils.generateChars(4);
            }, BaseAdapter;
        }), S2.define("select2/data/select", [ "./base", "../utils", "jquery" ], function(BaseAdapter, Utils, $) {
            function SelectAdapter($element, options) {
                this.$element = $element, this.options = options, SelectAdapter.__super__.constructor.call(this);
            }
            return Utils.Extend(SelectAdapter, BaseAdapter), SelectAdapter.prototype.current = function(callback) {
                var data = [], self = this;
                this.$element.find(":selected").each(function() {
                    var $option = $(this), option = self.item($option);
                    data.push(option);
                }), callback(data);
            }, SelectAdapter.prototype.select = function(data) {
                var self = this;
                if (data.selected = !0, $(data.element).is("option")) return data.element.selected = !0, 
                void this.$element.trigger("change");
                if (this.$element.prop("multiple")) this.current(function(currentData) {
                    var val = [];
                    data = [ data ], data.push.apply(data, currentData);
                    for (var d = 0; d < data.length; d++) {
                        var id = data[d].id;
                        $.inArray(id, val) === -1 && val.push(id);
                    }
                    self.$element.val(val), self.$element.trigger("change");
                }); else {
                    var val = data.id;
                    this.$element.val(val), this.$element.trigger("change");
                }
            }, SelectAdapter.prototype.unselect = function(data) {
                var self = this;
                if (this.$element.prop("multiple")) return data.selected = !1, $(data.element).is("option") ? (data.element.selected = !1, 
                void this.$element.trigger("change")) : void this.current(function(currentData) {
                    for (var val = [], d = 0; d < currentData.length; d++) {
                        var id = currentData[d].id;
                        id !== data.id && $.inArray(id, val) === -1 && val.push(id);
                    }
                    self.$element.val(val), self.$element.trigger("change");
                });
            }, SelectAdapter.prototype.bind = function(container, $container) {
                var self = this;
                this.container = container, container.on("select", function(params) {
                    self.select(params.data);
                }), container.on("unselect", function(params) {
                    self.unselect(params.data);
                });
            }, SelectAdapter.prototype.destroy = function() {
                this.$element.find("*").each(function() {
                    $.removeData(this, "data");
                });
            }, SelectAdapter.prototype.query = function(params, callback) {
                var data = [], self = this, $options = this.$element.children();
                $options.each(function() {
                    var $option = $(this);
                    if ($option.is("option") || $option.is("optgroup")) {
                        var option = self.item($option), matches = self.matches(params, option);
                        null !== matches && data.push(matches);
                    }
                }), callback({
                    results: data
                });
            }, SelectAdapter.prototype.addOptions = function($options) {
                Utils.appendMany(this.$element, $options);
            }, SelectAdapter.prototype.option = function(data) {
                var option;
                data.children ? (option = document.createElement("optgroup"), option.label = data.text) : (option = document.createElement("option"), 
                void 0 !== option.textContent ? option.textContent = data.text : option.innerText = data.text), 
                data.id && (option.value = data.id), data.disabled && (option.disabled = !0), data.selected && (option.selected = !0), 
                data.title && (option.title = data.title);
                var $option = $(option), normalizedData = this._normalizeItem(data);
                return normalizedData.element = option, $.data(option, "data", normalizedData), 
                $option;
            }, SelectAdapter.prototype.item = function($option) {
                var data = {};
                if (data = $.data($option[0], "data"), null != data) return data;
                if ($option.is("option")) data = {
                    id: $option.val(),
                    text: $option.text(),
                    disabled: $option.prop("disabled"),
                    selected: $option.prop("selected"),
                    title: $option.prop("title")
                }; else if ($option.is("optgroup")) {
                    data = {
                        text: $option.prop("label"),
                        children: [],
                        title: $option.prop("title")
                    };
                    for (var $children = $option.children("option"), children = [], c = 0; c < $children.length; c++) {
                        var $child = $($children[c]), child = this.item($child);
                        children.push(child);
                    }
                    data.children = children;
                }
                return data = this._normalizeItem(data), data.element = $option[0], $.data($option[0], "data", data), 
                data;
            }, SelectAdapter.prototype._normalizeItem = function(item) {
                $.isPlainObject(item) || (item = {
                    id: item,
                    text: item
                }), item = $.extend({}, {
                    text: ""
                }, item);
                var defaults = {
                    selected: !1,
                    disabled: !1
                };
                return null != item.id && (item.id = item.id.toString()), null != item.text && (item.text = item.text.toString()), 
                null == item._resultId && item.id && null != this.container && (item._resultId = this.generateResultId(this.container, item)), 
                $.extend({}, defaults, item);
            }, SelectAdapter.prototype.matches = function(params, data) {
                var matcher = this.options.get("matcher");
                return matcher(params, data);
            }, SelectAdapter;
        }), S2.define("select2/data/array", [ "./select", "../utils", "jquery" ], function(SelectAdapter, Utils, $) {
            function ArrayAdapter($element, options) {
                var data = options.get("data") || [];
                ArrayAdapter.__super__.constructor.call(this, $element, options), this.addOptions(this.convertToOptions(data));
            }
            return Utils.Extend(ArrayAdapter, SelectAdapter), ArrayAdapter.prototype.select = function(data) {
                var $option = this.$element.find("option").filter(function(i, elm) {
                    return elm.value == data.id.toString();
                });
                0 === $option.length && ($option = this.option(data), this.addOptions($option)), 
                ArrayAdapter.__super__.select.call(this, data);
            }, ArrayAdapter.prototype.convertToOptions = function(data) {
                function onlyItem(item) {
                    return function() {
                        return $(this).val() == item.id;
                    };
                }
                for (var self = this, $existing = this.$element.find("option"), existingIds = $existing.map(function() {
                    return self.item($(this)).id;
                }).get(), $options = [], d = 0; d < data.length; d++) {
                    var item = this._normalizeItem(data[d]);
                    if ($.inArray(item.id, existingIds) >= 0) {
                        var $existingOption = $existing.filter(onlyItem(item)), existingData = this.item($existingOption), newData = $.extend(!0, {}, item, existingData), $newOption = this.option(newData);
                        $existingOption.replaceWith($newOption);
                    } else {
                        var $option = this.option(item);
                        if (item.children) {
                            var $children = this.convertToOptions(item.children);
                            Utils.appendMany($option, $children);
                        }
                        $options.push($option);
                    }
                }
                return $options;
            }, ArrayAdapter;
        }), S2.define("select2/data/ajax", [ "./array", "../utils", "jquery" ], function(ArrayAdapter, Utils, $) {
            function AjaxAdapter($element, options) {
                this.ajaxOptions = this._applyDefaults(options.get("ajax")), null != this.ajaxOptions.processResults && (this.processResults = this.ajaxOptions.processResults), 
                AjaxAdapter.__super__.constructor.call(this, $element, options);
            }
            return Utils.Extend(AjaxAdapter, ArrayAdapter), AjaxAdapter.prototype._applyDefaults = function(options) {
                var defaults = {
                    data: function(params) {
                        return $.extend({}, params, {
                            q: params.term
                        });
                    },
                    transport: function(params, success, failure) {
                        var $request = $.ajax(params);
                        return $request.then(success), $request.fail(failure), $request;
                    }
                };
                return $.extend({}, defaults, options, !0);
            }, AjaxAdapter.prototype.processResults = function(results) {
                return results;
            }, AjaxAdapter.prototype.query = function(params, callback) {
                function request() {
                    var $request = options.transport(options, function(data) {
                        var results = self.processResults(data, params);
                        self.options.get("debug") && window.console && console.error && (results && results.results && $.isArray(results.results) || console.error("Select2: The AJAX results did not return an array in the `results` key of the response.")), 
                        callback(results);
                    }, function() {
                        $request.status && "0" === $request.status || self.trigger("results:message", {
                            message: "errorLoading"
                        });
                    });
                    self._request = $request;
                }
                var self = this;
                null != this._request && ($.isFunction(this._request.abort) && this._request.abort(), 
                this._request = null);
                var options = $.extend({
                    type: "GET"
                }, this.ajaxOptions);
                "function" == typeof options.url && (options.url = options.url.call(this.$element, params)), 
                "function" == typeof options.data && (options.data = options.data.call(this.$element, params)), 
                this.ajaxOptions.delay && null != params.term ? (this._queryTimeout && window.clearTimeout(this._queryTimeout), 
                this._queryTimeout = window.setTimeout(request, this.ajaxOptions.delay)) : request();
            }, AjaxAdapter;
        }), S2.define("select2/data/tags", [ "jquery" ], function($) {
            function Tags(decorated, $element, options) {
                var tags = options.get("tags"), createTag = options.get("createTag");
                void 0 !== createTag && (this.createTag = createTag);
                var insertTag = options.get("insertTag");
                if (void 0 !== insertTag && (this.insertTag = insertTag), decorated.call(this, $element, options), 
                $.isArray(tags)) for (var t = 0; t < tags.length; t++) {
                    var tag = tags[t], item = this._normalizeItem(tag), $option = this.option(item);
                    this.$element.append($option);
                }
            }
            return Tags.prototype.query = function(decorated, params, callback) {
                function wrapper(obj, child) {
                    for (var data = obj.results, i = 0; i < data.length; i++) {
                        var option = data[i], checkChildren = null != option.children && !wrapper({
                            results: option.children
                        }, !0), checkText = option.text === params.term;
                        if (checkText || checkChildren) return !child && (obj.data = data, void callback(obj));
                    }
                    if (child) return !0;
                    var tag = self.createTag(params);
                    if (null != tag) {
                        var $option = self.option(tag);
                        $option.attr("data-select2-tag", !0), self.addOptions([ $option ]), self.insertTag(data, tag);
                    }
                    obj.results = data, callback(obj);
                }
                var self = this;
                return this._removeOldTags(), null == params.term || null != params.page ? void decorated.call(this, params, callback) : void decorated.call(this, params, wrapper);
            }, Tags.prototype.createTag = function(decorated, params) {
                var term = $.trim(params.term);
                return "" === term ? null : {
                    id: term,
                    text: term
                };
            }, Tags.prototype.insertTag = function(_, data, tag) {
                data.unshift(tag);
            }, Tags.prototype._removeOldTags = function(_) {
                var $options = (this._lastTag, this.$element.find("option[data-select2-tag]"));
                $options.each(function() {
                    this.selected || $(this).remove();
                });
            }, Tags;
        }), S2.define("select2/data/tokenizer", [ "jquery" ], function($) {
            function Tokenizer(decorated, $element, options) {
                var tokenizer = options.get("tokenizer");
                void 0 !== tokenizer && (this.tokenizer = tokenizer), decorated.call(this, $element, options);
            }
            return Tokenizer.prototype.bind = function(decorated, container, $container) {
                decorated.call(this, container, $container), this.$search = container.dropdown.$search || container.selection.$search || $container.find(".select2-search__field");
            }, Tokenizer.prototype.query = function(decorated, params, callback) {
                function createAndSelect(data) {
                    var item = self._normalizeItem(data), $existingOptions = self.$element.find("option").filter(function() {
                        return $(this).val() === item.id;
                    });
                    if (!$existingOptions.length) {
                        var $option = self.option(item);
                        $option.attr("data-select2-tag", !0), self._removeOldTags(), self.addOptions([ $option ]);
                    }
                    select(item);
                }
                function select(data) {
                    self.trigger("select", {
                        data: data
                    });
                }
                var self = this;
                params.term = params.term || "";
                var tokenData = this.tokenizer(params, this.options, createAndSelect);
                tokenData.term !== params.term && (this.$search.length && (this.$search.val(tokenData.term), 
                this.$search.focus()), params.term = tokenData.term), decorated.call(this, params, callback);
            }, Tokenizer.prototype.tokenizer = function(_, params, options, callback) {
                for (var separators = options.get("tokenSeparators") || [], term = params.term, i = 0, createTag = this.createTag || function(params) {
                    return {
                        id: params.term,
                        text: params.term
                    };
                }; i < term.length; ) {
                    var termChar = term[i];
                    if ($.inArray(termChar, separators) !== -1) {
                        var part = term.substr(0, i), partParams = $.extend({}, params, {
                            term: part
                        }), data = createTag(partParams);
                        null != data ? (callback(data), term = term.substr(i + 1) || "", i = 0) : i++;
                    } else i++;
                }
                return {
                    term: term
                };
            }, Tokenizer;
        }), S2.define("select2/data/minimumInputLength", [], function() {
            function MinimumInputLength(decorated, $e, options) {
                this.minimumInputLength = options.get("minimumInputLength"), decorated.call(this, $e, options);
            }
            return MinimumInputLength.prototype.query = function(decorated, params, callback) {
                return params.term = params.term || "", params.term.length < this.minimumInputLength ? void this.trigger("results:message", {
                    message: "inputTooShort",
                    args: {
                        minimum: this.minimumInputLength,
                        input: params.term,
                        params: params
                    }
                }) : void decorated.call(this, params, callback);
            }, MinimumInputLength;
        }), S2.define("select2/data/maximumInputLength", [], function() {
            function MaximumInputLength(decorated, $e, options) {
                this.maximumInputLength = options.get("maximumInputLength"), decorated.call(this, $e, options);
            }
            return MaximumInputLength.prototype.query = function(decorated, params, callback) {
                return params.term = params.term || "", this.maximumInputLength > 0 && params.term.length > this.maximumInputLength ? void this.trigger("results:message", {
                    message: "inputTooLong",
                    args: {
                        maximum: this.maximumInputLength,
                        input: params.term,
                        params: params
                    }
                }) : void decorated.call(this, params, callback);
            }, MaximumInputLength;
        }), S2.define("select2/data/maximumSelectionLength", [], function() {
            function MaximumSelectionLength(decorated, $e, options) {
                this.maximumSelectionLength = options.get("maximumSelectionLength"), decorated.call(this, $e, options);
            }
            return MaximumSelectionLength.prototype.query = function(decorated, params, callback) {
                var self = this;
                this.current(function(currentData) {
                    var count = null != currentData ? currentData.length : 0;
                    return self.maximumSelectionLength > 0 && count >= self.maximumSelectionLength ? void self.trigger("results:message", {
                        message: "maximumSelected",
                        args: {
                            maximum: self.maximumSelectionLength
                        }
                    }) : void decorated.call(self, params, callback);
                });
            }, MaximumSelectionLength;
        }), S2.define("select2/dropdown", [ "jquery", "./utils" ], function($, Utils) {
            function Dropdown($element, options) {
                this.$element = $element, this.options = options, Dropdown.__super__.constructor.call(this);
            }
            return Utils.Extend(Dropdown, Utils.Observable), Dropdown.prototype.render = function() {
                var $dropdown = $('<span class="select2-dropdown"><span class="select2-results"></span></span>');
                return $dropdown.attr("dir", this.options.get("dir")), this.$dropdown = $dropdown, 
                $dropdown;
            }, Dropdown.prototype.bind = function() {}, Dropdown.prototype.position = function($dropdown, $container) {}, 
            Dropdown.prototype.destroy = function() {
                this.$dropdown.remove();
            }, Dropdown;
        }), S2.define("select2/dropdown/search", [ "jquery", "../utils" ], function($, Utils) {
            function Search() {}
            return Search.prototype.render = function(decorated) {
                var $rendered = decorated.call(this), $search = $('<span class="select2-search select2-search--dropdown"><input class="select2-search__field" type="search" tabindex="-1" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="textbox" /></span>');
                return this.$searchContainer = $search, this.$search = $search.find("input"), $rendered.prepend($search), 
                $rendered;
            }, Search.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container), this.$search.on("keydown", function(evt) {
                    self.trigger("keypress", evt), self._keyUpPrevented = evt.isDefaultPrevented();
                }), this.$search.on("input", function(evt) {
                    $(this).off("keyup");
                }), this.$search.on("keyup input", function(evt) {
                    self.handleSearch(evt);
                }), container.on("open", function() {
                    self.$search.attr("tabindex", 0), self.$search.focus(), window.setTimeout(function() {
                        self.$search.focus();
                    }, 0);
                }), container.on("close", function() {
                    self.$search.attr("tabindex", -1), self.$search.val("");
                }), container.on("focus", function() {
                    container.isOpen() && self.$search.focus();
                }), container.on("results:all", function(params) {
                    if (null == params.query.term || "" === params.query.term) {
                        var showSearch = self.showSearch(params);
                        showSearch ? self.$searchContainer.removeClass("select2-search--hide") : self.$searchContainer.addClass("select2-search--hide");
                    }
                });
            }, Search.prototype.handleSearch = function(evt) {
                if (!this._keyUpPrevented) {
                    var input = this.$search.val();
                    this.trigger("query", {
                        term: input
                    });
                }
                this._keyUpPrevented = !1;
            }, Search.prototype.showSearch = function(_, params) {
                return !0;
            }, Search;
        }), S2.define("select2/dropdown/hidePlaceholder", [], function() {
            function HidePlaceholder(decorated, $element, options, dataAdapter) {
                this.placeholder = this.normalizePlaceholder(options.get("placeholder")), decorated.call(this, $element, options, dataAdapter);
            }
            return HidePlaceholder.prototype.append = function(decorated, data) {
                data.results = this.removePlaceholder(data.results), decorated.call(this, data);
            }, HidePlaceholder.prototype.normalizePlaceholder = function(_, placeholder) {
                return "string" == typeof placeholder && (placeholder = {
                    id: "",
                    text: placeholder
                }), placeholder;
            }, HidePlaceholder.prototype.removePlaceholder = function(_, data) {
                for (var modifiedData = data.slice(0), d = data.length - 1; d >= 0; d--) {
                    var item = data[d];
                    this.placeholder.id === item.id && modifiedData.splice(d, 1);
                }
                return modifiedData;
            }, HidePlaceholder;
        }), S2.define("select2/dropdown/infiniteScroll", [ "jquery" ], function($) {
            function InfiniteScroll(decorated, $element, options, dataAdapter) {
                this.lastParams = {}, decorated.call(this, $element, options, dataAdapter), this.$loadingMore = this.createLoadingMore(), 
                this.loading = !1;
            }
            return InfiniteScroll.prototype.append = function(decorated, data) {
                this.$loadingMore.remove(), this.loading = !1, decorated.call(this, data), this.showLoadingMore(data) && this.$results.append(this.$loadingMore);
            }, InfiniteScroll.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container), container.on("query", function(params) {
                    self.lastParams = params, self.loading = !0;
                }), container.on("query:append", function(params) {
                    self.lastParams = params, self.loading = !0;
                }), this.$results.on("scroll", function() {
                    var isLoadMoreVisible = $.contains(document.documentElement, self.$loadingMore[0]);
                    if (!self.loading && isLoadMoreVisible) {
                        var currentOffset = self.$results.offset().top + self.$results.outerHeight(!1), loadingMoreOffset = self.$loadingMore.offset().top + self.$loadingMore.outerHeight(!1);
                        currentOffset + 50 >= loadingMoreOffset && self.loadMore();
                    }
                });
            }, InfiniteScroll.prototype.loadMore = function() {
                this.loading = !0;
                var params = $.extend({}, {
                    page: 1
                }, this.lastParams);
                params.page++, this.trigger("query:append", params);
            }, InfiniteScroll.prototype.showLoadingMore = function(_, data) {
                return data.pagination && data.pagination.more;
            }, InfiniteScroll.prototype.createLoadingMore = function() {
                var $option = $('<li class="select2-results__option select2-results__option--load-more"role="treeitem" aria-disabled="true"></li>'), message = this.options.get("translations").get("loadingMore");
                return $option.html(message(this.lastParams)), $option;
            }, InfiniteScroll;
        }), S2.define("select2/dropdown/attachBody", [ "jquery", "../utils" ], function($, Utils) {
            function AttachBody(decorated, $element, options) {
                this.$dropdownParent = options.get("dropdownParent") || $(document.body), decorated.call(this, $element, options);
            }
            return AttachBody.prototype.bind = function(decorated, container, $container) {
                var self = this, setupResultsEvents = !1;
                decorated.call(this, container, $container), container.on("open", function() {
                    self._showDropdown(), self._attachPositioningHandler(container), setupResultsEvents || (setupResultsEvents = !0, 
                    container.on("results:all", function() {
                        self._positionDropdown(), self._resizeDropdown();
                    }), container.on("results:append", function() {
                        self._positionDropdown(), self._resizeDropdown();
                    }));
                }), container.on("close", function() {
                    self._hideDropdown(), self._detachPositioningHandler(container);
                }), this.$dropdownContainer.on("mousedown", function(evt) {
                    evt.stopPropagation();
                });
            }, AttachBody.prototype.destroy = function(decorated) {
                decorated.call(this), this.$dropdownContainer.remove();
            }, AttachBody.prototype.position = function(decorated, $dropdown, $container) {
                $dropdown.attr("class", $container.attr("class")), $dropdown.removeClass("select2"), 
                $dropdown.addClass("select2-container--open"), $dropdown.css({
                    position: "absolute",
                    top: -999999
                }), this.$container = $container;
            }, AttachBody.prototype.render = function(decorated) {
                var $container = $("<span></span>"), $dropdown = decorated.call(this);
                return $container.append($dropdown), this.$dropdownContainer = $container, $container;
            }, AttachBody.prototype._hideDropdown = function(decorated) {
                this.$dropdownContainer.detach();
            }, AttachBody.prototype._attachPositioningHandler = function(decorated, container) {
                var self = this, scrollEvent = "scroll.select2." + container.id, resizeEvent = "resize.select2." + container.id, orientationEvent = "orientationchange.select2." + container.id, $watchers = this.$container.parents().filter(Utils.hasScroll);
                $watchers.each(function() {
                    $(this).data("select2-scroll-position", {
                        x: $(this).scrollLeft(),
                        y: $(this).scrollTop()
                    });
                }), $watchers.on(scrollEvent, function(ev) {
                    var position = $(this).data("select2-scroll-position");
                    $(this).scrollTop(position.y);
                }), $(window).on(scrollEvent + " " + resizeEvent + " " + orientationEvent, function(e) {
                    self._positionDropdown(), self._resizeDropdown();
                });
            }, AttachBody.prototype._detachPositioningHandler = function(decorated, container) {
                var scrollEvent = "scroll.select2." + container.id, resizeEvent = "resize.select2." + container.id, orientationEvent = "orientationchange.select2." + container.id, $watchers = this.$container.parents().filter(Utils.hasScroll);
                $watchers.off(scrollEvent), $(window).off(scrollEvent + " " + resizeEvent + " " + orientationEvent);
            }, AttachBody.prototype._positionDropdown = function() {
                var $window = $(window), isCurrentlyAbove = this.$dropdown.hasClass("select2-dropdown--above"), isCurrentlyBelow = this.$dropdown.hasClass("select2-dropdown--below"), newDirection = null, offset = this.$container.offset();
                offset.bottom = offset.top + this.$container.outerHeight(!1);
                var container = {
                    height: this.$container.outerHeight(!1)
                };
                container.top = offset.top, container.bottom = offset.top + container.height;
                var dropdown = {
                    height: this.$dropdown.outerHeight(!1)
                }, viewport = {
                    top: $window.scrollTop(),
                    bottom: $window.scrollTop() + $window.height()
                }, enoughRoomAbove = viewport.top < offset.top - dropdown.height, enoughRoomBelow = viewport.bottom > offset.bottom + dropdown.height, css = {
                    left: offset.left,
                    top: container.bottom
                }, $offsetParent = this.$dropdownParent;
                "static" === $offsetParent.css("position") && ($offsetParent = $offsetParent.offsetParent());
                var parentOffset = $offsetParent.offset();
                css.top -= parentOffset.top, css.left -= parentOffset.left, isCurrentlyAbove || isCurrentlyBelow || (newDirection = "below"), 
                enoughRoomBelow || !enoughRoomAbove || isCurrentlyAbove ? !enoughRoomAbove && enoughRoomBelow && isCurrentlyAbove && (newDirection = "below") : newDirection = "above", 
                ("above" == newDirection || isCurrentlyAbove && "below" !== newDirection) && (css.top = container.top - parentOffset.top - dropdown.height), 
                null != newDirection && (this.$dropdown.removeClass("select2-dropdown--below select2-dropdown--above").addClass("select2-dropdown--" + newDirection), 
                this.$container.removeClass("select2-container--below select2-container--above").addClass("select2-container--" + newDirection)), 
                this.$dropdownContainer.css(css);
            }, AttachBody.prototype._resizeDropdown = function() {
                var css = {
                    width: this.$container.outerWidth(!1) + "px"
                };
                this.options.get("dropdownAutoWidth") && (css.minWidth = css.width, css.position = "relative", 
                css.width = "auto"), this.$dropdown.css(css);
            }, AttachBody.prototype._showDropdown = function(decorated) {
                this.$dropdownContainer.appendTo(this.$dropdownParent), this._positionDropdown(), 
                this._resizeDropdown();
            }, AttachBody;
        }), S2.define("select2/dropdown/minimumResultsForSearch", [], function() {
            function countResults(data) {
                for (var count = 0, d = 0; d < data.length; d++) {
                    var item = data[d];
                    item.children ? count += countResults(item.children) : count++;
                }
                return count;
            }
            function MinimumResultsForSearch(decorated, $element, options, dataAdapter) {
                this.minimumResultsForSearch = options.get("minimumResultsForSearch"), this.minimumResultsForSearch < 0 && (this.minimumResultsForSearch = 1 / 0), 
                decorated.call(this, $element, options, dataAdapter);
            }
            return MinimumResultsForSearch.prototype.showSearch = function(decorated, params) {
                return !(countResults(params.data.results) < this.minimumResultsForSearch) && decorated.call(this, params);
            }, MinimumResultsForSearch;
        }), S2.define("select2/dropdown/selectOnClose", [], function() {
            function SelectOnClose() {}
            return SelectOnClose.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container), container.on("close", function(params) {
                    self._handleSelectOnClose(params);
                });
            }, SelectOnClose.prototype._handleSelectOnClose = function(_, params) {
                if (params && null != params.originalSelect2Event) {
                    var event = params.originalSelect2Event;
                    if ("select" === event._type || "unselect" === event._type) return;
                }
                var $highlightedResults = this.getHighlightedResults();
                if (!($highlightedResults.length < 1)) {
                    var data = $highlightedResults.data("data");
                    null != data.element && data.element.selected || null == data.element && data.selected || this.trigger("select", {
                        data: data
                    });
                }
            }, SelectOnClose;
        }), S2.define("select2/dropdown/closeOnSelect", [], function() {
            function CloseOnSelect() {}
            return CloseOnSelect.prototype.bind = function(decorated, container, $container) {
                var self = this;
                decorated.call(this, container, $container), container.on("select", function(evt) {
                    self._selectTriggered(evt);
                }), container.on("unselect", function(evt) {
                    self._selectTriggered(evt);
                });
            }, CloseOnSelect.prototype._selectTriggered = function(_, evt) {
                var originalEvent = evt.originalEvent;
                originalEvent && originalEvent.ctrlKey || this.trigger("close", {
                    originalEvent: originalEvent,
                    originalSelect2Event: evt
                });
            }, CloseOnSelect;
        }), S2.define("select2/i18n/en", [], function() {
            return {
                errorLoading: function() {
                    return "The results could not be loaded.";
                },
                inputTooLong: function(args) {
                    var overChars = args.input.length - args.maximum, message = "Please delete " + overChars + " character";
                    return 1 != overChars && (message += "s"), message;
                },
                inputTooShort: function(args) {
                    var remainingChars = args.minimum - args.input.length, message = "Please enter " + remainingChars + " or more characters";
                    return message;
                },
                loadingMore: function() {
                    return "Loading more results";
                },
                maximumSelected: function(args) {
                    var message = "You can only select " + args.maximum + " item";
                    return 1 != args.maximum && (message += "s"), message;
                },
                noResults: function() {
                    return "No results found";
                },
                searching: function() {
                    return "Searching";
                }
            };
        }), S2.define("select2/defaults", [ "jquery", "require", "./results", "./selection/single", "./selection/multiple", "./selection/placeholder", "./selection/allowClear", "./selection/search", "./selection/eventRelay", "./utils", "./translation", "./diacritics", "./data/select", "./data/array", "./data/ajax", "./data/tags", "./data/tokenizer", "./data/minimumInputLength", "./data/maximumInputLength", "./data/maximumSelectionLength", "./dropdown", "./dropdown/search", "./dropdown/hidePlaceholder", "./dropdown/infiniteScroll", "./dropdown/attachBody", "./dropdown/minimumResultsForSearch", "./dropdown/selectOnClose", "./dropdown/closeOnSelect", "./i18n/en" ], function($, require, ResultsList, SingleSelection, MultipleSelection, Placeholder, AllowClear, SelectionSearch, EventRelay, Utils, Translation, DIACRITICS, SelectData, ArrayData, AjaxData, Tags, Tokenizer, MinimumInputLength, MaximumInputLength, MaximumSelectionLength, Dropdown, DropdownSearch, HidePlaceholder, InfiniteScroll, AttachBody, MinimumResultsForSearch, SelectOnClose, CloseOnSelect, EnglishTranslation) {
            function Defaults() {
                this.reset();
            }
            Defaults.prototype.apply = function(options) {
                if (options = $.extend(!0, {}, this.defaults, options), null == options.dataAdapter) {
                    if (null != options.ajax ? options.dataAdapter = AjaxData : null != options.data ? options.dataAdapter = ArrayData : options.dataAdapter = SelectData, 
                    options.minimumInputLength > 0 && (options.dataAdapter = Utils.Decorate(options.dataAdapter, MinimumInputLength)), 
                    options.maximumInputLength > 0 && (options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumInputLength)), 
                    options.maximumSelectionLength > 0 && (options.dataAdapter = Utils.Decorate(options.dataAdapter, MaximumSelectionLength)), 
                    options.tags && (options.dataAdapter = Utils.Decorate(options.dataAdapter, Tags)), 
                    null == options.tokenSeparators && null == options.tokenizer || (options.dataAdapter = Utils.Decorate(options.dataAdapter, Tokenizer)), 
                    null != options.query) {
                        var Query = require(options.amdBase + "compat/query");
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, Query);
                    }
                    if (null != options.initSelection) {
                        var InitSelection = require(options.amdBase + "compat/initSelection");
                        options.dataAdapter = Utils.Decorate(options.dataAdapter, InitSelection);
                    }
                }
                if (null == options.resultsAdapter && (options.resultsAdapter = ResultsList, null != options.ajax && (options.resultsAdapter = Utils.Decorate(options.resultsAdapter, InfiniteScroll)), 
                null != options.placeholder && (options.resultsAdapter = Utils.Decorate(options.resultsAdapter, HidePlaceholder)), 
                options.selectOnClose && (options.resultsAdapter = Utils.Decorate(options.resultsAdapter, SelectOnClose))), 
                null == options.dropdownAdapter) {
                    if (options.multiple) options.dropdownAdapter = Dropdown; else {
                        var SearchableDropdown = Utils.Decorate(Dropdown, DropdownSearch);
                        options.dropdownAdapter = SearchableDropdown;
                    }
                    if (0 !== options.minimumResultsForSearch && (options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, MinimumResultsForSearch)), 
                    options.closeOnSelect && (options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, CloseOnSelect)), 
                    null != options.dropdownCssClass || null != options.dropdownCss || null != options.adaptDropdownCssClass) {
                        var DropdownCSS = require(options.amdBase + "compat/dropdownCss");
                        options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, DropdownCSS);
                    }
                    options.dropdownAdapter = Utils.Decorate(options.dropdownAdapter, AttachBody);
                }
                if (null == options.selectionAdapter) {
                    if (options.multiple ? options.selectionAdapter = MultipleSelection : options.selectionAdapter = SingleSelection, 
                    null != options.placeholder && (options.selectionAdapter = Utils.Decorate(options.selectionAdapter, Placeholder)), 
                    options.allowClear && (options.selectionAdapter = Utils.Decorate(options.selectionAdapter, AllowClear)), 
                    options.multiple && (options.selectionAdapter = Utils.Decorate(options.selectionAdapter, SelectionSearch)), 
                    null != options.containerCssClass || null != options.containerCss || null != options.adaptContainerCssClass) {
                        var ContainerCSS = require(options.amdBase + "compat/containerCss");
                        options.selectionAdapter = Utils.Decorate(options.selectionAdapter, ContainerCSS);
                    }
                    options.selectionAdapter = Utils.Decorate(options.selectionAdapter, EventRelay);
                }
                if ("string" == typeof options.language) if (options.language.indexOf("-") > 0) {
                    var languageParts = options.language.split("-"), baseLanguage = languageParts[0];
                    options.language = [ options.language, baseLanguage ];
                } else options.language = [ options.language ];
                if ($.isArray(options.language)) {
                    var languages = new Translation();
                    options.language.push("en");
                    for (var languageNames = options.language, l = 0; l < languageNames.length; l++) {
                        var name = languageNames[l], language = {};
                        try {
                            language = Translation.loadPath(name);
                        } catch (e) {
                            try {
                                name = this.defaults.amdLanguageBase + name, language = Translation.loadPath(name);
                            } catch (ex) {
                                options.debug && window.console && console.warn && console.warn('Select2: The language file for "' + name + '" could not be automatically loaded. A fallback will be used instead.');
                                continue;
                            }
                        }
                        languages.extend(language);
                    }
                    options.translations = languages;
                } else {
                    var baseTranslation = Translation.loadPath(this.defaults.amdLanguageBase + "en"), customTranslation = new Translation(options.language);
                    customTranslation.extend(baseTranslation), options.translations = customTranslation;
                }
                return options;
            }, Defaults.prototype.reset = function() {
                function stripDiacritics(text) {
                    function match(a) {
                        return DIACRITICS[a] || a;
                    }
                    return text.replace(/[^\u0000-\u007E]/g, match);
                }
                function matcher(params, data) {
                    if ("" === $.trim(params.term)) return data;
                    if (data.children && data.children.length > 0) {
                        for (var match = $.extend(!0, {}, data), c = data.children.length - 1; c >= 0; c--) {
                            var child = data.children[c], matches = matcher(params, child);
                            null == matches && match.children.splice(c, 1);
                        }
                        return match.children.length > 0 ? match : matcher(params, match);
                    }
                    var original = stripDiacritics(data.text).toUpperCase(), term = stripDiacritics(params.term).toUpperCase();
                    return original.indexOf(term) > -1 ? data : null;
                }
                this.defaults = {
                    amdBase: "./",
                    amdLanguageBase: "./i18n/",
                    closeOnSelect: !0,
                    debug: !1,
                    dropdownAutoWidth: !1,
                    escapeMarkup: Utils.escapeMarkup,
                    language: EnglishTranslation,
                    matcher: matcher,
                    minimumInputLength: 0,
                    maximumInputLength: 0,
                    maximumSelectionLength: 0,
                    minimumResultsForSearch: 0,
                    selectOnClose: !1,
                    sorter: function(data) {
                        return data;
                    },
                    templateResult: function(result) {
                        return result.text;
                    },
                    templateSelection: function(selection) {
                        return selection.text;
                    },
                    theme: "default",
                    width: "resolve"
                };
            }, Defaults.prototype.set = function(key, value) {
                var camelKey = $.camelCase(key), data = {};
                data[camelKey] = value;
                var convertedData = Utils._convertData(data);
                $.extend(this.defaults, convertedData);
            };
            var defaults = new Defaults();
            return defaults;
        }), S2.define("select2/options", [ "require", "jquery", "./defaults", "./utils" ], function(require, $, Defaults, Utils) {
            function Options(options, $element) {
                if (this.options = options, null != $element && this.fromElement($element), this.options = Defaults.apply(this.options), 
                $element && $element.is("input")) {
                    var InputCompat = require(this.get("amdBase") + "compat/inputData");
                    this.options.dataAdapter = Utils.Decorate(this.options.dataAdapter, InputCompat);
                }
            }
            return Options.prototype.fromElement = function($e) {
                var excludedData = [ "select2" ];
                null == this.options.multiple && (this.options.multiple = $e.prop("multiple")), 
                null == this.options.disabled && (this.options.disabled = $e.prop("disabled")), 
                null == this.options.language && ($e.prop("lang") ? this.options.language = $e.prop("lang").toLowerCase() : $e.closest("[lang]").prop("lang") && (this.options.language = $e.closest("[lang]").prop("lang"))), 
                null == this.options.dir && ($e.prop("dir") ? this.options.dir = $e.prop("dir") : $e.closest("[dir]").prop("dir") ? this.options.dir = $e.closest("[dir]").prop("dir") : this.options.dir = "ltr"), 
                $e.prop("disabled", this.options.disabled), $e.prop("multiple", this.options.multiple), 
                $e.data("select2Tags") && (this.options.debug && window.console && console.warn && console.warn('Select2: The `data-select2-tags` attribute has been changed to use the `data-data` and `data-tags="true"` attributes and will be removed in future versions of Select2.'), 
                $e.data("data", $e.data("select2Tags")), $e.data("tags", !0)), $e.data("ajaxUrl") && (this.options.debug && window.console && console.warn && console.warn("Select2: The `data-ajax-url` attribute has been changed to `data-ajax--url` and support for the old attribute will be removed in future versions of Select2."), 
                $e.attr("ajax--url", $e.data("ajaxUrl")), $e.data("ajax--url", $e.data("ajaxUrl")));
                var dataset = {};
                dataset = $.fn.jquery && "1." == $.fn.jquery.substr(0, 2) && $e[0].dataset ? $.extend(!0, {}, $e[0].dataset, $e.data()) : $e.data();
                var data = $.extend(!0, {}, dataset);
                data = Utils._convertData(data);
                for (var key in data) $.inArray(key, excludedData) > -1 || ($.isPlainObject(this.options[key]) ? $.extend(this.options[key], data[key]) : this.options[key] = data[key]);
                return this;
            }, Options.prototype.get = function(key) {
                return this.options[key];
            }, Options.prototype.set = function(key, val) {
                this.options[key] = val;
            }, Options;
        }), S2.define("select2/core", [ "jquery", "./options", "./utils", "./keys" ], function($, Options, Utils, KEYS) {
            var Select2 = function($element, options) {
                null != $element.data("select2") && $element.data("select2").destroy(), this.$element = $element, 
                this.id = this._generateId($element), options = options || {}, this.options = new Options(options, $element), 
                Select2.__super__.constructor.call(this);
                var tabindex = $element.attr("tabindex") || 0;
                $element.data("old-tabindex", tabindex), $element.attr("tabindex", "-1");
                var DataAdapter = this.options.get("dataAdapter");
                this.dataAdapter = new DataAdapter($element, this.options);
                var $container = this.render();
                this._placeContainer($container);
                var SelectionAdapter = this.options.get("selectionAdapter");
                this.selection = new SelectionAdapter($element, this.options), this.$selection = this.selection.render(), 
                this.selection.position(this.$selection, $container);
                var DropdownAdapter = this.options.get("dropdownAdapter");
                this.dropdown = new DropdownAdapter($element, this.options), this.$dropdown = this.dropdown.render(), 
                this.dropdown.position(this.$dropdown, $container);
                var ResultsAdapter = this.options.get("resultsAdapter");
                this.results = new ResultsAdapter($element, this.options, this.dataAdapter), this.$results = this.results.render(), 
                this.results.position(this.$results, this.$dropdown);
                var self = this;
                this._bindAdapters(), this._registerDomEvents(), this._registerDataEvents(), this._registerSelectionEvents(), 
                this._registerDropdownEvents(), this._registerResultsEvents(), this._registerEvents(), 
                this.dataAdapter.current(function(initialData) {
                    self.trigger("selection:update", {
                        data: initialData
                    });
                }), $element.addClass("select2-hidden-accessible"), $element.attr("aria-hidden", "true"), 
                this._syncAttributes(), $element.data("select2", this);
            };
            return Utils.Extend(Select2, Utils.Observable), Select2.prototype._generateId = function($element) {
                var id = "";
                return id = null != $element.attr("id") ? $element.attr("id") : null != $element.attr("name") ? $element.attr("name") + "-" + Utils.generateChars(2) : Utils.generateChars(4), 
                id = id.replace(/(:|\.|\[|\]|,)/g, ""), id = "select2-" + id;
            }, Select2.prototype._placeContainer = function($container) {
                $container.insertAfter(this.$element);
                var width = this._resolveWidth(this.$element, this.options.get("width"));
                null != width && $container.css("width", width);
            }, Select2.prototype._resolveWidth = function($element, method) {
                var WIDTH = /^width:(([-+]?([0-9]*\.)?[0-9]+)(px|em|ex|%|in|cm|mm|pt|pc))/i;
                if ("resolve" == method) {
                    var styleWidth = this._resolveWidth($element, "style");
                    return null != styleWidth ? styleWidth : this._resolveWidth($element, "element");
                }
                if ("element" == method) {
                    var elementWidth = $element.outerWidth(!1);
                    return elementWidth <= 0 ? "auto" : elementWidth + "px";
                }
                if ("style" == method) {
                    var style = $element.attr("style");
                    if ("string" != typeof style) return null;
                    for (var attrs = style.split(";"), i = 0, l = attrs.length; i < l; i += 1) {
                        var attr = attrs[i].replace(/\s/g, ""), matches = attr.match(WIDTH);
                        if (null !== matches && matches.length >= 1) return matches[1];
                    }
                    return null;
                }
                return method;
            }, Select2.prototype._bindAdapters = function() {
                this.dataAdapter.bind(this, this.$container), this.selection.bind(this, this.$container), 
                this.dropdown.bind(this, this.$container), this.results.bind(this, this.$container);
            }, Select2.prototype._registerDomEvents = function() {
                var self = this;
                this.$element.on("change.select2", function() {
                    self.dataAdapter.current(function(data) {
                        self.trigger("selection:update", {
                            data: data
                        });
                    });
                }), this.$element.on("focus.select2", function(evt) {
                    self.trigger("focus", evt);
                }), this._syncA = Utils.bind(this._syncAttributes, this), this._syncS = Utils.bind(this._syncSubtree, this), 
                this.$element[0].attachEvent && this.$element[0].attachEvent("onpropertychange", this._syncA);
                var observer = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
                null != observer ? (this._observer = new observer(function(mutations) {
                    $.each(mutations, self._syncA), $.each(mutations, self._syncS);
                }), this._observer.observe(this.$element[0], {
                    attributes: !0,
                    childList: !0,
                    subtree: !1
                })) : this.$element[0].addEventListener && (this.$element[0].addEventListener("DOMAttrModified", self._syncA, !1), 
                this.$element[0].addEventListener("DOMNodeInserted", self._syncS, !1), this.$element[0].addEventListener("DOMNodeRemoved", self._syncS, !1));
            }, Select2.prototype._registerDataEvents = function() {
                var self = this;
                this.dataAdapter.on("*", function(name, params) {
                    self.trigger(name, params);
                });
            }, Select2.prototype._registerSelectionEvents = function() {
                var self = this, nonRelayEvents = [ "toggle", "focus" ];
                this.selection.on("toggle", function() {
                    self.toggleDropdown();
                }), this.selection.on("focus", function(params) {
                    self.focus(params);
                }), this.selection.on("*", function(name, params) {
                    $.inArray(name, nonRelayEvents) === -1 && self.trigger(name, params);
                });
            }, Select2.prototype._registerDropdownEvents = function() {
                var self = this;
                this.dropdown.on("*", function(name, params) {
                    self.trigger(name, params);
                });
            }, Select2.prototype._registerResultsEvents = function() {
                var self = this;
                this.results.on("*", function(name, params) {
                    self.trigger(name, params);
                });
            }, Select2.prototype._registerEvents = function() {
                var self = this;
                this.on("open", function() {
                    self.$container.addClass("select2-container--open");
                }), this.on("close", function() {
                    self.$container.removeClass("select2-container--open");
                }), this.on("enable", function() {
                    self.$container.removeClass("select2-container--disabled");
                }), this.on("disable", function() {
                    self.$container.addClass("select2-container--disabled");
                }), this.on("blur", function() {
                    self.$container.removeClass("select2-container--focus");
                }), this.on("query", function(params) {
                    self.isOpen() || self.trigger("open", {}), this.dataAdapter.query(params, function(data) {
                        self.trigger("results:all", {
                            data: data,
                            query: params
                        });
                    });
                }), this.on("query:append", function(params) {
                    this.dataAdapter.query(params, function(data) {
                        self.trigger("results:append", {
                            data: data,
                            query: params
                        });
                    });
                }), this.on("keypress", function(evt) {
                    var key = evt.which;
                    self.isOpen() ? key === KEYS.ESC || key === KEYS.TAB || key === KEYS.UP && evt.altKey ? (self.close(), 
                    evt.preventDefault()) : key === KEYS.ENTER ? (self.trigger("results:select", {}), 
                    evt.preventDefault()) : key === KEYS.SPACE && evt.ctrlKey ? (self.trigger("results:toggle", {}), 
                    evt.preventDefault()) : key === KEYS.UP ? (self.trigger("results:previous", {}), 
                    evt.preventDefault()) : key === KEYS.DOWN && (self.trigger("results:next", {}), 
                    evt.preventDefault()) : (key === KEYS.ENTER || key === KEYS.SPACE || key === KEYS.DOWN && evt.altKey) && (self.open(), 
                    evt.preventDefault());
                });
            }, Select2.prototype._syncAttributes = function() {
                this.options.set("disabled", this.$element.prop("disabled")), this.options.get("disabled") ? (this.isOpen() && this.close(), 
                this.trigger("disable", {})) : this.trigger("enable", {});
            }, Select2.prototype._syncSubtree = function(evt, mutations) {
                var changed = !1, self = this;
                if (!evt || !evt.target || "OPTION" === evt.target.nodeName || "OPTGROUP" === evt.target.nodeName) {
                    if (mutations) if (mutations.addedNodes && mutations.addedNodes.length > 0) for (var n = 0; n < mutations.addedNodes.length; n++) {
                        var node = mutations.addedNodes[n];
                        node.selected && (changed = !0);
                    } else mutations.removedNodes && mutations.removedNodes.length > 0 && (changed = !0); else changed = !0;
                    changed && this.dataAdapter.current(function(currentData) {
                        self.trigger("selection:update", {
                            data: currentData
                        });
                    });
                }
            }, Select2.prototype.trigger = function(name, args) {
                var actualTrigger = Select2.__super__.trigger, preTriggerMap = {
                    open: "opening",
                    close: "closing",
                    select: "selecting",
                    unselect: "unselecting"
                };
                if (void 0 === args && (args = {}), name in preTriggerMap) {
                    var preTriggerName = preTriggerMap[name], preTriggerArgs = {
                        prevented: !1,
                        name: name,
                        args: args
                    };
                    if (actualTrigger.call(this, preTriggerName, preTriggerArgs), preTriggerArgs.prevented) return void (args.prevented = !0);
                }
                actualTrigger.call(this, name, args);
            }, Select2.prototype.toggleDropdown = function() {
                this.options.get("disabled") || (this.isOpen() ? this.close() : this.open());
            }, Select2.prototype.open = function() {
                this.isOpen() || this.trigger("query", {});
            }, Select2.prototype.close = function() {
                this.isOpen() && this.trigger("close", {});
            }, Select2.prototype.isOpen = function() {
                return this.$container.hasClass("select2-container--open");
            }, Select2.prototype.hasFocus = function() {
                return this.$container.hasClass("select2-container--focus");
            }, Select2.prototype.focus = function(data) {
                this.hasFocus() || (this.$container.addClass("select2-container--focus"), this.trigger("focus", {}));
            }, Select2.prototype.enable = function(args) {
                this.options.get("debug") && window.console && console.warn && console.warn('Select2: The `select2("enable")` method has been deprecated and will be removed in later Select2 versions. Use $element.prop("disabled") instead.'), 
                null != args && 0 !== args.length || (args = [ !0 ]);
                var disabled = !args[0];
                this.$element.prop("disabled", disabled);
            }, Select2.prototype.data = function() {
                this.options.get("debug") && arguments.length > 0 && window.console && console.warn && console.warn('Select2: Data can no longer be set using `select2("data")`. You should consider setting the value instead using `$element.val()`.');
                var data = [];
                return this.dataAdapter.current(function(currentData) {
                    data = currentData;
                }), data;
            }, Select2.prototype.val = function(args) {
                if (this.options.get("debug") && window.console && console.warn && console.warn('Select2: The `select2("val")` method has been deprecated and will be removed in later Select2 versions. Use $element.val() instead.'), 
                null == args || 0 === args.length) return this.$element.val();
                var newVal = args[0];
                $.isArray(newVal) && (newVal = $.map(newVal, function(obj) {
                    return obj.toString();
                })), this.$element.val(newVal).trigger("change");
            }, Select2.prototype.destroy = function() {
                this.$container.remove(), this.$element[0].detachEvent && this.$element[0].detachEvent("onpropertychange", this._syncA), 
                null != this._observer ? (this._observer.disconnect(), this._observer = null) : this.$element[0].removeEventListener && (this.$element[0].removeEventListener("DOMAttrModified", this._syncA, !1), 
                this.$element[0].removeEventListener("DOMNodeInserted", this._syncS, !1), this.$element[0].removeEventListener("DOMNodeRemoved", this._syncS, !1)), 
                this._syncA = null, this._syncS = null, this.$element.off(".select2"), this.$element.attr("tabindex", this.$element.data("old-tabindex")), 
                this.$element.removeClass("select2-hidden-accessible"), this.$element.attr("aria-hidden", "false"), 
                this.$element.removeData("select2"), this.dataAdapter.destroy(), this.selection.destroy(), 
                this.dropdown.destroy(), this.results.destroy(), this.dataAdapter = null, this.selection = null, 
                this.dropdown = null, this.results = null;
            }, Select2.prototype.render = function() {
                var $container = $('<span class="select2 select2-container"><span class="selection"></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>');
                return $container.attr("dir", this.options.get("dir")), this.$container = $container, 
                this.$container.addClass("select2-container--" + this.options.get("theme")), $container.data("element", this.$element), 
                $container;
            }, Select2;
        }), S2.define("jquery-mousewheel", [ "jquery" ], function($) {
            return $;
        }), S2.define("jquery.select2", [ "jquery", "jquery-mousewheel", "./select2/core", "./select2/defaults" ], function($, _, Select2, Defaults) {
            if (null == $.fn.select2) {
                var thisMethods = [ "open", "close", "destroy" ];
                $.fn.select2 = function(options) {
                    if (options = options || {}, "object" == typeof options) return this.each(function() {
                        var instanceOptions = $.extend(!0, {}, options);
                        new Select2($(this), instanceOptions);
                    }), this;
                    if ("string" == typeof options) {
                        var ret, args = Array.prototype.slice.call(arguments, 1);
                        return this.each(function() {
                            var instance = $(this).data("select2");
                            null == instance && window.console && console.error && console.error("The select2('" + options + "') method was called on an element that is not using Select2."), 
                            ret = instance[options].apply(instance, args);
                        }), $.inArray(options, thisMethods) > -1 ? this : ret;
                    }
                    throw new Error("Invalid arguments for Select2: " + options);
                };
            }
            return null == $.fn.select2.defaults && ($.fn.select2.defaults = Defaults), Select2;
        }), {
            define: S2.define,
            require: S2.require
        };
    }(), select2 = S2.require("jquery.select2");
    return jQuery.fn.select2.amd = S2, select2;
}), function(root, factory) {
    "object" == typeof exports && "object" == typeof module ? module.exports = factory(require("jquery")) : "function" == typeof define && define.amd ? define([ "jquery" ], factory) : "object" == typeof exports ? exports.autonumeric = factory(require("jquery")) : root.autonumeric = factory(root.jQuery);
}(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
    return function(modules) {
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId]) return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: !1
            };
            return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
            module.loaded = !0, module.exports;
        }
        var installedModules = {};
        return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
        __webpack_require__.p = "", __webpack_require__(0);
    }([ function(module, exports, __webpack_require__) {
        eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*** IMPORTS FROM imports-loader ***/\nvar jQuery = __webpack_require__(1);\nvar $ = __webpack_require__(1);\n(function() {\n\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n *               autoNumeric.js\n *\n * @version      2.0.8\n * @date         2017-02-01 UTC 19:30\n *\n * @author       Bob Knothe\n * @contributors Alexandre Bonneau, Sokolov Yura and other Github users,\n *               cf. AUTHORS.md.\n * @copyright    2009 Robert J. Knothe http://www.decorplanit.com/plugin/\n * @since        2009-08-09\n *\n * @summary      autoNumeric is a library that provides live as-you-type\n *               formatting for international numbers and currencies.\n *\n *               Note : Some functions are borrowed from big.js\n * @link         https://github.com/MikeMcl/big.js/\n *\n * Please report any bugs to https://github.com/BobKnothe/autoNumeric\n *\n * @license      Released under the MIT License\n * @link         http://www.opensource.org/licenses/mit-license.php\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation\n * files (the \"Software\"), to deal in the Software without\n * restriction, including without limitation the rights to use,\n * copy, modify, merge, publish, distribute, sub license, and/or sell\n * copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following\n * conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n * OTHER DEALINGS IN THE SOFTWARE.\n */\n\n/* global module, require, define */\n\n// Functions names for ES6 exports\nvar autoFormat = void 0;\nvar autoUnFormat = void 0;\nvar getDefaultConfig = void 0;\nvar getLanguages = void 0;\nvar validate = void 0;\nvar areSettingsValid = void 0;\n\n// AutoNumeric default settings\n/**\n * List of allowed tag on which autoNumeric can be used.\n */\nvar allowedTagList = ['b', 'caption', 'cite', 'code', 'const', 'dd', 'del', 'div', 'dfn', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ins', 'kdb', 'label', 'li', 'option', 'output', 'p', 'q', 's', 'sample', 'span', 'strong', 'td', 'th', 'u'];\n\n/**\n * Defaults options are public - these can be overridden by the following method:\n * - HTML5 data attributes (ie. `<input type=\"text\" data-currency-symbol=\" \">`)\n * - Options passed by the 'init' or 'update' methods (ie. `aNInput.autoNumeric('update', { currencySymbol: ' ' });`)\n * - Use jQuery's `$.extend` method for global changes - also a great way to pass ASP.NET current culture settings\n */\nvar defaultSettings = {\n    /* Allowed thousand grouping separator characters :\n     * ','      // Comma\n     * '.'      // Dot\n     * ' '      // Normal space\n     * '\\u2009' // Thin-space\n     * '\\u202f' // Narrow no-break space\n     * '\\u00a0' // No-break space\n     * ''       // No separator\n     * \"'\"      // Apostrophe\n     * ''      // Arabic thousands separator\n     * ''      // Dot above\n     * Deprecated older option name : aSep\n     */\n    digitGroupSeparator: ',',\n\n    /* Remove the thousand separator on focus, currency symbol and suffix on focus\n     * example if the input value \"$ 1,999.88 suffix\"\n     * on \"focusin\" it becomes \"1999.88\" and back to \"$ 1,999.88 suffix\" on focus out.\n     * Deprecated older option name : nSep\n     */\n    noSeparatorOnFocus: false,\n\n    /* Digital grouping for the thousand separator used in Format\n     * digitalGroupSpacing: \"2\", results in 99,99,99,999 India's lakhs\n     * digitalGroupSpacing: \"2s\", results in 99,999,99,99,999 India's lakhs scaled\n     * digitalGroupSpacing: \"3\", results in 999,999,999 default\n     * digitalGroupSpacing: \"4\", results in 9999,9999,9999 used in some Asian countries\n     * Deprecated older option name : dGroup\n     */\n    digitalGroupSpacing: '3',\n\n    /* Allowed decimal separator characters :\n     * ',' : Comma\n     * '.' : Dot\n     * '' : Middle-dot\n     * '' : Arabic decimal separator\n     * '' : Decimal separator key symbol\n     * Deprecated older option name : aDec\n     */\n    decimalCharacter: '.',\n\n    /* Allow to declare an alternative decimal separator which is automatically replaced by `decimalCharacter` when typed.\n     * This is used by countries that use a comma \",\" as the decimal character and have keyboards\\numeric pads that have\n     * a period 'full stop' as the decimal characters (France or Spain for instance).\n     * Deprecated older option name : altDec\n     */\n    decimalCharacterAlternative: null,\n\n    /* currencySymbol = allowed currency symbol\n     * Must be in quotes currencySymbol: \"$\"\n     * space to the right of the currency symbol currencySymbol: '$ '\n     * space to the left of the currency symbol currencySymbol: ' $'\n     * Deprecated older option name : aSign\n     */\n    currencySymbol: '',\n\n    /* currencySymbolPlacement = placement of currency sign as a p=prefix or s=suffix\n     * for prefix currencySymbolPlacement: \"p\" (default)\n     * for suffix currencySymbolPlacement: \"s\"\n     * Deprecated older option name : pSign\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    currencySymbolPlacement: 'p',\n\n    /* Placement of negative/positive sign relative to the currencySymbol option l=left, r=right, p=prefix & s=suffix\n     * -1,234.56  => default no options required\n     * -$1,234.56 => {currencySymbol: \"$\"} or {currencySymbol: \"$\", negativePositiveSignPlacement: \"l\"}\n     * $-1,234.56 => {currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\n     * -1,234.56$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"} // Default if negativePositiveSignPlacement is 'null' and currencySymbol is not empty\n     * 1,234.56-  => {negativePositiveSignPlacement: \"s\"}\n     * $1,234.56- => {currencySymbol: \"$\", negativePositiveSignPlacement: \"s\"}\n     * 1,234.56-$ => {currencySymbol: \"$\", currencySymbolPlacement: \"s\"}\n     * 1,234.56$- => {currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"r\"}\n     * Deprecated older option name : pNeg\n     */\n    //TODO Rename the options to more explicit names ('p' => 'prefix', etc.)\n    negativePositiveSignPlacement: null,\n\n    /* Allow the positive sign symbol `+` to be displayed for positive numbers.\n     * By default, this positive sign is not shown.\n     * The sign placement is controlled by the 'negativePositiveSignPlacement' option, mimicking the negative sign placement rules.\n     */\n    showPositiveSign: false,\n\n    /* Additional suffix\n     * Must be in quotes suffixText: 'gross', a space is allowed suffixText: ' dollars'\n     * Numeric characters and negative sign not allowed'\n     * Deprecated older option name : aSuffix\n     */\n    suffixText: '',\n\n    /* Override min max limits\n     * overrideMinMaxLimits: \"ceiling\" adheres to maximumValue and ignores minimumValue settings\n     * overrideMinMaxLimits: \"floor\" adheres to minimumValue and ignores maximumValue settings\n     * overrideMinMaxLimits: \"ignore\" ignores both minimumValue & maximumValue\n     * Deprecated older option name : oLimits\n     */\n    overrideMinMaxLimits: null,\n\n    /* Maximum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be larger than minimumValue\n     * Deprecated older option name : vMax\n     */\n    maximumValue: '9999999999999.99', // 9.999.999.999.999,99 ~= 10000 billions\n\n    /* Minimum possible value\n     * value must be enclosed in quotes and use the period for the decimal point\n     * value must be smaller than maximumValue\n     * Deprecated older option name : vMin\n     */\n    minimumValue: '-9999999999999.99', // -9.999.999.999.999,99 ~= 10000 billions\n\n    /* Maximum number of decimal places = used to override decimal places set by the minimumValue & maximumValue values\n     * Deprecated older option name : mDec\n     */\n    decimalPlacesOverride: null,\n\n    /* Expanded decimal places visible when input has focus - example:\n     * {decimalPlacesShownOnFocus: \"5\"} and the default 2 decimal places with focus \"1,000.12345\" without focus \"1,000.12\" the results depends on the rounding method used\n     * the \"get\" method returns the extended decimal places\n     * Deprecated older option name : eDec\n     */\n    decimalPlacesShownOnFocus: null,\n\n    /* The next three options (scaleDivisor, scaleDecimalPlaces & scaleSymbol) handle scaling of the input when the input does not have focus\n     * Please note that the non-scaled value is held in data and it is advised that you use the \"saveValueToSessionStorage\" option to ensure retaining the value\n     * [\"divisor\", \"decimal places\", \"symbol\"]\n     * Example: with the following options set {scaleDivisor: '1000', scaleDecimalPlaces: '1', scaleSymbol: ' K'}\n     * Example: focusin value \"1,111.11\" focusout value \"1.1 K\"\n     */\n\n    /* The `scaleDivisor` decides the on focus value and places the result in the input on focusout\n     * Example {scaleDivisor: '1000'} or <input data-scale-divisor=\"1000\">\n     * The divisor value - does not need to be whole number but please understand that Javascript has limited accuracy in math\n     * The \"get\" method returns the full value, including the 'hidden' decimals.\n     */\n    scaleDivisor: null,\n\n    /*\n     * The `scaleDecimalPlaces` option is the number of decimal place when not in focus - for this to work, `scaledDivisor` must not be `null`.\n     * This is optional ; if omitted the decimal places will be the same when the input has the focus.\n     * Deprecated older option name : scaleDecimal\n     */\n    scaleDecimalPlaces: null,\n\n    /*\n     * The `scaleSymbol` option is a symbol placed as a suffix when not in focus.\n     * This is optional too.\n     */\n    scaleSymbol: null,\n\n    /* Set to true to allow the decimalPlacesShownOnFocus value to be saved with sessionStorage\n     * if ie 6 or 7 the value will be saved as a session cookie\n     * Deprecated older option name : aStor\n     */\n    saveValueToSessionStorage: false,\n\n    /*\n     * Manage how autoNumeric react when the user tries to paste an invalid number.\n     * - 'error'    : (This is the default behavior) The input value is not changed and an error is output in the console.\n     * - 'ignore'   : idem than 'error', but fail silently without outputting any error/warning in the console.\n     * - 'clamp'    : if the pasted value is either too small or too big regarding the minimumValue and maximumValue range, then the result is clamped to those limits.\n     * - 'truncate' : autoNumeric will insert as many pasted numbers it can at the initial caret/selection, until everything is pasted, or the range limit is hit.\n     *                The non-pasted numbers are dropped and therefore not used at all.\n     * - 'replace'  : autoNumeric will first insert as many pasted numbers it can at the initial caret/selection, then if the range limit is hit, it will try\n     *                to replace one by one the remaining initial numbers (on the right side of the caret) with the rest of the pasted numbers.\n     *\n     * Note 1 : A paste content starting with a negative sign '-' will be accepted anywhere in the input, and will set the resulting value as a negative number\n     * Note 2 : A paste content starting with a number will be accepted, even if the rest is gibberish (ie. '123foobar456').\n     *          Only the first number will be used (here '123').\n     * Note 3 : The paste event works with the `decimalPlacesShownOnFocus` option too.\n     */\n    //TODO Shouldn't we use `truncate` as the default value?\n    onInvalidPaste: 'error',\n\n    /* method used for rounding\n     * roundingMethod: \"S\", Round-Half-Up Symmetric (default)\n     * roundingMethod: \"A\", Round-Half-Up Asymmetric\n     * roundingMethod: \"s\", Round-Half-Down Symmetric (lower case s)\n     * roundingMethod: \"a\", Round-Half-Down Asymmetric (lower case a)\n     * roundingMethod: \"B\", Round-Half-Even \"Bankers Rounding\"\n     * roundingMethod: \"U\", Round Up \"Round-Away-From-Zero\"\n     * roundingMethod: \"D\", Round Down \"Round-Toward-Zero\" - same as truncate\n     * roundingMethod: \"C\", Round to Ceiling \"Toward Positive Infinity\"\n     * roundingMethod: \"F\", Round to Floor \"Toward Negative Infinity\"\n     * roundingMethod: \"N05\" Rounds to the nearest .05 => same as \"CHF\" used in 1.9X and still valid\n     * roundingMethod: \"U05\" Rounds up to next .05\n     * roundingMethod: \"D05\" Rounds down to next .05\n     * Deprecated older option name : mRound\n     */\n    //TODO Rename the options to more explicit names ('S' => 'RoundHalfUpSymmetric', etc.)\n    //TODO Add an `an.roundingMethod` object that enum those options clearly\n    roundingMethod: 'S',\n\n    /* Allow padding the decimal places with zeros\n     * allowDecimalPadding: true - always Pad decimals with zeros\n     * allowDecimalPadding: false - does not pad with zeros.\n     * Note: setting allowDecimalPadding to 'false' will override the 'decimalPlacesOverride' setting.\n     *\n     * thanks to Jonas Johansson for the suggestion\n     * Deprecated older option name : aPad\n     */\n    allowDecimalPadding: true,\n\n    /* Adds brackets on negative values (ie. transforms '-$ 999.99' to '(999.99)')\n     * Those brackets are visible only when the field does NOT have the focus.\n     * The left and right symbols should be enclosed in quotes and separated by a comma\n     * This option can be of the following values :\n     * null, // This is the default value, which deactivate this feature\n     * '(,)',\n     * '[,]',\n     * '<,>' or\n     * '{,}'\n     * Deprecated older option name : nBracket\n     */\n    //TODO Rename the options to more explicit names ('(,)' => 'parentheses', etc.)\n    negativeBracketsTypeOnBlur: null,\n\n    /* Displayed on empty string \"\"\n     * emptyInputBehavior: \"focus\" - (default) currency sign displayed and the input receives focus\n     * emptyInputBehavior: \"press\" - currency sign displays on any key being pressed\n     * emptyInputBehavior: \"always\" - always displays the currency sign only\n     * emptyInputBehavior: \"zero\" - if the input has no value on focus out displays a zero \"rounded\" with or without a currency sign\n     * Deprecated older option name : wEmpty\n     */\n    emptyInputBehavior: 'focus',\n\n    /* Controls leading zero behavior\n     * leadingZero: \"allow\", - allows leading zeros to be entered. Zeros will be truncated when entering additional digits. On focusout zeros will be deleted.\n     * leadingZero: \"deny\", - allows only one leading zero on values less than one\n     * leadingZero: \"keep\", - allows leading zeros to be entered. on focusout zeros will be retained.\n     * Deprecated older option name : lZero\n     */\n    leadingZero: 'deny',\n\n    /* Determine if the default value will be formatted on initialization.\n     * true = automatically formats the default value on initialization\n     * false = will not format the default value on initialization\n     * Deprecated older option name : aForm\n     */\n    formatOnPageLoad: true,\n\n    /* Determine if the select all keyboard command will select the complete input text, or only the input numeric value\n     * Note : If the currency symbol is between the numeric value and the negative sign, only the numeric value will selected\n     * Deprecated older option name : sNumber\n     */\n    selectNumberOnly: false,\n\n    /* Helper option for ASP.NET postback\n     * should be the value of the unformatted default value\n     * examples:\n     * no default value=\"\" {defaultValueOverride: \"\"}\n     * value=1234.56 {defaultValueOverride: '1234.56'}\n     * Deprecated older option name : anDefault\n     */\n    defaultValueOverride: null,\n\n    /* Removes formatting on submit event\n     * this output format: positive nnnn.nn, negative -nnnn.nn\n     * review the 'unSet' method for other formats\n     * Deprecated older option name : unSetOnSubmit\n     */\n    unformatOnSubmit: false,\n\n    /* Allows the output to be in the locale format via the \"get\", \"getString\" & \"getArray\" methods\n     * null or 'string' => 'nnnn.nn' or '-nnnn.nn' as text type. This is the default behavior.\n     * 'number'         => nnnn.nn or -nnnn.nn as a Number (Warning: this works only for integers inferior to Number.MAX_SAFE_INTEGER)\n     * ',' or '-,'      => 'nnnn,nn' or '-nnnn,nn'\n     * '.-'             => 'nnnn.nn' or 'nnnn.nn-'\n     * ',-'             => 'nnnn,nn' or 'nnnn,nn-'\n     * Deprecated older option name : outputType\n     */\n    outputFormat: null,\n\n    /* Defines if warnings should be shown\n     * Error handling function\n     * true => all warning are shown\n     * false => no warnings are shown, only the thrown errors\n     * Deprecated older option name : debug\n     */\n    showWarnings: true,\n\n    /*\n     * This option is the 'strict mode' (aka 'debug' mode), which allows autoNumeric to strictly analyse the options passed, and fails if an unknown options is used in the settings object.\n     * You should set that to 'TRUE' if you want to make sure you are only using 'pure' autoNumeric settings objects in your code.\n     * If you see uncaught errors in the console and your code starts to fail, this means somehow those options gets corrupted by another program.\n     */\n    failOnUnknownOption: false\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective keyCode as seen in DOM events.\n * //TODO Replace every call to this object with a call to `keyName`\n * @deprecated\n */\nvar keyCode = {\n    Backspace: 8,\n    Tab: 9,\n    Enter: 13,\n    Shift: 16,\n    Ctrl: 17,\n    Alt: 18,\n    PauseBreak: 19,\n    CapsLock: 20,\n    Esc: 27,\n    Space: 32,\n    PageUp: 33,\n    PageDown: 34,\n    End: 35,\n    Home: 36,\n    LeftArrow: 37,\n    UpArrow: 38,\n    RightArrow: 39,\n    DownArrow: 40,\n    Insert: 45,\n    Delete: 46,\n    num0: 48,\n    num1: 49,\n    num2: 50,\n    num3: 51,\n    num4: 52,\n    num5: 53,\n    num6: 54,\n    num7: 55,\n    num8: 56,\n    num9: 57,\n    a: 65,\n    b: 66,\n    c: 67,\n    d: 68,\n    e: 69,\n    f: 70,\n    g: 71,\n    h: 72,\n    i: 73,\n    j: 74,\n    k: 75,\n    l: 76,\n    m: 77,\n    n: 78,\n    o: 79,\n    p: 80,\n    q: 81,\n    r: 82,\n    s: 83,\n    t: 84,\n    u: 85,\n    v: 86,\n    w: 87,\n    x: 88,\n    y: 89,\n    z: 90,\n    Windows: 91,\n    RightClick: 93,\n    numpad0: 96,\n    numpad1: 97,\n    numpad2: 98,\n    numpad3: 99,\n    numpad4: 100,\n    numpad5: 101,\n    numpad6: 102,\n    numpad7: 103,\n    numpad8: 104,\n    numpad9: 105,\n    MultiplyNumpad: 106,\n    PlusNumpad: 107,\n    MinusNumpad: 109,\n    DotNumpad: 110,\n    SlashNumpad: 111,\n    F1: 112,\n    F2: 113,\n    F3: 114,\n    F4: 115,\n    F5: 116,\n    F6: 117,\n    F7: 118,\n    F8: 119,\n    F9: 120,\n    F10: 121,\n    F11: 122,\n    F12: 123,\n    NumLock: 144,\n    ScrollLock: 145,\n    MyComputer: 182,\n    MyCalculator: 183,\n    Semicolon: 186,\n    Equal: 187,\n    Comma: 188,\n    Hyphen: 189,\n    Dot: 190,\n    Slash: 191,\n    Backquote: 192,\n    LeftBracket: 219,\n    Backslash: 220,\n    RightBracket: 221,\n    Quote: 222,\n    Command: 224\n};\n\n/**\n * Wrapper variable that hold named keyboard keys with their respective key name (as set in KeyboardEvent.key).\n * Those names are listed here :\n * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n */\nvar keyName = {\n    // Special values\n    Unidentified: 'Unidentified',\n\n    // Modifier keys\n    Alt: 'Alt',\n    AltGr: 'AltGraph',\n    CapsLock: 'CapsLock', // Under Chrome, e.key is empty for CapsLock\n    Ctrl: 'Control',\n    Fn: 'Fn',\n    FnLock: 'FnLock',\n    Hyper: 'Hyper', // 'OS' under Firefox\n    Meta: 'Meta', // The Windows, Command or  key // 'OS' under Firefox and IE9\n    Windows: 'Meta', // This is a non-official key name\n    Command: 'Meta', // This is a non-official key name\n    NumLock: 'NumLock',\n    ScrollLock: 'ScrollLock',\n    Shift: 'Shift',\n    Super: 'Super', // 'OS' under Firefox\n    Symbol: 'Symbol',\n    SymbolLock: 'SymbolLock',\n\n    // Whitespace keys\n    Enter: 'Enter',\n    Tab: 'Tab',\n    Space: ' ', // 'Spacebar' for Firefox <37, and IE9\n\n    // Navigation keys\n    DownArrow: 'ArrowDown', // 'Down' for Firefox <=36, and IE9\n    LeftArrow: 'ArrowLeft', // 'Left' for Firefox <=36, and IE9\n    RightArrow: 'ArrowRight', // 'Right' for Firefox <=36, and IE9\n    UpArrow: 'ArrowUp', // 'Up' for Firefox <=36, and IE9\n    End: 'End',\n    Home: 'Home',\n    PageDown: 'PageDown',\n    PageUp: 'PageUp',\n\n    // Editing keys\n    Backspace: 'Backspace',\n    Clear: 'Clear',\n    Copy: 'Copy',\n    CrSel: 'CrSel', // 'Crsel' for Firefox <=36, and IE9\n    Cut: 'Cut',\n    Delete: 'Delete', // 'Del' for Firefox <=36, and IE9\n    EraseEof: 'EraseEof',\n    ExSel: 'ExSel', // 'Exsel' for Firefox <=36, and IE9\n    Insert: 'Insert',\n    Paste: 'Paste',\n    Redo: 'Redo',\n    Undo: 'Undo',\n\n    // UI keys\n    Accept: 'Accept',\n    Again: 'Again',\n    Attn: 'Attn', // 'Unidentified' for Firefox, Chrome, and IE9 ('KanaMode' when using the Japanese keyboard layout)\n    Cancel: 'Cancel',\n    ContextMenu: 'ContextMenu', // 'Apps' for Firefox <=36, and IE9\n    Esc: 'Escape', // 'Esc' for Firefox <=36, and IE9\n    Execute: 'Execute',\n    Find: 'Find',\n    Finish: 'Finish', // 'Unidentified' for Firefox, Chrome, and IE9 ('Katakana' when using the Japanese keyboard layout)\n    Help: 'Help',\n    Pause: 'Pause',\n    Play: 'Play',\n    Props: 'Props',\n    Select: 'Select',\n    ZoomIn: 'ZoomIn',\n    ZoomOut: 'ZoomOut',\n\n    // Device keys\n    BrightnessDown: 'BrightnessDown',\n    BrightnessUp: 'BrightnessUp',\n    Eject: 'Eject',\n    LogOff: 'LogOff',\n    Power: 'Power',\n    PowerOff: 'PowerOff',\n    PrintScreen: 'PrintScreen',\n    Hibernate: 'Hibernate', // 'Unidentified' for Firefox <=37\n    Standby: 'Standby', // 'Unidentified' for Firefox <=36, and IE9\n    WakeUp: 'WakeUp',\n\n    // IME and composition keys\n    Compose: 'Compose',\n    Dead: 'Dead',\n\n    // Function keys\n    F1: 'F1',\n    F2: 'F2',\n    F3: 'F3',\n    F4: 'F4',\n    F5: 'F5',\n    F6: 'F6',\n    F7: 'F7',\n    F8: 'F8',\n    F9: 'F9',\n    F10: 'F10',\n    F11: 'F11',\n    F12: 'F12',\n\n    // Document keys\n    Print: 'Print',\n\n    // 'Normal' keys\n    num0: '0',\n    num1: '1',\n    num2: '2',\n    num3: '3',\n    num4: '4',\n    num5: '5',\n    num6: '6',\n    num7: '7',\n    num8: '8',\n    num9: '9',\n    numpad0: '0',\n    numpad1: '1',\n    numpad2: '2',\n    numpad3: '3',\n    numpad4: '4',\n    numpad5: '5',\n    numpad6: '6',\n    numpad7: '7',\n    numpad8: '8',\n    numpad9: '9',\n    a: 'a',\n    b: 'b',\n    c: 'c',\n    d: 'd',\n    e: 'e',\n    f: 'f',\n    g: 'g',\n    h: 'h',\n    i: 'i',\n    j: 'j',\n    k: 'k',\n    l: 'l',\n    m: 'm',\n    n: 'n',\n    o: 'o',\n    p: 'p',\n    q: 'q',\n    r: 'r',\n    s: 's',\n    t: 't',\n    u: 'u',\n    v: 'v',\n    w: 'w',\n    x: 'x',\n    y: 'y',\n    z: 'z',\n    MultiplyNumpad: '*',\n    PlusNumpad: '+',\n    MinusNumpad: '-',\n    DotNumpad: '.',\n    SlashNumpad: '/',\n    Semicolon: ';',\n    Equal: '=',\n    Comma: ',',\n    Hyphen: '-',\n    Minus: '-',\n    Plus: '+',\n    Dot: '.',\n    Slash: '/',\n    Backquote: '`',\n    LeftBracket: '[',\n    RightBracket: ']',\n    Backslash: '\\\\',\n    Quote: \"'\"\n};\n\nvar defaultMinimumValue = '-999999999999.99';\nvar defaultMaximumValue = '999999999999.99';\nvar defaultRoundingMethod = 'U';\nvar defaultLeadingZero = 'deny';\nvar defaultSelectNumberOnly = true;\n\n/**\n * Predefined options for the most common languages\n */\nvar languageOption = {\n    French: { // Franais\n        digitGroupSeparator: '.', // or '\\u202f'\n        decimalCharacter: ',',\n        decimalCharacterAlternative: '.',\n        currencySymbol: '\\u202F\\u20AC',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    NorthAmerican: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '$',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    British: {\n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Swiss: { // Suisse\n        digitGroupSeparator: '\\'',\n        decimalCharacter: '.',\n        currencySymbol: '\\u202FCHF',\n        currencySymbolPlacement: 's',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    },\n    Japanese: { // \n        digitGroupSeparator: ',',\n        decimalCharacter: '.',\n        currencySymbol: '',\n        currencySymbolPlacement: 'p',\n        selectNumberOnly: defaultSelectNumberOnly,\n        roundingMethod: defaultRoundingMethod,\n        leadingZero: defaultLeadingZero,\n        minimumValue: defaultMinimumValue,\n        maximumValue: defaultMaximumValue\n    }\n};\nlanguageOption.Spanish = languageOption.French; // Espaol (idem French)\nlanguageOption.Chinese = languageOption.Japanese; //  (Chinese)\n\n/**\n * UMD structure\n */\n(function (factory) {\n    //TODO This surely can be improved by letting webpack take care of generating this UMD part\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(1)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if ((typeof module === 'undefined' ? 'undefined' : _typeof(module)) === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n})(function ($) {\n    // Helper functions\n\n    /**\n     * Return TRUE if the `value` is null\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is null, FALSE otherwise\n     */\n    function isNull(value) {\n        return value === null;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined\n     *\n     * @static\n     * @param {*} value The value to test\n     * @returns {boolean} Return TRUE if the `value` is undefined, FALSE otherwise\n     */\n    function isUndefined(value) {\n        return value === void 0;\n    }\n\n    /**\n     * Return TRUE if the `value` is undefined, null or empty\n     *\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isUndefinedOrNullOrEmpty(value) {\n        return value === null || value === void 0 || '' === value;\n    }\n\n    /**\n     * Return TRUE if the given parameter is a String\n     *\n     * @param {*} str\n     * @returns {boolean}\n     */\n    function isString(str) {\n        return typeof str === 'string' || str instanceof String;\n    }\n\n    /**\n     * Return TRUE if the parameter is a boolean\n     *\n     * @static\n     * @param {*} value\n     * @returns {boolean}\n     */\n    function isBoolean(value) {\n        return typeof value === 'boolean';\n    }\n\n    /**\n     * Return TRUE if the parameter is a string 'true' or 'false'\n     *\n     * This function accepts any cases for those strings.\n     * @param {string} value\n     * @returns {boolean}\n     */\n    function isTrueOrFalseString(value) {\n        var lowercaseValue = String(value).toLowerCase();\n        return lowercaseValue === 'true' || lowercaseValue === 'false';\n    }\n\n    /**\n     * Return TRUE if the parameter is an object\n     *\n     * @param {*} reference\n     * @returns {boolean}\n     */\n    function isObject(reference) {\n        return (typeof reference === 'undefined' ? 'undefined' : _typeof(reference)) === 'object' && reference !== null && !Array.isArray(reference);\n    }\n\n    /**\n     * Return TRUE if the given object is empty\n     * cf. http://stackoverflow.com/questions/679915/how-do-i-test-for-an-empty-javascript-object and http://jsperf.com/empty-object-test\n     *\n     * @param {object} obj\n     * @returns {boolean}\n     */\n    function isEmptyObj(obj) {\n        for (var prop in obj) {\n            if (obj.hasOwnProperty(prop)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Return TRUE if the parameter is a number (or a number written as a string).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isNumber(n) {\n        return !isArray(n) && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    /**\n     * Return TRUE if the parameter is an integer (and not a float).\n     *\n     * @param {*} n\n     * @returns {boolean}\n     */\n    function isInt(n) {\n        return typeof n === 'number' && parseFloat(n) === parseInt(n, 10) && !isNaN(n);\n    }\n\n    /**\n     * Return the pasted text that will be used.\n     *\n     * @param {string} text\n     * @param {AutoNumericHolder} holder\n     * @returns {string|void|XML|*}\n     */\n    function preparePastedText(text, holder) {\n        return stripAllNonNumberCharacters(text, holder.settingsClone, true).replace(holder.settingsClone.decimalCharacter, '.');\n    }\n\n    /**\n     * Return TRUE is the string `str` contains the string `needle`\n     * Note: this function does not coerce the parameters types\n     *\n     * @param {string} str\n     * @param {string} needle\n     * @returns {boolean}\n     */\n    function contains(str, needle) {\n        if (!isString(str) || !isString(needle) || str === '' || needle === '') {\n            return false;\n        }\n\n        return str.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the `needle` is in the array\n     *\n     * @param {*} needle\n     * @param {Array} array\n     * @returns {boolean}\n     */\n    function isInArray(needle, array) {\n        if (!isArray(array) || array === [] || isUndefined(needle)) {\n            return false;\n        }\n\n        return array.indexOf(needle) !== -1;\n    }\n\n    /**\n     * Return TRUE if the parameter is an Array\n     *\n     * @param {*} arr\n     * @throws Error\n     * @returns {*|boolean}\n     */\n    function isArray(arr) {\n        if (Object.prototype.toString.call([]) === '[object Array]') {\n            // Make sure an array has a class attribute of [object Array]\n            // Test passed, now check if is an Array\n            return Array.isArray(arr) || (typeof arr === 'undefined' ? 'undefined' : _typeof(arr)) === 'object' && Object.prototype.toString.call(arr) === '[object Array]';\n        } else {\n            throw new Error('toString message changed for Object Array'); // Verify that the string returned by `toString` does not change in the future (cf. http://stackoverflow.com/a/8365215)\n        }\n    }\n\n    /**\n     * Return TRUE if the parameter is a string that represents a float number, and that number has a decimal part\n     *\n     * @param {string} str\n     * @returns {boolean}\n     */\n    // function hasDecimals(str) {\n    //     const [, decimalPart] = str.split('.');\n    //     return !isUndefined(decimalPart);\n    // }\n\n    /**\n     * Return the number of decimal places if the parameter is a string that represents a float number, and that number has a decimal part.\n     *\n     * @param {string} str\n     * @returns {int}\n     */\n    function decimalPlaces(str) {\n        var _str$split = str.split('.'),\n            _str$split2 = _slicedToArray(_str$split, 2),\n            decimalPart = _str$split2[1];\n\n        if (!isUndefined(decimalPart)) {\n            return decimalPart.length;\n        }\n\n        return 0;\n    }\n\n    /**\n     * Return the code for the key used to generate the given event.\n     *\n     * @param {Event} event\n     * @returns {string|Number}\n     */\n    function keyCodeNumber(event) {\n        // `event.keyCode` and `event.which` are deprecated, `KeyboardEvent.key` (https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key) must be used now\n        return typeof event.which === 'undefined' ? event.keyCode : event.which;\n    }\n\n    /**\n     * Return the character from the event key code.\n     * @example character(50) => '2'\n     *\n     * @param {Event} event\n     * @returns {string}\n     */\n    function character(event) {\n        if (typeof event.key === 'undefined' || event.key === 'Unidentified') {\n            return String.fromCharCode(keyCodeNumber(event));\n        } else {\n            return event.key;\n        }\n    }\n\n    /**\n     * Return TRUE if the given value (a number as a string) is within the range set in the settings `minimumValue` and `maximumValue`, FALSE otherwise.\n     *\n     * @param {string} value\n     * @param {object} parsedMinValue Parsed via the `parseStr()` function\n     * @param {object} parsedMaxValue Parsed via the `parseStr()` function\n     * @returns {boolean}\n     */\n    function checkIfInRange(value, parsedMinValue, parsedMaxValue) {\n        var parsedValue = parseStr(value);\n        return testMinMax(parsedMinValue, parsedValue) > -1 && testMinMax(parsedMaxValue, parsedValue) < 1;\n    }\n\n    /**\n     * Return TRUE if the given string contains a negative sign :\n     * - everywhere in the string (by default), or\n     * - on the first character only if the `checkEverywhere` parameter is set to `false`.\n     *\n     * @param {string} numericString A number represented by a string\n     * @param {boolean} checkEverywhere If TRUE, then the negative sign is search everywhere in the numeric string (this is needed for instance if the string is '1234.56-')\n     * @returns {boolean}\n     */\n    function isNegative(numericString) {\n        var checkEverywhere = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        //TODO Use the `negativeSignCharacter` from the settings here\n        if (checkEverywhere) {\n            return contains(numericString, '-');\n        }\n\n        return isNegativeStrict(numericString);\n    }\n\n    /**\n     * Return TRUE if the given string contains a negative sign on the first character (on the far left).\n     *\n     * @example isNegativeStrict('1234.56')     => false\n     * @example isNegativeStrict('1234.56-')    => false\n     * @example isNegativeStrict('-1234.56')    => true\n     * @example isNegativeStrict('-1,234.56 ') => true\n     *\n     * @param {string} numericString\n     * @returns {boolean}\n     */\n    function isNegativeStrict(numericString) {\n        //TODO Using the `negativeSignCharacter` from the settings here\n        return numericString.charAt(0) === '-';\n    }\n\n    /**\n     * Return TRUE if the formatted or unformatted numeric string represent the value 0 (ie. '0,00 '), or is empty (' ').\n     * This works since we test if there are any numbers from 1 to 9 in the string. If there is none, then the number is zero (or the string is empty).\n     *\n     * @param {string} numericString\n     * @returns {boolean}\n     */\n    function isZeroOrHasNoValue(numericString) {\n        return !/[1-9]/g.test(numericString);\n    }\n\n    /**\n     * Return the negative version of the value (represented as a string) given as a parameter.\n     *\n     * @param {string} value\n     * @returns {*}\n     */\n    function setRawNegativeSign(value) {\n        if (!isNegativeStrict(value)) {\n            return '-' + value;\n        }\n\n        return value;\n    }\n\n    /**\n     * Replace the character at the position `index` in the string `string` by the character(s) `newCharacter`.\n     *\n     * @param {string} string\n     * @param {int} index\n     * @param {string} newCharacter\n     * @returns {string}\n     */\n    function replaceCharAt(string, index, newCharacter) {\n        return '' + string.substr(0, index) + newCharacter + string.substr(index + newCharacter.length);\n    }\n\n    /**\n     * Return the value clamped to the nearest minimum/maximum value, as defined in the settings.\n     *\n     * @param {string|number} value\n     * @param {object} settings\n     * @returns {number}\n     */\n    function clampToRangeLimits(value, settings) {\n        //XXX This function always assume `settings.minimumValue` is lower than `settings.maximumValue`\n        return Math.max(settings.minimumValue, Math.min(settings.maximumValue, value));\n    }\n\n    /**\n     * Return the number of number or dot characters on the left side of the caret, in a formatted number.\n     *\n     * @param {string} formattedNumberString\n     * @param {int} caretPosition This must be a positive integer\n     * @param {string} decimalCharacter\n     * @returns {number}\n     */\n    function countNumberCharactersOnTheCaretLeftSide(formattedNumberString, caretPosition, decimalCharacter) {\n        // Here we count the dot and report it as a number character too, since it will 'stay' in the Javascript number when unformatted\n        var numberDotOrNegativeSign = new RegExp('[0-9' + decimalCharacter + '-]'); // No need to escape the decimal character here, since it's in `[]`\n\n        var numberDotAndNegativeSignCount = 0;\n        for (var i = 0; i < caretPosition; i++) {\n            // Test if the character is a number, a dot or an hyphen. If it is, count it, otherwise ignore it\n            if (numberDotOrNegativeSign.test(formattedNumberString[i])) {\n                numberDotAndNegativeSignCount++;\n            }\n        }\n\n        return numberDotAndNegativeSignCount;\n    }\n\n    /**\n     * Walk the `formattedNumberString` from left to right, one char by one, counting the `formattedNumberStringIndex`.\n     * If the char is in the `rawNumberString` (starting at index 0), then `rawNumberStringIndex++`, and continue until\n     * there is no more characters in `rawNumberString`) or that `rawNumberStringIndex === caretPositionInRawValue`.\n     * When you stop, the `formattedNumberStringIndex` is the position where the caret should be set.\n     *\n     * @example\n     * 1234567|89.01   : position 7 (rawNumberString)\n     * 123.456.7|89,01 : position 9 (formattedNumberString)\n     *\n     * @param {string} rawNumberString\n     * @param {int} caretPositionInRawValue\n     * @param {string} formattedNumberString\n     * @param {string} decimalCharacter\n     * @returns {*}\n     */\n    function findCaretPositionInFormattedNumber(rawNumberString, caretPositionInRawValue, formattedNumberString, decimalCharacter) {\n        var formattedNumberStringSize = formattedNumberString.length;\n        var rawNumberStringSize = rawNumberString.length;\n\n        var formattedNumberStringIndex = void 0;\n        var rawNumberStringIndex = 0;\n        for (formattedNumberStringIndex = 0; formattedNumberStringIndex < formattedNumberStringSize && rawNumberStringIndex < rawNumberStringSize && rawNumberStringIndex < caretPositionInRawValue; formattedNumberStringIndex++) {\n            if (rawNumberString[rawNumberStringIndex] === formattedNumberString[formattedNumberStringIndex] || rawNumberString[rawNumberStringIndex] === '.' && formattedNumberString[formattedNumberStringIndex] === decimalCharacter) {\n                rawNumberStringIndex++;\n            }\n        }\n\n        return formattedNumberStringIndex;\n    }\n\n    /**\n     * Count the number of occurrence of the given character, in the given text.\n     *\n     * @param {string} character\n     * @param {string} text\n     * @returns {number}\n     */\n    function countCharInText(character, text) {\n        var charCounter = 0;\n        for (var i = 0; i < text.length; i++) {\n            if (text[i] === character) {\n                charCounter++;\n            }\n        }\n\n        return charCounter;\n    }\n\n    /**\n     * Return the index that can be used to set the caret position.\n     * This takes into account that the position is starting at '0', not 1.\n     *\n     * @param {int} characterCount\n     * @returns {number}\n     */\n    function convertCharacterCountToIndexPosition(characterCount) {\n        return Math.max(characterCount, characterCount - 1);\n    }\n\n    /**\n     * Cross browser routine for getting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @returns {{}}\n     */\n    function getElementSelection(that) {\n        var position = {};\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var select = document.selection.createRange();\n            position.length = select.text.length;\n            select.moveStart('character', -that.value.length);\n            position.end = select.text.length;\n            position.start = position.end - position.length;\n        } else {\n            position.start = that.selectionStart;\n            position.end = that.selectionEnd;\n            position.length = position.end - position.start;\n        }\n\n        return position;\n    }\n\n    /**\n     * Cross browser routine for setting selected range/cursor position\n     *\n     * @param {HTMLElement|EventTarget} that\n     * @param {int} start\n     * @param {int|null} end\n     */\n    function setElementSelection(that, start) {\n        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        if (isUndefinedOrNullOrEmpty(end)) {\n            end = start;\n        }\n\n        if (isUndefined(that.selectionStart)) {\n            that.focus();\n            var range = that.createTextRange();\n            range.collapse(true);\n            range.moveEnd('character', end);\n            range.moveStart('character', start);\n            range.select();\n        } else {\n            that.selectionStart = start;\n            that.selectionEnd = end;\n        }\n    }\n\n    /**\n     * Function that throw error messages\n     *\n     * @param {string} message\n     */\n    function throwError(message) {\n        throw new Error(message);\n    }\n\n    /**\n     * Function that display a warning messages, according to the debug level.\n     *\n     * @param {string} message\n     * @param {boolean} showWarning If FALSE, then the warning message is not displayed\n     */\n    function warning(message) {\n        var showWarning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (showWarning) {\n            /* eslint no-console: 0 */\n            console.warn('Warning: ' + message);\n        }\n    }\n\n    // autoNumeric-specific functions\n\n    /**\n     * Run any callbacks found in the settings object.\n     * Any parameter could be a callback:\n     * - a function, which invoked with jQuery element, parameters and this parameter name and returns parameter value\n     * - a name of function, attached to $(selector).autoNumeric.functionName(){} - which was called previously\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     */\n    function runCallbacksFoundInTheSettingsObject($this, settings) {\n        // Loops through the settings object (option array) to find the following\n        $.each(settings, function (k, val) {\n            if (typeof val === 'function') {\n                settings[k] = val($this, settings, k);\n            } else if (typeof $this.autoNumeric[val] === 'function') {\n                // Calls the attached function from the html5 data example: data-a-sign=\"functionName\"\n                settings[k] = $this.autoNumeric[val]($this, settings, k);\n            }\n        });\n    }\n\n    /**\n     * Determine the maximum decimal length from the minimumValue and maximumValue settings\n     *\n     * @param {string} minimumValue\n     * @param {string} maximumValue\n     * @returns {number}\n     */\n    function maximumVMinAndVMaxDecimalLength(minimumValue, maximumValue) {\n        return Math.max(decimalPlaces(minimumValue), decimalPlaces(maximumValue));\n    }\n\n    /**\n     * Strip all unwanted non-number characters.\n     * This keeps the numbers, the negative sign as well as the custom decimal character.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} leftOrAll\n     * @returns {string|*}\n     */\n    function stripAllNonNumberCharacters(s, settings, leftOrAll) {\n        //TODO This function is called 10 times (sic!) on each key input, couldn't we lower that number? cf. issue #325\n        //TODO Refactor this with `convertToNumericString()` if possible?\n        if (settings.currencySymbol !== '') {\n            // Remove currency sign\n            s = s.replace(settings.currencySymbol, '');\n        }\n        if (settings.suffixText) {\n            // Remove suffix\n            while (contains(s, settings.suffixText)) {\n                s = s.replace(settings.suffixText, '');\n            }\n        }\n\n        // First replace anything before digits\n        s = s.replace(settings.skipFirstAutoStrip, '$1$2');\n\n        if ((settings.negativePositiveSignPlacement === 's' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement !== 'p') && isNegative(s) && s !== '') {\n            settings.trailingNegative = true;\n        }\n\n        // Then replace anything after digits\n        s = s.replace(settings.skipLastAutoStrip, '$1');\n\n        // Then remove any uninteresting characters\n        s = s.replace(settings.allowedAutoStrip, '');\n        if (settings.decimalCharacterAlternative) {\n            s = s.replace(settings.decimalCharacterAlternative, settings.decimalCharacter);\n        }\n\n        // Get only number string\n        var m = s.match(settings.numRegAutoStrip);\n        s = m ? [m[1], m[2], m[3]].join('') : '';\n\n        if (settings.leadingZero === 'allow' || settings.leadingZero === 'keep') {\n            var nSign = '';\n\n            var _s$split = s.split(settings.decimalCharacter),\n                _s$split2 = _slicedToArray(_s$split, 2),\n                integerPart = _s$split2[0],\n                decimalPart = _s$split2[1];\n\n            var modifiedIntegerPart = integerPart;\n            if (contains(modifiedIntegerPart, settings.negativeSignCharacter)) {\n                nSign = settings.negativeSignCharacter;\n                modifiedIntegerPart = modifiedIntegerPart.replace(settings.negativeSignCharacter, '');\n            }\n\n            // Strip leading zero on positive value if need\n            if (nSign === '' && modifiedIntegerPart.length > settings.mIntPos && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            // Strip leading zero on negative value if need\n            if (nSign !== '' && modifiedIntegerPart.length > settings.mIntNeg && modifiedIntegerPart.charAt(0) === '0') {\n                modifiedIntegerPart = modifiedIntegerPart.slice(1);\n            }\n\n            s = '' + nSign + modifiedIntegerPart + (isUndefined(decimalPart) ? '' : settings.decimalCharacter + decimalPart);\n        }\n\n        if (leftOrAll && settings.leadingZero === 'deny' || !settings.hasFocus && settings.leadingZero === 'allow') {\n            s = s.replace(settings.stripReg, '$1$2');\n        }\n\n        return s;\n    }\n\n    /**\n     * Sets or removes brackets on negative values, depending on the focus state.\n     * The focus state is 'stored' in the settings object under the `settings.hasFocus` attribute.\n     * //TODO Use another object to keep track of internal data that are not settings\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function toggleNegativeBracket(s, settings) {\n        if (settings.currencySymbolPlacement === 'p' && settings.negativePositiveSignPlacement === 'l' || settings.currencySymbolPlacement === 's' && settings.negativePositiveSignPlacement === 'p') {\n            //TODO Split the first and last bracket only once during the settings initialization\n            var _settings$negativeBra = settings.negativeBracketsTypeOnBlur.split(','),\n                _settings$negativeBra2 = _slicedToArray(_settings$negativeBra, 2),\n                firstBracket = _settings$negativeBra2[0],\n                lastBracket = _settings$negativeBra2[1];\n\n            if (!settings.hasFocus) {\n                // Add brackets\n                s = s.replace(settings.negativeSignCharacter, '');\n                s = firstBracket + s + lastBracket;\n            } else if (settings.hasFocus && s.charAt(0) === firstBracket) {\n                // Remove brackets\n                //TODO Quid if the negative sign is not on the left, shouldn't we replace the '-' sign at the right place?\n                s = s.replace(firstBracket, settings.negativeSignCharacter);\n                s = s.replace(lastBracket, '');\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Return a number as a numeric string that can be typecast to a Number that Javascript will understand.\n     *\n     * This function return the given string by stripping the currency sign (currencySymbol), the grouping separators (digitalGroupSpacing) and by replacing the decimal character (decimalCharacter) by a dot.\n     * Lastly, it also put the negative sign back to its normal position if needed.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string|void|XML|*}\n     */\n    function convertToNumericString(s, settings) {\n        // Remove the currency symbol\n        s = s.replace(settings.currencySymbol, '');\n\n        // Remove the grouping separators (thousands separators usually)\n        s = s.replace(settings.digitGroupSeparator, '');\n\n        // Replace the decimal character by a dot\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n\n        // Move the trailing negative sign to the right position, if any\n        if (isNegative(s) && s.lastIndexOf('-') === s.length - 1) {\n            s = s.replace('-', '');\n            s = '-' + s;\n        }\n\n        // Convert any arabic numbers to latin ones\n        var temp = arabicToLatinNumbers(s, true, false, false);\n        if (!isNaN(temp)) {\n            s = temp.toString();\n        }\n\n        return s;\n    }\n\n    /**\n     * Converts the ISO numeric string to the locale decimal and minus sign placement.\n     * See the \"outputFormat\" option definition for more details.\n     *\n     * @param {string|null} value\n     * @param {string} locale\n     * @returns {*}\n     */\n    function toLocale(value, locale) {\n        if (isNull(locale) || locale === 'string') {\n            return value;\n        }\n\n        var result = void 0;\n        switch (locale) {\n            case 'number':\n                result = Number(value);\n                break;\n            case '.-':\n                result = isNegative(value) ? value.replace('-', '') + '-' : value;\n                break;\n            case ',':\n            case '-,':\n                result = value.replace('.', ',');\n                break;\n            case ',-':\n                result = value.replace('.', ',');\n                result = isNegative(result) ? result.replace('-', '') + '-' : result;\n                break;\n            // The default case\n            case '.':\n            case '-.':\n                result = value;\n                break;\n            default:\n                throwError('The given outputFormat [' + locale + '] option is not recognized.');\n        }\n\n        return result;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character of the given string value to an hyphen (-) and a dot (.) in order to make that value 'typecastable' to a real number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForRawValue(s, settings) {\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace(settings.decimalCharacter, '.');\n        }\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace(settings.negativeSignCharacter, '-');\n        }\n        if (!s.match(/\\d/)) {\n            // The default value returned by `get` is not formatted with decimals\n            s += '0';\n        }\n\n        return s;\n    }\n\n    /**\n     * Modify the negative sign and the decimal character to use those defined in the settings.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {string}\n     */\n    function modifyNegativeSignAndDecimalCharacterForFormattedValue(s, settings) {\n        if (settings.negativeSignCharacter !== '-' && settings.negativeSignCharacter !== '') {\n            s = s.replace('-', settings.negativeSignCharacter);\n        }\n        if (settings.decimalCharacter !== '.') {\n            s = s.replace('.', settings.decimalCharacter);\n        }\n\n        return s;\n    }\n\n    /**\n     * Private function to check for empty value\n     * //TODO Modify this function so that it return either TRUE or FALSE if the value is empty. Then create another function to return the input value if it's not empty.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @param {boolean} signOnEmpty\n     * @returns {*}\n     */\n    function checkEmpty(inputValue, settings, signOnEmpty) {\n        if (inputValue === '' || inputValue === settings.negativeSignCharacter) {\n            if (settings.emptyInputBehavior === 'always' || signOnEmpty) {\n                return settings.negativePositiveSignPlacement === 'l' ? inputValue + settings.currencySymbol + settings.suffixText : settings.currencySymbol + inputValue + settings.suffixText;\n            }\n\n            return inputValue;\n        }\n\n        return null;\n    }\n\n    /**\n     * Modify the input value by adding the group separators, as defined in the settings.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function addGroupSeparators(inputValue, settings) {\n        if (settings.strip) {\n            inputValue = stripAllNonNumberCharacters(inputValue, settings, false);\n        }\n\n        //TODO This function `addGroupSeparators()` add group separators. Adding the negative sign as well is out of its scope. Move that to another function.\n        if (settings.trailingNegative && !isNegative(inputValue)) {\n            inputValue = '-' + inputValue;\n        }\n\n        var empty = checkEmpty(inputValue, settings, true);\n        var isValueNegative = isNegative(inputValue);\n        var isZero = isZeroOrHasNoValue(inputValue);\n        if (isValueNegative) {\n            inputValue = inputValue.replace('-', '');\n        }\n\n        if (!isNull(empty)) {\n            return empty;\n        }\n\n        settings.digitalGroupSpacing = settings.digitalGroupSpacing.toString();\n        var digitalGroup = void 0;\n        switch (settings.digitalGroupSpacing) {\n            case '2':\n                digitalGroup = /(\\d)((\\d)(\\d{2}?)+)$/;\n                break;\n            case '2s':\n                digitalGroup = /(\\d)((?:\\d{2}){0,2}\\d{3}(?:(?:\\d{2}){2}\\d{3})*?)$/;\n                break;\n            case '4':\n                digitalGroup = /(\\d)((\\d{4}?)+)$/;\n                break;\n            default:\n                digitalGroup = /(\\d)((\\d{3}?)+)$/;\n        }\n\n        // Splits the string at the decimal string\n\n        var _inputValue$split = inputValue.split(settings.decimalCharacter),\n            _inputValue$split2 = _slicedToArray(_inputValue$split, 2),\n            integerPart = _inputValue$split2[0],\n            decimalPart = _inputValue$split2[1];\n\n        if (settings.decimalCharacterAlternative && isUndefined(decimalPart)) {\n            var _inputValue$split3 = inputValue.split(settings.decimalCharacterAlternative);\n\n            var _inputValue$split4 = _slicedToArray(_inputValue$split3, 2);\n\n            integerPart = _inputValue$split4[0];\n            decimalPart = _inputValue$split4[1];\n        }\n\n        if (settings.digitGroupSeparator !== '') {\n            // Re-inserts the thousand separator via a regular expression\n            while (digitalGroup.test(integerPart)) {\n                integerPart = integerPart.replace(digitalGroup, '$1' + settings.digitGroupSeparator + '$2');\n            }\n        }\n\n        if (settings.decimalPlacesOverride !== 0 && !isUndefined(decimalPart)) {\n            if (decimalPart.length > settings.decimalPlacesOverride) {\n                decimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n            }\n\n            // Joins the whole number with the decimal value\n            inputValue = integerPart + settings.decimalCharacter + decimalPart;\n        } else {\n            // Otherwise if it's an integer\n            inputValue = integerPart;\n        }\n\n        settings.trailingNegative = false;\n\n        if (settings.currencySymbolPlacement === 'p') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.negativeSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.negativeSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'l':\n                        inputValue = '' + settings.positiveSignCharacter + settings.currencySymbol + inputValue;\n                        break;\n                    case 'r':\n                        inputValue = '' + settings.currencySymbol + settings.positiveSignCharacter + inputValue;\n                        break;\n                    case 's':\n                        inputValue = '' + settings.currencySymbol + inputValue + settings.positiveSignCharacter;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = settings.currencySymbol + inputValue;\n            }\n        }\n\n        if (settings.currencySymbolPlacement === 's') {\n            if (isValueNegative) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.negativeSignCharacter;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.negativeSignCharacter + settings.currencySymbol;\n                        settings.trailingNegative = true;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.negativeSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else if (settings.showPositiveSign && !isZero) {\n                switch (settings.negativePositiveSignPlacement) {\n                    case 'r':\n                        inputValue = '' + inputValue + settings.currencySymbol + settings.positiveSignCharacter;\n                        break;\n                    case 'l':\n                        inputValue = '' + inputValue + settings.positiveSignCharacter + settings.currencySymbol;\n                        break;\n                    case 'p':\n                        inputValue = '' + settings.positiveSignCharacter + inputValue + settings.currencySymbol;\n                        break;\n                    default:\n                    //\n                }\n            } else {\n                inputValue = inputValue + settings.currencySymbol;\n            }\n        }\n\n        // Removes the negative sign and places brackets\n        if (settings.negativeBracketsTypeOnBlur !== null && (settings.rawValue < 0 || isNegativeStrict(inputValue))) {\n            inputValue = toggleNegativeBracket(inputValue, settings);\n        }\n\n        return inputValue + settings.suffixText;\n    }\n\n    /**\n     * Truncate not needed zeros\n     *\n     * @param {string} roundedInputValue\n     * @param {int} temporaryDecimalPlacesOverride\n     * @returns {void|XML|string|*}\n     */\n    function truncateZeros(roundedInputValue, temporaryDecimalPlacesOverride) {\n        var regex = void 0;\n        switch (temporaryDecimalPlacesOverride) {\n            case 0:\n                // Prevents padding - removes trailing zeros until the first significant digit is encountered\n                regex = /(\\.(?:\\d*[1-9])?)0*$/;\n                break;\n            case 1:\n                // Allows padding when decimalPlacesOverride equals one - leaves one zero trailing the decimal character\n                regex = /(\\.\\d(?:\\d*[1-9])?)0*$/;\n                break;\n            default:\n                // Removes access zeros to the decimalPlacesOverride length when allowDecimalPadding is set to true\n                regex = new RegExp('(\\\\.\\\\d{' + temporaryDecimalPlacesOverride + '}(?:\\\\d*[1-9])?)0*');\n        }\n\n        // If there are no decimal places, we don't need a decimal point at the end\n        roundedInputValue = roundedInputValue.replace(regex, '$1');\n        if (temporaryDecimalPlacesOverride === 0) {\n            roundedInputValue = roundedInputValue.replace(/\\.$/, '');\n        }\n\n        return roundedInputValue;\n    }\n\n    /**\n     * Round the input value using the rounding method defined in the settings.\n     * This function accepts multiple rounding methods. See the documentation for more details about those.\n     *\n     * Note : This is handled as text since JavaScript math function can return inaccurate values.\n     *\n     * @param {string} inputValue\n     * @param {object} settings\n     * @returns {*}\n     */\n    function roundValue(inputValue, settings) {\n        inputValue = inputValue === '' ? '0' : inputValue.toString();\n        if (settings.roundingMethod === 'N05' || settings.roundingMethod === 'CHF' || settings.roundingMethod === 'U05' || settings.roundingMethod === 'D05') {\n            switch (settings.roundingMethod) {\n                case 'N05':\n                    inputValue = (Math.round(inputValue * 20) / 20).toString();\n                    break;\n                case 'U05':\n                    inputValue = (Math.ceil(inputValue * 20) / 20).toString();\n                    break;\n                default:\n                    inputValue = (Math.floor(inputValue * 20) / 20).toString();\n            }\n\n            var result = void 0;\n            if (!contains(inputValue, '.')) {\n                result = inputValue + '.00';\n            } else if (inputValue.length - inputValue.indexOf('.') < 3) {\n                result = inputValue + '0';\n            } else {\n                result = inputValue;\n            }\n            return result;\n        }\n\n        var ivRounded = '';\n        var i = 0;\n        var nSign = '';\n        var temporaryDecimalPlacesOverride = void 0;\n\n        // sets the truncate zero method\n        if (settings.allowDecimalPadding) {\n            temporaryDecimalPlacesOverride = settings.decimalPlacesOverride;\n        } else {\n            temporaryDecimalPlacesOverride = 0;\n        }\n\n        // Checks if the inputValue (input Value) is a negative value\n        if (isNegativeStrict(inputValue)) {\n            nSign = '-';\n\n            // Removes the negative sign that will be added back later if required\n            inputValue = inputValue.replace('-', '');\n        }\n\n        // Append a zero if the first character is not a digit (then it is likely to be a dot)\n        if (!inputValue.match(/^\\d/)) {\n            inputValue = '0' + inputValue;\n        }\n\n        // Determines if the value is equal to zero. If it is, remove the negative sign\n        if (Number(inputValue) === 0) {\n            nSign = '';\n        }\n\n        // Trims leading zero's as needed\n        if (Number(inputValue) > 0 && settings.leadingZero !== 'keep' || inputValue.length > 0 && settings.leadingZero === 'allow') {\n            inputValue = inputValue.replace(/^0*(\\d)/, '$1');\n        }\n\n        var dPos = inputValue.lastIndexOf('.');\n        var inputValueHasADot = dPos === -1;\n\n        // Virtual decimal position\n        var vdPos = inputValueHasADot ? inputValue.length - 1 : dPos;\n\n        // Checks decimal places to determine if rounding is required :\n        // Check if no rounding is required\n        var cDec = inputValue.length - 1 - vdPos;\n\n        if (cDec <= settings.decimalPlacesOverride) {\n            // Check if we need to pad with zeros\n            ivRounded = inputValue;\n            if (cDec < temporaryDecimalPlacesOverride) {\n                if (inputValueHasADot) {\n                    ivRounded += settings.decimalCharacter;\n                }\n\n                var zeros = '000000';\n                while (cDec < temporaryDecimalPlacesOverride) {\n                    zeros = zeros.substring(0, temporaryDecimalPlacesOverride - cDec);\n                    ivRounded += zeros;\n                    cDec += zeros.length;\n                }\n            } else if (cDec > temporaryDecimalPlacesOverride) {\n                ivRounded = truncateZeros(ivRounded, temporaryDecimalPlacesOverride);\n            } else if (cDec === 0 && temporaryDecimalPlacesOverride === 0) {\n                ivRounded = ivRounded.replace(/\\.$/, '');\n            }\n\n            return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n        }\n\n        // Rounded length of the string after rounding\n        var rLength = void 0;\n        if (inputValueHasADot) {\n            rLength = settings.decimalPlacesOverride - 1;\n        } else {\n            rLength = settings.decimalPlacesOverride + dPos;\n        }\n\n        var tRound = Number(inputValue.charAt(rLength + 1));\n        var odd = inputValue.charAt(rLength) === '.' ? inputValue.charAt(rLength - 1) % 2 : inputValue.charAt(rLength) % 2;\n        var ivArray = inputValue.substring(0, rLength + 1).split('');\n\n        if (tRound > 4 && settings.roundingMethod === 'S' || // Round half up symmetric\n        tRound > 4 && settings.roundingMethod === 'A' && nSign === '' || // Round half up asymmetric positive values\n        tRound > 5 && settings.roundingMethod === 'A' && nSign === '-' || // Round half up asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 's' || // Round half down symmetric\n        tRound > 5 && settings.roundingMethod === 'a' && nSign === '' || // Round half down asymmetric positive values\n        tRound > 4 && settings.roundingMethod === 'a' && nSign === '-' || // Round half down asymmetric negative values\n        tRound > 5 && settings.roundingMethod === 'B' || // Round half even \"Banker's Rounding\"\n        tRound === 5 && settings.roundingMethod === 'B' && odd === 1 || // Round half even \"Banker's Rounding\"\n        tRound > 0 && settings.roundingMethod === 'C' && nSign === '' || // Round to ceiling toward positive infinite\n        tRound > 0 && settings.roundingMethod === 'F' && nSign === '-' || // Round to floor toward negative infinite\n        tRound > 0 && settings.roundingMethod === 'U') {\n            // Round up away from zero\n            // Round up the last digit if required, and continue until no more 9's are found\n            for (i = ivArray.length - 1; i >= 0; i -= 1) {\n                if (ivArray[i] !== '.') {\n                    ivArray[i] = +ivArray[i] + 1;\n                    if (ivArray[i] < 10) {\n                        break;\n                    }\n\n                    if (i > 0) {\n                        ivArray[i] = '0';\n                    }\n                }\n            }\n        }\n\n        // Reconstruct the string, converting any 10's to 0's\n        ivArray = ivArray.slice(0, rLength + 1);\n\n        // Return the rounded value\n        ivRounded = truncateZeros(ivArray.join(''), temporaryDecimalPlacesOverride);\n\n        return Number(ivRounded) === 0 ? ivRounded : nSign + ivRounded;\n    }\n\n    /**\n     * Truncates the decimal part of a number.\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @param {boolean} isPaste\n     * @returns {*}\n     */\n    function truncateDecimal(s, settings, isPaste) {\n        s = isPaste ? roundValue(s, settings) : s;\n\n        if (settings.decimalCharacter && settings.decimalPlacesOverride) {\n            var _s$split3 = s.split(settings.decimalCharacter),\n                _s$split4 = _slicedToArray(_s$split3, 2),\n                integerPart = _s$split4[0],\n                decimalPart = _s$split4[1];\n\n            // truncate decimal part to satisfying length since we would round it anyway\n\n\n            if (decimalPart && decimalPart.length > settings.decimalPlacesOverride) {\n                if (settings.decimalPlacesOverride > 0) {\n                    var modifiedDecimalPart = decimalPart.substring(0, settings.decimalPlacesOverride);\n                    s = '' + integerPart + settings.decimalCharacter + modifiedDecimalPart;\n                } else {\n                    s = integerPart;\n                }\n            }\n        }\n\n        return s;\n    }\n\n    /**\n     * Function to parse minimumValue, maximumValue & the input value to prepare for testing to determine if the value falls within the min / max range.\n     * Return an object example: minimumValue: \"999999999999999.99\" returns the following \"{s: -1, e: 12, c: Array[15]}\".\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {number|string} n A numeric value.\n     * @returns {{}}\n     */\n    function parseStr(n) {\n        var x = {}; // A Big number instance.\n        var e = void 0;\n        var i = void 0;\n        var nL = void 0;\n        var j = void 0;\n\n        // Minus zero?\n        if (n === 0 && 1 / n < 0) {\n            n = '-0';\n        }\n\n        // Determine sign. 1 positive, -1 negative\n        n = n.toString();\n        if (isNegativeStrict(n)) {\n            n = n.slice(1);\n            x.s = -1;\n        } else {\n            x.s = 1;\n        }\n\n        // Decimal point?\n        e = n.indexOf('.');\n        if (e > -1) {\n            n = n.replace('.', '');\n        }\n\n        // length of string if no decimal character\n        if (e < 0) {\n            // Integer\n            e = n.length;\n        }\n\n        // Determine leading zeros\n        i = n.search(/[1-9]/i) === -1 ? n.length : n.search(/[1-9]/i);\n        nL = n.length;\n        if (i === nL) {\n            // Zero\n            x.e = 0;\n            x.c = [0];\n        } else {\n            // Determine trailing zeros\n            for (j = nL - 1; n.charAt(j) === '0'; j -= 1) {\n                nL -= 1;\n            }\n            nL -= 1;\n\n            // Decimal location\n            x.e = e - i - 1;\n            x.c = [];\n\n            // Convert string to array of digits without leading/trailing zeros\n            for (e = 0; i <= nL; i += 1) {\n                x.c[e] = +n.charAt(i);\n                e += 1;\n            }\n        }\n\n        return x;\n    }\n\n    /**\n     * Function to test if the input value falls with the Min / Max settings.\n     * This uses the parsed strings for the above parseStr function.\n     *\n     * This function is adapted from Big.js https://github.com/MikeMcl/big.js/. Many thanks to Mike.\n     *\n     * @param {object} y Big number instance\n     * @param {object} x Big number instance\n     * @returns {*}\n     */\n    function testMinMax(y, x) {\n        var xc = x.c;\n        var yc = y.c;\n        var i = x.s;\n        var j = y.s;\n        var k = x.e;\n        var l = y.e;\n\n        // Either zero?\n        if (!xc[0] || !yc[0]) {\n            var _result = void 0;\n            if (!xc[0]) {\n                _result = !yc[0] ? 0 : -j;\n            } else {\n                _result = i;\n            }\n            return _result;\n        }\n\n        // Signs differ?\n        if (i !== j) {\n            return i;\n        }\n        var xNeg = i < 0;\n\n        // Compare exponents\n        if (k !== l) {\n            return k > l ^ xNeg ? 1 : -1;\n        }\n        i = -1;\n        k = xc.length;\n        l = yc.length;\n        j = k < l ? k : l;\n\n        // Compare digit by digit\n        for (i += 1; i < j; i += 1) {\n            if (xc[i] !== yc[i]) {\n                return xc[i] > yc[i] ^ xNeg ? 1 : -1;\n            }\n        }\n\n        // Compare lengths\n        var result = void 0;\n        if (k === l) {\n            result = 0;\n        } else {\n            result = k > l ^ xNeg ? 1 : -1;\n        }\n\n        return result;\n    }\n\n    /**\n     * Check that the number satisfy the format conditions\n     * and lays between settings.minimumValue and settings.maximumValue\n     * and the string length does not exceed the digits in settings.minimumValue and settings.maximumValue\n     *\n     * @param {string} s\n     * @param {object} settings\n     * @returns {*}\n     */\n    function checkIfInRangeWithOverrideOption(s, settings) {\n        s = s.toString();\n        s = s.replace(',', '.');\n        var minParse = parseStr(settings.minimumValue);\n        var maxParse = parseStr(settings.maximumValue);\n        var valParse = parseStr(s);\n\n        var result = void 0;\n        switch (settings.overrideMinMaxLimits) {\n            case 'floor':\n                result = [testMinMax(minParse, valParse) > -1, true];\n                break;\n            case 'ceiling':\n                result = [true, testMinMax(maxParse, valParse) < 1];\n                break;\n            case 'ignore':\n                result = [true, true];\n                break;\n            default:\n                result = [testMinMax(minParse, valParse) > -1, testMinMax(maxParse, valParse) < 1];\n        }\n\n        return result;\n    }\n\n    /**\n     * Thanks to Anthony & Evan C\n     *\n     * @param {Element|string} element\n     * @returns {*|jQuery|HTMLElement}\n     */\n    function getCurrentElement(element) {\n        /*\n         * If the parameter is a string (and therefore is a CSS selector), then we need to modify this string in order\n         * for jQuery to be able to parse the selector correctly.\n         * cf. http://learn.jquery.com/using-jquery-core/faq/how-do-i-select-an-element-by-an-id-that-has-characters-used-in-css-notation/\n         */\n        if (isString(element)) {\n            //TODO This block is apparently never entered. We should remove it after making sure that's 100% the case\n            element = '#' + element.replace(/(:|\\.|\\[|]|,|=)/g, '\\\\$1');\n        }\n\n        return $(element);\n    }\n\n    /**\n     * Function that attach the autoNumeric field properties to the DOM element via an AutoNumericHolder object.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {object} settings\n     * @param {boolean} update\n     * @returns {*}\n     */\n    function getAutoNumericHolder($this, settings) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        var data = $this.data('autoNumeric');\n        if (!data) {\n            data = {};\n            $this.data('autoNumeric', data);\n        }\n\n        var holder = data.holder;\n        if (update || isUndefined(holder) && settings) {\n            holder = new AutoNumericHolder($this.get(0), settings);\n            data.holder = holder;\n        }\n\n        return holder;\n    }\n\n    /**\n     * Original settings saved for use when decimalPlacesShownOnFocus & noSeparatorOnFocus options are being used.\n     * Those original settings are used exclusively in the `focusin` and `focusout` event handlers.\n     *\n     * @param {object} settings\n     */\n    function keepAnOriginalSettingsCopy(settings) {\n        //TODO Rename the old option names to the new ones\n        settings.oDec = settings.decimalPlacesOverride;\n        settings.oPad = settings.allowDecimalPadding;\n        settings.oBracket = settings.negativeBracketsTypeOnBlur;\n        settings.oSep = settings.digitGroupSeparator;\n        settings.oSign = settings.currencySymbol;\n        settings.oSuffix = settings.suffixText;\n    }\n\n    /**\n     * Original settings saved for use when `decimalPlacesShownOnFocus` & `noSeparatorOnFocus` options are being used.\n     * This is taken from Quirksmode.\n     *\n     * @param {string} name\n     * @returns {*}\n     */\n    function readCookie(name) {\n        var nameEQ = name + '=';\n        var ca = document.cookie.split(';');\n        var c = '';\n        for (var i = 0; i < ca.length; i += 1) {\n            c = ca[i];\n            while (c.charAt(0) === ' ') {\n                c = c.substring(1, c.length);\n            }\n            if (c.indexOf(nameEQ) === 0) {\n                return c.substring(nameEQ.length, c.length);\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Test if sessionStorage is supported.\n     * This is taken from Modernizr.\n     *\n     * @returns {boolean}\n     */\n    function storageTest() {\n        var mod = 'modernizr';\n        try {\n            sessionStorage.setItem(mod, mod);\n            sessionStorage.removeItem(mod);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * properly formats the string to a numeric when leadingZero does not 'keep'.\n     *\n     * @param {string} value\n     * @param {object} settings\n     * @returns {string}\n     */\n    function cleanLeadingTrailingZeros(value, settings) {\n        // Return the empty string is the value is already empty. This prevent converting that value to '0'.\n        if (value === '') {\n            return '';\n        }\n\n        // Return '0' if the value is zero\n        if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n            return '0';\n        }\n\n        if (settings.leadingZero !== 'keep') {\n            // Trim leading zero's - leaves one zero to the left of the decimal point\n            value = value.replace(/^(-)?0+(?=\\d)/g, '$1');\n\n            //TODO remove this from that function and use `trimPaddedZerosFromDecimalPlaces()` instead. Also create a new `trailingZero` option.\n            if (contains(value, '.')) {\n                // Trims trailing zeros after the decimal point\n                value = value.replace(/(\\.[0-9]*?)0+$/, '$1');\n            }\n        }\n        // Strips trailing decimal point\n        value = value.replace(/\\.$/, '');\n\n        return value;\n    }\n\n    /**\n     * Remove the trailing zeros in the decimal part of a number.\n     *\n     * @param {string} numericString\n     * @returns {*}\n     */\n    function trimPaddedZerosFromDecimalPlaces(numericString) {\n        var _numericString$split = numericString.split('.'),\n            _numericString$split2 = _slicedToArray(_numericString$split, 2),\n            integerPart = _numericString$split2[0],\n            decimalPart = _numericString$split2[1];\n\n        if (isUndefinedOrNullOrEmpty(decimalPart)) {\n            return integerPart;\n        }\n\n        var trimmedDecimalPart = decimalPart.replace(/0+$/g, '');\n\n        var result = void 0;\n        if (trimmedDecimalPart === '') {\n            result = integerPart;\n        } else {\n            result = integerPart + '.' + trimmedDecimalPart;\n        }\n\n        return result;\n    }\n\n    /**\n     * Creates or removes sessionStorage or cookie depending on what the browser is supporting.\n     *\n     * @param {Element|EventTarget} element\n     * @param {object} settings\n     * @param {string} action\n     * @returns {*}\n     */\n    function saveValueToPersistentStorage(element, settings, action) {\n        if (settings.saveValueToSessionStorage) {\n            var storedName = element.name !== '' && !isUndefined(element.name) ? 'AUTO_' + decodeURIComponent(element.name) : 'AUTO_' + element.id;\n            var date = void 0;\n            var expires = void 0;\n\n            // Sets cookie for browser that do not support sessionStorage IE 6 & IE 7\n            if (storageTest() === false) {\n                switch (action) {\n                    case 'set':\n                        document.cookie = storedName + '=' + settings.rawValue + '; expires= ; path=/';\n                        break;\n                    case 'wipe':\n                        date = new Date();\n                        date.setTime(date.getTime() + -1 * 24 * 60 * 60 * 1000);\n                        expires = '; expires=' + date.toUTCString(); // Note : `toGMTString()` has been deprecated (cf. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toGMTString)\n                        document.cookie = storedName + '=\\'\\' ;' + expires + '; path=/';\n                        break;\n                    case 'get':\n                        return readCookie(storedName);\n                }\n            } else {\n                switch (action) {\n                    case 'set':\n                        sessionStorage.setItem(storedName, settings.rawValue);\n                        break;\n                    case 'wipe':\n                        sessionStorage.removeItem(storedName);\n                        break;\n                    case 'get':\n                        return sessionStorage.getItem(storedName);\n                }\n            }\n        }\n    }\n\n    /**\n     * Holder object for field properties\n     */\n\n    var AutoNumericHolder = function () {\n        /**\n         * Class constructor\n         *\n         * @param {HTMLElement} that - A reference to the current DOM element\n         * @param {object} settings\n         */\n        function AutoNumericHolder(that, settings) {\n            _classCallCheck(this, AutoNumericHolder);\n\n            this.settings = settings;\n            this.that = that;\n            this.$that = $(that);\n            this.formatted = false;\n            this.settingsClone = settings;\n            this.value = that.value;\n        }\n\n        /**\n         * Update the value and the selection values inside the AutoNumericHolder object.\n         * This keeps tracks of the input value, as well as the current selection.\n         * This also resets the 'processed' and 'formatted' state.\n         *\n         * Note : Those two can change between the keydown, keypress and keyup events, that's why\n         *        this function is called on each event handler.\n         *\n         * @private\n         */\n\n\n        _createClass(AutoNumericHolder, [{\n            key: '_updateAutoNumericHolderProperties',\n            value: function _updateAutoNumericHolderProperties() {\n                this.value = this.that.value;\n                this.selection = getElementSelection(this.that);\n                this.processed = false;\n                this.formatted = false;\n            }\n\n            /**\n             * Update the keycode of the key that triggered the given event.\n             * Note : e.which is sometimes different than e.keyCode during the keypress event, when entering a printable character key (ie. 't'). `e.which` equals 0 for non-printable characters.\n             *\n             * //TODO Switch to the non-deprecated e.key attribute, instead of inconsistant e.which and e.keyCode.\n             * e.key describe the key name used to trigger the event.\n             * e.keyCode being deprecated : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode\n             * How e.key works : https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key\n             * The key list is described here\n             * @link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values\n             *\n             * @param {Event} e\n             * @private\n             */\n\n        }, {\n            key: '_updateAutoNumericHolderEventKeycode',\n            value: function _updateAutoNumericHolderEventKeycode(e) {\n                // Note: the keypress event overwrites meaningful value of e.keyCode, hence we do not update that value on 'keypress'\n                this.eventKeyCode = keyCodeNumber(e);\n            }\n\n            /**\n             * Set the text selection inside the input with the given start and end position.\n             *\n             * @param {int} start\n             * @param {int} end\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_setSelection',\n            value: function _setSelection(start, end, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                start = Math.max(start, 0);\n                end = Math.min(end, this.that.value.length); //TODO Replace `this.that.value.length` with `this.value.length`\n                this.selection = {\n                    start: start,\n                    end: end,\n                    length: end - start\n                };\n\n                if (isUndefined(setReal) || setReal) {\n                    setElementSelection(this.that, start, end);\n                }\n            }\n\n            /**\n             * Set the caret position inside the input at the given position.\n             *\n             * @param {int} pos\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_setCaretPosition',\n            value: function _setCaretPosition(pos, setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean)\n                this._setSelection(pos, pos, setReal);\n            }\n\n            /**\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\n             * Those parts are left 'untouched', ie. formatted by autoNumeric.\n             *\n             * @returns {[string, string]} The parts on the left and right of the caret or selection\n             * @private\n             */\n\n        }, {\n            key: '_getLeftAndRightPartAroundTheSelection',\n            value: function _getLeftAndRightPartAroundTheSelection() {\n                var value = this.value;\n                var left = value.substring(0, this.selection.start);\n                var right = value.substring(this.selection.end, value.length);\n\n                return [left, right];\n            }\n\n            /**\n             * Return an array containing the string parts located on the left and right side of the caret or selection.\n             * Those parts are unformatted (stripped) of any non-numbers characters.\n             *\n             * @returns {[string, string]} The parts on the left and right of the caret or selection, unformatted.\n             * @private\n             */\n\n        }, {\n            key: '_getUnformattedLeftAndRightPartAroundTheSelection',\n            value: function _getUnformattedLeftAndRightPartAroundTheSelection() {\n                var settingsClone = this.settingsClone;\n\n                var _getLeftAndRightPartA = this._getLeftAndRightPartAroundTheSelection(),\n                    _getLeftAndRightPartA2 = _slicedToArray(_getLeftAndRightPartA, 2),\n                    left = _getLeftAndRightPartA2[0],\n                    right = _getLeftAndRightPartA2[1];\n\n                if (left === '' && right === '') {\n                    settingsClone.trailingNegative = false;\n                }\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, this.settingsClone, stripZeros);\n                right = stripAllNonNumberCharacters(right, this.settingsClone, false);\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    right = right === '-' ? '' : right;\n                    settingsClone.trailingNegative = false;\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Strip parts from excess characters and leading zeros.\n             *\n             * @param {string} left\n             * @param {string} right\n             * @returns {[*,*]}\n             * @private\n             */\n\n        }, {\n            key: '_normalizeParts',\n            value: function _normalizeParts(left, right) {\n                var settingsClone = this.settingsClone;\n\n                // if changing the sign and left is equal to the number zero - prevents stripping the leading zeros\n                var stripZeros = true;\n                if (this.eventKeyCode === keyCode.Hyphen && Number(left) === 0) {\n                    stripZeros = false;\n                }\n                left = stripAllNonNumberCharacters(left, settingsClone, stripZeros);\n\n                // If right is not empty and first character is not decimalCharacter\n                right = stripAllNonNumberCharacters(right, settingsClone, false);\n\n                // Prevents multiple leading zeros from being entered\n                if (settingsClone.leadingZero === 'deny' && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0) && Number(left) === 0 && !contains(left, settingsClone.decimalCharacter) && right !== '') {\n                    left = left.substring(0, left.length - 1);\n                }\n\n                if (settingsClone.trailingNegative && !isNegative(left)) {\n                    left = '-' + left;\n                    settingsClone.trailingNegative = false;\n                }\n\n                // Insert zero if has leading dot\n                this.newValue = left + right;\n                if (settingsClone.decimalCharacter) {\n                    var m = this.newValue.match(new RegExp('^' + settingsClone.aNegRegAutoStrip + '\\\\' + settingsClone.decimalCharacter));\n                    if (m) {\n                        left = left.replace(m[1], m[1] + '0');\n                        this.newValue = left + right;\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Set part of number to value while keeping the cursor position. //TODO What about the cursor selection?\n             *\n             * @param {string} left\n             * @param {string} right\n             * @param {boolean} isPaste\n             * @returns {boolean}\n             * @private\n             */\n\n        }, {\n            key: '_setValueParts',\n            value: function _setValueParts(left, right) {\n                var isPaste = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n                var settingsClone = this.settingsClone;\n                var parts = this._normalizeParts(left, right);\n\n                var _checkIfInRangeWithOv = checkIfInRangeWithOverrideOption(this.newValue, settingsClone),\n                    _checkIfInRangeWithOv2 = _slicedToArray(_checkIfInRangeWithOv, 2),\n                    minTest = _checkIfInRangeWithOv2[0],\n                    maxTest = _checkIfInRangeWithOv2[1];\n\n                var position = parts[0].length;\n                this.newValue = parts.join('');\n\n                if (minTest && maxTest) {\n                    this.newValue = truncateDecimal(this.newValue, settingsClone, isPaste);\n                    //TODO Check if we need to replace the hard-coded ',' with settings.decimalCharacter\n                    var testValue = contains(this.newValue, ',') ? this.newValue.replace(',', '.') : this.newValue;\n                    if (testValue === '' || testValue === settingsClone.negativeSignCharacter) {\n                        settingsClone.rawValue = settingsClone.emptyInputBehavior === 'zero' ? '0' : '';\n                    } else {\n                        settingsClone.rawValue = cleanLeadingTrailingZeros(testValue, settingsClone);\n                    }\n\n                    if (position > this.newValue.length) {\n                        position = this.newValue.length;\n                    }\n\n                    // Make sure when the user enter a '0' on the far left with a leading zero option set to 'deny', that the caret does not moves since the input is dropped (fix issue #283)\n                    if (position === 1 && parts[0] === '0' && settingsClone.leadingZero === 'deny') {\n                        // If the user enter `0`, then the caret is put on the right side of it (Fix issue #299)\n                        if (parts[1] === '' || parts[0] === '0' && parts[1] !== '') {\n                            position = 1;\n                        } else {\n                            position = 0;\n                        }\n                    }\n\n                    this.value = this.newValue;\n                    this._setCaretPosition(position, false);\n\n                    return true;\n                }\n\n                if (!minTest) {\n                    this.$that.trigger('autoNumeric:minExceeded');\n                } else if (!maxTest) {\n                    this.$that.trigger('autoNumeric:maxExceeded');\n                }\n\n                return false;\n            }\n\n            /**\n             * Helper function for `_expandSelectionOnSign()`.\n             *\n             * @returns {*} Sign position of a formatted value\n             * @private\n             */\n\n        }, {\n            key: '_getSignPosition',\n            value: function _getSignPosition() {\n                var settingsClone = this.settingsClone;\n                var currencySymbol = settingsClone.currencySymbol;\n                var that = this.that;\n\n                if (currencySymbol) {\n                    var currencySymbolLen = currencySymbol.length;\n                    if (settingsClone.currencySymbolPlacement === 'p') {\n                        var hasNeg = settingsClone.negativeSignCharacter && that.value && that.value.charAt(0) === settingsClone.negativeSignCharacter;\n                        return hasNeg ? [1, currencySymbolLen + 1] : [0, currencySymbolLen];\n                    }\n                    var valueLen = that.value.length;\n                    return [valueLen - currencySymbolLen, valueLen];\n                }\n\n                return [1000, -1];\n            }\n\n            /**\n             * Expands selection to cover whole sign\n             * Prevents partial deletion/copying/overwriting of a sign\n             *\n             * @param {undefined|boolean} setReal\n             * @private\n             */\n\n        }, {\n            key: '_expandSelectionOnSign',\n            value: function _expandSelectionOnSign(setReal) {\n                //TODO Modify setReal to be more explicit (and a boolean only)\n                //TODO Use array destructuring here to set signPosition to more explicit variables\n                var signPosition = this._getSignPosition();\n                var selection = this.selection;\n\n                // If selection catches something except sign and catches only space from sign\n                if (selection.start < signPosition[1] && selection.end > signPosition[0]) {\n                    // Then select without empty space\n                    if ((selection.start < signPosition[0] || selection.end > signPosition[1]) && this.value.substring(Math.max(selection.start, signPosition[0]), Math.min(selection.end, signPosition[1])).match(/^\\s*$/)) {\n                        if (selection.start < signPosition[0]) {\n                            this._setSelection(selection.start, signPosition[0], setReal);\n                        } else {\n                            this._setSelection(signPosition[1], selection.end, setReal);\n                        }\n                    } else {\n                        // Else select with whole sign\n                        this._setSelection(Math.min(selection.start, signPosition[0]), Math.max(selection.end, signPosition[1]), setReal);\n                    }\n                }\n            }\n\n            /**\n             * Try to strip pasted value to digits\n             */\n\n        }, {\n            key: '_checkPaste',\n            value: function _checkPaste() {\n                if (!isUndefined(this.valuePartsBeforePaste)) {\n                    var oldParts = this.valuePartsBeforePaste;\n\n                    var _getLeftAndRightPartA3 = this._getLeftAndRightPartAroundTheSelection(),\n                        _getLeftAndRightPartA4 = _slicedToArray(_getLeftAndRightPartA3, 2),\n                        left = _getLeftAndRightPartA4[0],\n                        right = _getLeftAndRightPartA4[1];\n\n                    // Try to strip the pasted value first\n\n\n                    delete this.valuePartsBeforePaste;\n\n                    var modifiedLeftPart = left.substr(0, oldParts[0].length) + stripAllNonNumberCharacters(left.substr(oldParts[0].length), this.settingsClone, true);\n                    if (!this._setValueParts(modifiedLeftPart, right, true)) {\n                        this.value = oldParts.join('');\n                        this._setCaretPosition(oldParts[0].length, false);\n                    }\n                }\n            }\n\n            /**\n             * Process pasting, cursor moving and skipping of not interesting keys.\n             * If this function returns TRUE, then further processing is not performed.\n             *\n             * @param {Event} e\n             * @returns {boolean}\n             * @private\n             */\n\n        }, {\n            key: '_skipAlways',\n            value: function _skipAlways(e) {\n                // Catch the ctrl up on ctrl-v\n                if ((e.ctrlKey || e.metaKey) && e.type === 'keyup' && !isUndefined(this.valuePartsBeforePaste) || e.shiftKey && this.eventKeyCode === keyCode.Insert) {\n                    //TODO Move this test inside the `onKeyup` handler\n                    this._checkPaste();\n                    return false;\n                }\n\n                // Skip all function keys (F1-F12), Windows keys, tab and other special keys\n                if (this.eventKeyCode >= keyCode.F1 && this.eventKeyCode <= keyCode.F12 || this.eventKeyCode >= keyCode.Windows && this.eventKeyCode <= keyCode.RightClick || this.eventKeyCode >= keyCode.Tab && this.eventKeyCode < keyCode.Space ||\n                // `e.which` is sometimes different than `this.eventKeyCode` during the keypress event when entering a printable character key (ie. 't'). Also, `e.which` equals 0 for non-printable characters.\n                this.eventKeyCode < keyCode.Backspace && (e.which === 0 || e.which === this.eventKeyCode) || this.eventKeyCode === keyCode.NumLock || this.eventKeyCode === keyCode.ScrollLock || this.eventKeyCode === keyCode.Insert || this.eventKeyCode === keyCode.Command) {\n                    return true;\n                }\n\n                // If a \"Select all\" keyboard shortcut is detected (ctrl + a)\n                if ((e.ctrlKey || e.metaKey) && this.eventKeyCode === keyCode.a) {\n                    if (this.settings.selectNumberOnly) {\n                        // `preventDefault()` is used here to prevent the browser to first select all the input text (including the currency sign), otherwise we would see that whole selection first in a flash, then the selection with only the number part without the currency sign.\n                        e.preventDefault();\n                        var valueLen = this.that.value.length;\n                        var currencySymbolLen = this.settings.currencySymbol.length;\n                        var negLen = !isNegative(this.that.value) ? 0 : 1;\n                        var suffixTextLen = this.settings.suffixText.length;\n                        var currencySymbolPlacement = this.settings.currencySymbolPlacement;\n                        var negativePositiveSignPlacement = this.settings.negativePositiveSignPlacement;\n\n                        var start = void 0;\n                        if (currencySymbolPlacement === 's') {\n                            start = 0;\n                        } else {\n                            start = negativePositiveSignPlacement === 'l' && negLen === 1 && currencySymbolLen > 0 ? currencySymbolLen + 1 : currencySymbolLen;\n                        }\n\n                        var end = void 0;\n                        if (currencySymbolPlacement === 'p') {\n                            end = valueLen - suffixTextLen;\n                        } else {\n                            switch (negativePositiveSignPlacement) {\n                                case 'l':\n                                    end = valueLen - (suffixTextLen + currencySymbolLen);\n                                    break;\n                                case 'r':\n                                    end = currencySymbolLen > 0 ? valueLen - (currencySymbolLen + negLen + suffixTextLen) : valueLen - (currencySymbolLen + suffixTextLen);\n                                    break;\n                                default:\n                                    end = valueLen - (currencySymbolLen + suffixTextLen);\n                            }\n                        }\n\n                        setElementSelection(this.that, start, end);\n                    }\n\n                    return true;\n                }\n\n                // If a \"Copy\", \"Paste\" or \"Cut\" keyboard shortcut is detected (respectively 'ctrl + c', 'ctrl + v' or 'ctrl + x')\n                if ((e.ctrlKey || e.metaKey) && (this.eventKeyCode === keyCode.c || this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.x)) {\n                    if (e.type === 'keydown') {\n                        this._expandSelectionOnSign();\n                    }\n\n                    // Try to prevent wrong paste\n                    if (this.eventKeyCode === keyCode.v || this.eventKeyCode === keyCode.Insert) {\n                        if (e.type === 'keydown' || e.type === 'keypress') {\n                            if (isUndefined(this.valuePartsBeforePaste)) {\n                                this.valuePartsBeforePaste = this._getLeftAndRightPartAroundTheSelection();\n                            }\n                        } else {\n                            this._checkPaste();\n                        }\n                    }\n\n                    return e.type === 'keydown' || e.type === 'keypress' || this.eventKeyCode === keyCode.c;\n                }\n\n                if (e.ctrlKey || e.metaKey) {\n                    return true;\n                }\n\n                // Jump over thousand separator\n                //TODO Move this test inside the `onKeydown` handler\n                if (this.eventKeyCode === keyCode.LeftArrow || this.eventKeyCode === keyCode.RightArrow) {\n                    if (e.type === 'keydown' && !e.shiftKey) {\n                        if (this.eventKeyCode === keyCode.LeftArrow && (this.that.value.charAt(this.selection.start - 2) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start - 2) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start - 1);\n                        } else if (this.eventKeyCode === keyCode.RightArrow && (this.that.value.charAt(this.selection.start + 1) === this.settingsClone.digitGroupSeparator || this.that.value.charAt(this.selection.start + 1) === this.settingsClone.decimalCharacter)) {\n                            this._setCaretPosition(this.selection.start + 1);\n                        }\n                    }\n                    return true;\n                }\n\n                return this.eventKeyCode >= keyCode.PageDown && this.eventKeyCode <= keyCode.DownArrow;\n            }\n\n            /**\n             * Process deletion of characters when the minus sign is to the right of the numeric characters.\n             *\n             * @param {string} left The part on the left of the caret or selection\n             * @param {string} right The part on the right of the caret or selection\n             * @returns {[string, string]}\n             * @private\n             */\n\n        }, {\n            key: '_processCharacterDeletionIfTrailingNegativeSign',\n            value: function _processCharacterDeletionIfTrailingNegativeSign(_ref) {\n                var _ref2 = _slicedToArray(_ref, 2),\n                    left = _ref2[0],\n                    right = _ref2[1];\n\n                var settingsClone = this.settingsClone;\n                if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.value.charAt(this.selection.start - 1) === '-') {\n                            left = left.substring(1);\n                        } else if (this.selection.start <= this.value.length - settingsClone.suffixText.length) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.suffixText) && settingsClone.suffixText !== '';\n                        if (this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) + settingsClone.currencySymbol.length) {\n                            right = right.substring(1, right.length);\n                        }\n                        if (isNegative(left) && this.value.charAt(this.selection.start) === '-') {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                //TODO Merge the two following 'if' blocks into one `if (settingsClone.currencySymbolPlacement === 's') {` and a switch on settingsClone.negativePositiveSignPlacement\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && (this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) || !contains(this.value, settingsClone.negativeSignCharacter))) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        if (left[0] === '-') {\n                            right = right.substring(1);\n                        }\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) && contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                    }\n                }\n\n                if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                    settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length;\n                    if (this.eventKeyCode === keyCode.Backspace) {\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter) + settingsClone.negativeSignCharacter.length) {\n                            left = left.substring(1);\n                        } else if (left !== '-' && this.selection.start <= this.value.indexOf(settingsClone.negativeSignCharacter) - settingsClone.currencySymbol.length) {\n                            left = left.substring(0, left.length - 1);\n                        } else if (left !== '' && !contains(this.value, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(0, left.length - 1);\n                        }\n                    } else {\n                        settingsClone.caretFix = this.selection.start >= this.value.indexOf(settingsClone.currencySymbol) && settingsClone.currencySymbol !== '';\n                        if (this.selection.start === this.value.indexOf(settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1);\n                        }\n                        right = right.substring(1);\n                    }\n                }\n\n                return [left, right];\n            }\n\n            /**\n             * Process the deletion of characters.\n             */\n\n        }, {\n            key: '_processCharacterDeletion',\n            value: function _processCharacterDeletion() {\n                var settingsClone = this.settingsClone;\n\n                var left = void 0;\n                var right = void 0;\n\n                if (!this.selection.length) {\n                    var _getUnformattedLeftAn = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn2 = _slicedToArray(_getUnformattedLeftAn, 2);\n\n                    left = _getUnformattedLeftAn2[0];\n                    right = _getUnformattedLeftAn2[1];\n\n                    if (left === '' && right === '') {\n                        settingsClone.throwInput = false;\n                    }\n\n                    if ((settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && (settingsClone.negativePositiveSignPlacement === 'l' || settingsClone.negativePositiveSignPlacement === 'r')) && isNegative(this.value)) {\n                        var _processCharacterDele = this._processCharacterDeletionIfTrailingNegativeSign([left, right]); //TODO Change `this.value` to `this.that.value`?\n\n\n                        var _processCharacterDele2 = _slicedToArray(_processCharacterDele, 2);\n\n                        left = _processCharacterDele2[0];\n                        right = _processCharacterDele2[1];\n                    } else {\n                        if (this.eventKeyCode === keyCode.Backspace) {\n                            left = left.substring(0, left.length - 1);\n                        } else {\n                            right = right.substring(1, right.length);\n                        }\n                    }\n                } else {\n                    this._expandSelectionOnSign(false);\n\n                    var _getUnformattedLeftAn3 = this._getUnformattedLeftAndRightPartAroundTheSelection();\n\n                    var _getUnformattedLeftAn4 = _slicedToArray(_getUnformattedLeftAn3, 2);\n\n                    left = _getUnformattedLeftAn4[0];\n                    right = _getUnformattedLeftAn4[1];\n                }\n\n                this._setValueParts(left, right);\n            }\n\n            /**\n             * This function decides if the key pressed should be dropped or accepted, and modify the value 'on-the-fly' accordingly.\n             * Returns TRUE if the keycode is allowed.\n             * This functions also modify the value on-the-fly. //FIXME This should use another function in order to separate the test and the modification\n             *\n             * @param {Event} e\n             * @returns {boolean}\n             */\n\n        }, {\n            key: '_processCharacterInsertion',\n            value: function _processCharacterInsertion(e) {\n                var settingsClone = this.settingsClone;\n\n                var _getUnformattedLeftAn5 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn6 = _slicedToArray(_getUnformattedLeftAn5, 2),\n                    left = _getUnformattedLeftAn6[0],\n                    right = _getUnformattedLeftAn6[1];\n\n                settingsClone.throwInput = true;\n\n                // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n                var eventCharacter = character(e);\n\n                // Start rules when the decimal character key is pressed always use numeric pad dot to insert decimal separator\n                // Do not allow decimal character if no decimal part allowed\n                if (eventCharacter === settingsClone.decimalCharacter || settingsClone.decimalCharacterAlternative && eventCharacter === settingsClone.decimalCharacterAlternative || (eventCharacter === '.' || eventCharacter === ',') && this.eventKeyCode === keyCode.DotNumpad) {\n                    if (!settingsClone.decimalPlacesOverride || !settingsClone.decimalCharacter) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character before negativeSignCharacter character\n                    if (settingsClone.negativeSignCharacter && contains(right, settingsClone.negativeSignCharacter)) {\n                        return true;\n                    }\n\n                    // Do not allow decimal character if other decimal character present\n                    if (contains(left, settingsClone.decimalCharacter)) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) > 0) {\n                        return true;\n                    }\n\n                    if (right.indexOf(settingsClone.decimalCharacter) === 0) {\n                        right = right.substr(1);\n                    }\n\n                    this._setValueParts(left + settingsClone.decimalCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent minus if not allowed\n                if ((eventCharacter === '-' || eventCharacter === '+') && settingsClone.negativeSignCharacter === '-') {\n                    if (!settingsClone) {\n                        return true;\n                    }\n\n                    // Caret is always after minus\n                    if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (isNegativeStrict(left) || contains(left, settingsClone.negativeSignCharacter)) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    } else {\n                        if (left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                            left = settingsClone.negativeSignCharacter;\n                            right = right.substring(1, right.length);\n                        }\n\n                        // Change number sign, remove part if should\n                        if (left.charAt(0) === settingsClone.negativeSignCharacter) {\n                            left = left.substring(1, left.length);\n                        } else {\n                            left = eventCharacter === '-' ? settingsClone.negativeSignCharacter + left : left;\n                        }\n                    }\n\n                    this._setValueParts(left, right);\n\n                    return true;\n                }\n\n                // If the user tries to insert digit before minus sign\n                var eventNumber = Number(eventCharacter);\n                if (eventNumber >= 0 && eventNumber <= 9) {\n                    if (settingsClone.negativeSignCharacter && left === '' && contains(right, settingsClone.negativeSignCharacter)) {\n                        left = settingsClone.negativeSignCharacter;\n                        right = right.substring(1, right.length);\n                    }\n\n                    if (settingsClone.maximumValue <= 0 && settingsClone.minimumValue < settingsClone.maximumValue && !contains(this.value, settingsClone.negativeSignCharacter) && eventCharacter !== '0') {\n                        left = settingsClone.negativeSignCharacter + left;\n                    }\n\n                    this._setValueParts(left + eventCharacter, right);\n\n                    return true;\n                }\n\n                // Prevent any other character\n                settingsClone.throwInput = false;\n\n                return false;\n            }\n\n            /**\n             * Formatting of just processed value while keeping the cursor position\n             *\n             * @param {Event} e\n             * @private\n             */\n\n        }, {\n            key: '_formatValue',\n            value: function _formatValue(e) {\n                var _this = this;\n\n                var settingsClone = this.settingsClone;\n                var leftLength = this.value;\n\n                var _getUnformattedLeftAn7 = this._getUnformattedLeftAndRightPartAroundTheSelection(),\n                    _getUnformattedLeftAn8 = _slicedToArray(_getUnformattedLeftAn7, 1),\n                    left = _getUnformattedLeftAn8[0];\n\n                // No grouping separator and no currency sign\n\n\n                if ((settingsClone.digitGroupSeparator === '' || settingsClone.digitGroupSeparator !== '' && !contains(leftLength, settingsClone.digitGroupSeparator)) && (settingsClone.currencySymbol === '' || settingsClone.currencySymbol !== '' && !contains(leftLength, settingsClone.currencySymbol))) {\n                    var _leftLength$split = leftLength.split(settingsClone.decimalCharacter),\n                        _leftLength$split2 = _slicedToArray(_leftLength$split, 1),\n                        subParts = _leftLength$split2[0];\n\n                    var nSign = '';\n                    if (isNegative(subParts)) {\n                        nSign = '-';\n                        subParts = subParts.replace('-', '');\n                        left = left.replace('-', '');\n                    }\n\n                    // Strip leading zero on positive value if needed\n                    if (nSign === '' && subParts.length > settingsClone.mIntPos && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    // Strip leading zero on negative value if needed\n                    if (nSign === '-' && subParts.length > settingsClone.mIntNeg && left.charAt(0) === '0') {\n                        left = left.slice(1);\n                    }\n\n                    left = nSign + left;\n                }\n\n                var value = addGroupSeparators(this.value, this.settingsClone);\n                var position = value.length;\n                if (value) {\n                    // Prepare regexp which searches for cursor position from unformatted left part\n                    var leftAr = left.split('');\n\n                    // Fixes caret position with trailing minus sign\n                    if ((settingsClone.negativePositiveSignPlacement === 's' || settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement !== 'p') && leftAr[0] === '-' && settingsClone.negativeSignCharacter !== '') {\n                        leftAr.shift();\n\n                        if ((this.eventKeyCode === keyCode.Backspace || this.eventKeyCode === keyCode.Delete) && settingsClone.caretFix) {\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'l') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 'p' && settingsClone.negativePositiveSignPlacement === 's') {\n                                leftAr.push('-');\n                                settingsClone.caretFix = e.type === 'keydown';\n                            }\n\n                            if (settingsClone.currencySymbolPlacement === 's' && settingsClone.negativePositiveSignPlacement === 'r') {\n                                (function () {\n                                    var signParts = settingsClone.currencySymbol.split('');\n                                    var escapeChr = ['\\\\', '^', '$', '.', '|', '?', '*', '+', '(', ')', '['];\n                                    var escapedParts = [];\n                                    $.each(signParts, function (i, miniParts) {\n                                        miniParts = signParts[i];\n                                        if (isInArray(miniParts, escapeChr)) {\n                                            escapedParts.push('\\\\' + miniParts);\n                                        } else {\n                                            escapedParts.push(miniParts);\n                                        }\n                                    });\n\n                                    if (_this.eventKeyCode === keyCode.Backspace) {\n                                        escapedParts.push('-');\n                                    }\n\n                                    // Pushing the escaped sign\n                                    leftAr.push(escapedParts.join(''));\n                                    settingsClone.caretFix = e.type === 'keydown';\n                                })();\n                            }\n                        }\n                    }\n\n                    for (var i = 0; i < leftAr.length; i++) {\n                        if (!leftAr[i].match('\\\\d')) {\n                            leftAr[i] = '\\\\' + leftAr[i];\n                        }\n                    }\n\n                    var leftReg = new RegExp('^.*?' + leftAr.join('.*?'));\n\n                    // Search cursor position in formatted value\n                    var newLeft = value.match(leftReg);\n                    if (newLeft) {\n                        position = newLeft[0].length;\n\n                        // If the positive sign is shown, calculate the caret position accordingly\n                        if (settingsClone.showPositiveSign) {\n                            if (position === 0 && newLeft.input.charAt(0) === settingsClone.positiveSignCharacter) {\n                                position = newLeft.input.indexOf(settingsClone.currencySymbol) === 1 ? settingsClone.currencySymbol.length + 1 : 1;\n                            }\n\n                            if (position === 0 && newLeft.input.charAt(settingsClone.currencySymbol.length) === settingsClone.positiveSignCharacter) {\n                                position = settingsClone.currencySymbol.length + 1;\n                            }\n                        }\n\n                        // If we are just before the sign which is in prefix position\n                        if ((position === 0 && value.charAt(0) !== settingsClone.negativeSignCharacter || position === 1 && value.charAt(0) === settingsClone.negativeSignCharacter) && settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 'p') {\n                            // Place caret after prefix sign\n                            //TODO Should the test be 'isNegative' instead of 'isNegativeStrict' in order to search for '-' everywhere in the string?\n                            position = this.settingsClone.currencySymbol.length + (isNegativeStrict(value) ? 1 : 0);\n                        }\n                    } else {\n                        if (settingsClone.currencySymbol && settingsClone.currencySymbolPlacement === 's') {\n                            // If we could not find a place for cursor and have a sign as a suffix\n                            // Place caret before suffix currency sign\n                            position -= settingsClone.currencySymbol.length;\n                        }\n\n                        if (settingsClone.suffixText) {\n                            // If we could not find a place for cursor and have a suffix\n                            // Place caret before suffix\n                            position -= settingsClone.suffixText.length;\n                        }\n                    }\n                }\n\n                // Only update the value if it has changed. This prevents modifying the selection, if any.\n                if (value !== this.that.value || value === this.that.value && (this.eventKeyCode === keyCode.num0 || this.eventKeyCode === keyCode.numpad0)) {\n                    this.that.value = value;\n                    this._setCaretPosition(position);\n                }\n\n                this.formatted = true; //TODO Rename `this.formatted` to `this._formatExecuted`, since it's possible this function does not need to format anything (in the case where the keycode is dropped for instance)\n            }\n        }]);\n\n        return AutoNumericHolder;\n    }();\n\n    /**\n     * This function factorise the `getString()` and `getArray()` functions since they share quite a lot of code.\n     *\n     * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n     * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n     *\n     * It then loops through the string and un-formats the inputs with autoNumeric.\n     * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n     * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers => please see option \"outputFormat\" for more details\n     *\n     * @param {boolean} getArrayBehavior - If set to TRUE, then this function behave like `getArray()`, otherwise if set to FALSE, it behave like `getString()`\n     * @param {HTMLElement} that - A reference to the current DOM element\n     * @returns {*}\n     * @private\n     */\n\n\n    function _getStringOrArray() {\n        var getArrayBehavior = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        var that = arguments[1];\n\n        var $this = getCurrentElement(that);\n        var formIndex = $('form').index($this);\n        var allFormElements = $('form:eq(' + formIndex + ')')[0];\n        var aiIndex = [];\n\n        // all input index\n        var scIndex = [];\n\n        // successful control index\n        var rSubmitterTypes = /^(?:submit|button|image|reset|file)$/i;\n\n        // from jQuery serialize method\n        var rSubmittable = /^(?:input|select|textarea|keygen)/i;\n\n        // from jQuery serialize method\n        var rCheckableType = /^(?:checkbox|radio)$/i;\n        var rNonAutoNumericTypes = /^(?:button|checkbox|color|date|datetime|datetime-local|email|file|image|month|number|password|radio|range|reset|search|submit|time|url|week)/i;\n\n        var count = 0;\n\n        // index of successful elements\n        $.each(allFormElements, function (i, field) {\n            if (field.name !== '' && rSubmittable.test(field.localName) && !rSubmitterTypes.test(field.type) && !field.disabled && (field.checked || !rCheckableType.test(field.type))) {\n                scIndex.push(count);\n                count++;\n            } else {\n                scIndex.push(-1);\n            }\n        });\n\n        // index of all inputs tags except checkbox\n        count = 0;\n        $.each(allFormElements, function (i, field) {\n            if (field.localName === 'input' && (field.type === '' || field.type === 'text' || field.type === 'hidden' || field.type === 'tel')) {\n                aiIndex.push(count);\n                count++;\n            } else {\n                aiIndex.push(-1);\n                if (field.localName === 'input' && rNonAutoNumericTypes.test(field.type)) {\n                    count++;\n                }\n            }\n        });\n\n        if (getArrayBehavior) {\n            var formFields = $this.serializeArray();\n\n            $.each(formFields, function (i, field) {\n                var scElement = scIndex.indexOf(i);\n\n                if (scElement > -1 && aiIndex[scElement] > -1) {\n                    var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                    var settings = testInput.data('autoNumeric');\n\n                    if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                        field.value = testInput.autoNumeric('getLocalized').toString();\n                    }\n                }\n            });\n\n            return formFields;\n        } else {\n            var _ret2 = function () {\n                // getString() behavior\n                var formFields = $this.serialize();\n                var formParts = formFields.split('&');\n\n                $.each(formParts, function (i) {\n                    var _formParts$i$split = formParts[i].split('='),\n                        _formParts$i$split2 = _slicedToArray(_formParts$i$split, 2),\n                        inputName = _formParts$i$split2[0],\n                        inputValue = _formParts$i$split2[1];\n\n                    var scElement = scIndex.indexOf(i);\n\n                    // If the current element is a valid element\n                    if (scElement > -1 && aiIndex[scElement] > -1) {\n                        var testInput = $('form:eq(' + formIndex + ') input:eq(' + aiIndex[scElement] + ')');\n                        var settings = testInput.data('autoNumeric');\n\n                        if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                            if (inputValue !== null) {\n                                var modifiedInputValue = testInput.autoNumeric('getLocalized').toString();\n                                formParts[i] = inputName + '=' + modifiedInputValue;\n                            }\n                        }\n                    }\n                });\n\n                return {\n                    v: formParts.join('&')\n                };\n            }();\n\n            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n        }\n    }\n\n    /**\n     * Handler for 'focusin' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusInAndMouseEnter($this, holder, e) {\n        var settings = holder.settingsClone;\n\n        if (e.type === 'focusin' || e.type === 'mouseenter' && !$this.is(':focus') && settings.emptyInputBehavior === 'focus') {\n            settings.hasFocus = true;\n\n            if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                $this.val(toggleNegativeBracket(e.target.value, settings));\n            }\n\n            // clean the value to compare to rawValue\n            var result = stripAllNonNumberCharacters(e.target.value, settings, true);\n            result = convertToNumericString(result, settings);\n            result = cleanLeadingTrailingZeros(result, settings);\n            if (settings.trailingNegative) {\n                result = '-' + result;\n            }\n\n            if (settings.decimalPlacesShownOnFocus) {\n                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.scaleDivisor) {\n                settings.decimalPlacesOverride = settings.oDec;\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (settings.noSeparatorOnFocus) {\n                settings.digitGroupSeparator = '';\n                settings.currencySymbol = '';\n                settings.suffixText = '';\n                $this.autoNumeric('set', settings.rawValue);\n            } else if (result !== settings.rawValue) {\n                $this.autoNumeric('set', result);\n            }\n\n            // In order to send a 'native' change event when blurring the input, we need to first store the initial input value on focus.\n            holder.valueOnFocus = e.target.value;\n            holder.lastVal = holder.valueOnFocus;\n            var onEmpty = checkEmpty(holder.valueOnFocus, settings, true);\n            if (onEmpty !== null && onEmpty !== '' && settings.emptyInputBehavior === 'focus') {\n                $this.val(onEmpty);\n                if (onEmpty === settings.currencySymbol && settings.currencySymbolPlacement === 's') {\n                    setElementSelection(e.target, 0, 0);\n                }\n            }\n        }\n    }\n\n    /**\n     * Handler for 'keydown' events.\n     * The user just started pushing any key, hence one event is sent.\n     *\n     * Note :\n     * By default a 'normal' input output those events in the right order when inputting a character key (ie. 'a') :\n     * - keydown\n     * - keypress\n     * - input\n     * - keyup\n     *\n     * ...when inputting a modifier key (ie. 'ctrl') :\n     * - keydown\n     * - keyup\n     *\n     * If 'delete' or 'backspace' is entered, the following events are sent :\n     * - keydown\n     * - input\n     * - keyup\n     *\n     * If 'enter' is entered and the value has not changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - keyup\n     *\n     * If 'enter' is entered and the value has been changed, the following events are sent :\n     * - keydown\n     * - keypress\n     * - change\n     * - keyup\n     *\n     * When a paste is done, the following events are sent :\n     * - input (if paste is done with the mouse)\n     *\n     * - keydown (if paste is done with ctrl+v)\n     * - keydown\n     * - input\n     * - keyup\n     * - keyup\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeydown(holder, e) {\n        //TODO Create a function that retrieve the element value (either by using `e.target.value` when the element is an <input>, or by using `element.textContent` when the element as its `contenteditable` set to true)\n        holder._updateAutoNumericHolderEventKeycode(e);\n        holder.initialValueOnKeydown = e.target.value; // This is needed in `onKeyup()` to check if the value as changed during the key press\n\n        if (holder.that.readOnly) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // The \"enter\" key throws a `change` event if the value has changed since the `focus` event\n        if (holder.eventKeyCode === keyCode.Enter && holder.valueOnFocus !== e.target.value) {\n            triggerEvent('change', e.target);\n            holder.valueOnFocus = e.target.value;\n        }\n\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            holder.processed = true;\n\n            return;\n        }\n\n        // Check if the key is a delete/backspace key\n        if (holder.eventKeyCode === keyCode.Backspace || holder.eventKeyCode === keyCode.Delete) {\n            holder._processCharacterDeletion(); // Because backspace and delete only triggers keydown and keyup events, not keypress\n            holder.processed = true;\n            holder._formatValue(e);\n\n            // If and only if the resulting value has changed after that backspace/delete, then we have to send an 'input' event like browsers normally do.\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throw an input event when a character deletion is detected\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to delete a second character\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        holder.formatted = false; //TODO Is this line needed?\n    }\n\n    /**\n     * Handler for 'keypress' events.\n     * The user is still pressing the key, which will output a character (ie. '2') continuously until it releases the key.\n     * Note: 'keypress' events are not sent for delete keys like Backspace/Delete.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onKeypress(holder, e) {\n        // Retrieve the real character that has been entered (ie. 'a' instead of the key code)\n        var eventCharacter = character(e);\n\n        // Firefox generate a 'keypress' event (e.keyCode === 0) for the keys that do not print a character (ie. 'Insert', 'Delete', 'Fn' keys, 'PageUp', 'PageDown' etc.). 'Shift' on the other hand does not generate a keypress event.\n        if (eventCharacter === keyName.Insert) {\n            return;\n        }\n\n        var processed = holder.processed;\n        holder._updateAutoNumericHolderProperties(e);\n\n        if (holder._skipAlways(e)) {\n            return;\n        }\n\n        if (processed) {\n            e.preventDefault();\n\n            return;\n        }\n\n        var isCharacterInsertionAllowed = holder._processCharacterInsertion(e);\n        if (isCharacterInsertionAllowed) {\n            holder._formatValue(e);\n            if (e.target.value !== holder.lastVal && holder.settingsClone.throwInput) {\n                // Throws input event on adding a character\n                triggerEvent('input', e.target);\n                e.preventDefault(); // ...and immediately prevent the browser to add a second character\n            } else {\n                if ((eventCharacter === holder.settings.decimalCharacter || eventCharacter === holder.settings.decimalCharacterAlternative) && getElementSelection(e.target).start === getElementSelection(e.target).end && getElementSelection(e.target).start === e.target.value.indexOf(holder.settings.decimalCharacter)) {\n                    var position = getElementSelection(e.target).start + 1;\n                    setElementSelection(e.target, position, position);\n                }\n                e.preventDefault();\n            }\n\n            holder.lastVal = e.target.value;\n            holder.settingsClone.throwInput = true;\n\n            return;\n        }\n\n        e.preventDefault();\n\n        holder.formatted = false;\n    }\n\n    /**\n     * Handler for 'keyup' events.\n     * The user just released any key, hence one event is sent.\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {object} settings\n     * @param {Event} e\n     */\n    function onKeyup(holder, settings, e) {\n        holder._updateAutoNumericHolderProperties(e);\n\n        var skip = holder._skipAlways(e);\n        delete holder.valuePartsBeforePaste;\n        if (skip || e.target.value === '') {\n            return;\n        }\n\n        // Added to properly place the caret when only the currency sign is present\n        if (e.target.value === holder.settingsClone.currencySymbol) {\n            if (holder.settingsClone.currencySymbolPlacement === 's') {\n                setElementSelection(e.target, 0, 0);\n            } else {\n                setElementSelection(e.target, holder.settingsClone.currencySymbol.length, holder.settingsClone.currencySymbol.length);\n            }\n        } else if (holder.eventKeyCode === keyCode.Tab) {\n            setElementSelection(e.target, 0, e.target.value.length);\n        }\n\n        if (e.target.value === holder.settingsClone.suffixText || holder.settingsClone.rawValue === '' && holder.settingsClone.currencySymbol !== '' && holder.settingsClone.suffixText !== '') {\n            setElementSelection(e.target, 0, 0);\n        }\n\n        // Saves the extended decimal to preserve the data when navigating away from the page\n        if (holder.settingsClone.decimalPlacesShownOnFocus !== null && holder.settingsClone.saveValueToSessionStorage) {\n            saveValueToPersistentStorage(e.target, settings, 'set');\n        }\n\n        if (!holder.formatted) {\n            holder._formatValue(e);\n        }\n\n        // If the input value has changed during the key press event chain, an event is sent to alert that a formatting has been done (cf. Issue #187)\n        if (e.target.value !== holder.initialValueOnKeydown) {\n            triggerEvent('autoNumeric:formatted', e.target);\n        }\n    }\n\n    /**\n     * Handler for 'focusout' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onFocusOutAndMouseLeave($this, holder, e) {\n        if (!$this.is(':focus')) {\n            var value = e.target.value;\n            var origValue = value;\n            var settings = holder.settingsClone;\n            settings.hasFocus = false;\n\n            if (settings.saveValueToSessionStorage) {\n                saveValueToPersistentStorage(e.target, settings, 'set');\n            }\n\n            if (settings.noSeparatorOnFocus === true) {\n                settings.digitGroupSeparator = settings.oSep;\n                settings.currencySymbol = settings.oSign;\n                settings.suffixText = settings.oSuffix;\n            }\n\n            if (settings.decimalPlacesShownOnFocus !== null) {\n                settings.decimalPlacesOverride = settings.oDec;\n                settings.allowDecimalPadding = settings.oPad;\n                settings.negativeBracketsTypeOnBlur = settings.oBracket;\n            }\n\n            value = stripAllNonNumberCharacters(value, settings, true);\n\n            if (value !== '') {\n                if (settings.trailingNegative && !isNegative(value)) {\n                    value = '-' + value;\n                    settings.trailingNegative = false;\n                }\n\n                var _checkIfInRangeWithOv3 = checkIfInRangeWithOverrideOption(value, settings),\n                    _checkIfInRangeWithOv4 = _slicedToArray(_checkIfInRangeWithOv3, 2),\n                    minTest = _checkIfInRangeWithOv4[0],\n                    maxTest = _checkIfInRangeWithOv4[1];\n\n                if (checkEmpty(value, settings, false) === null && minTest && maxTest) {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                    settings.rawValue = cleanLeadingTrailingZeros(value, settings);\n\n                    if (settings.scaleDivisor) {\n                        value = value / settings.scaleDivisor;\n                        value = value.toString();\n                    }\n\n                    settings.decimalPlacesOverride = settings.scaleDivisor && settings.scaleDecimalPlaces ? +settings.scaleDecimalPlaces : settings.decimalPlacesOverride;\n                    value = roundValue(value, settings);\n                    value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                } else {\n                    if (!minTest) {\n                        $this.trigger('autoNumeric:minExceeded');\n                    }\n                    if (!maxTest) {\n                        $this.trigger('autoNumeric:maxExceeded');\n                    }\n\n                    value = settings.rawValue;\n                }\n            } else {\n                if (settings.emptyInputBehavior === 'zero') {\n                    settings.rawValue = '0';\n                    value = roundValue('0', settings);\n                } else {\n                    settings.rawValue = '';\n                }\n            }\n\n            var groupedValue = checkEmpty(value, settings, false);\n            if (groupedValue === null) {\n                groupedValue = addGroupSeparators(value, settings);\n            }\n\n            if (groupedValue !== origValue) {\n                groupedValue = settings.scaleSymbol ? groupedValue + settings.scaleSymbol : groupedValue;\n                $this.val(groupedValue);\n            }\n\n            if (groupedValue !== holder.valueOnFocus) {\n                $this.change();\n                delete holder.valueOnFocus;\n            }\n        }\n    }\n\n    /**\n     * Handler for 'paste' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onPaste($this, holder, e) {\n        //TODO Using ctrl+z after a paste should cancel it -> How would that affect other frameworks/component built with that feature in mind though?\n        //FIXME When pasting '000' on a thousand group selection, the whole selection gets deleted, and only one '0' is pasted (cf. issue #302)\n        // The event is prevented by default, since otherwise the user would be able to paste invalid characters into the input\n        e.preventDefault();\n\n        var rawPastedText = e.clipboardData.getData('text/plain');\n\n        // 0. Special case if the user has selected all the input text before pasting\n        var initialFormattedValue = e.target.value;\n        var selectionStart = e.target.selectionStart || 0;\n        var selectionEnd = e.target.selectionEnd || 0;\n        var selectionSize = selectionEnd - selectionStart;\n        var isAllInputTextSelected = false;\n\n        if (selectionSize === initialFormattedValue.length) {\n            isAllInputTextSelected = true;\n        }\n\n        // 1. Check if the paste has a negative sign (only if it's the first character), and store that information for later use\n        var isPasteNegative = isNegativeStrict(rawPastedText);\n        if (isPasteNegative) {\n            // 1a. Remove the negative sign from the pasted text\n            rawPastedText = rawPastedText.slice(1, rawPastedText.length);\n        }\n\n        // 2. Strip all thousand separators, brackets and currency sign, and convert the decimal character to a dot\n        var untranslatedPastedText = preparePastedText(rawPastedText, holder);\n\n        var pastedText = void 0;\n        if (untranslatedPastedText === '.') {\n            // Special case : If the user tries to paste a single decimal character (that has been translated to '.' already)\n            pastedText = '.';\n        } else {\n            // Normal case\n            // Allow pasting arabic numbers\n            pastedText = arabicToLatinNumbers(untranslatedPastedText, false, false, false);\n        }\n\n        // 3. Test if the paste is valid (only has numbers and eventually a decimal character). If it's not valid, stop here.\n        if (pastedText !== '.' && (!isNumber(pastedText) || pastedText === '')) {\n            if (holder.settings.onInvalidPaste === 'error') {\n                //TODO Should we send a warning instead of throwing an error?\n                throwError('The pasted value \\'' + rawPastedText + '\\' is not a valid paste content.');\n            }\n\n            return;\n        }\n\n        // 4. Calculate the paste result\n        var caretPositionOnInitialTextAfterPasting = void 0;\n        var initialUnformattedNumber = void 0;\n        if (e.target.value === '') {\n            // autoNumeric 'get' returns '0.00' if the input is empty, hence we need to store the 'real' empty initial value when needed\n            //FIXME This has been fixed in a previous commit, get should return '' on an empty input. Remove this unneeded 'if'\n            initialUnformattedNumber = '';\n        } else {\n            initialUnformattedNumber = $this.autoNumeric('get');\n        }\n        var isInitialValueNegative = isNegativeStrict(initialUnformattedNumber);\n        var isPasteNegativeAndInitialValueIsPositive = void 0;\n        var result = void 0;\n\n        // If the pasted content is negative, then the result will be negative too\n        if (isPasteNegative && !isInitialValueNegative) {\n            initialUnformattedNumber = '-' + initialUnformattedNumber;\n            isInitialValueNegative = true;\n            isPasteNegativeAndInitialValueIsPositive = true;\n        } else {\n            isPasteNegativeAndInitialValueIsPositive = false;\n        }\n\n        var leftPartContainedADot = false;\n        switch (holder.settings.onInvalidPaste) {\n            /* 4a. Truncate paste behavior:\n             * Insert as many numbers as possible on the right hand side of the caret from the pasted text content, until the input reach its range limit.\n             * If there is more characters in the clipboard once a limit is reached, drop the extraneous characters.\n             * Otherwise paste all the numbers in the clipboard.\n             * While doing so, we check if the result is within the minimum and maximum values allowed, and stop as soon as we encounter one of those.\n             *\n             * 4b. Replace paste behavior:\n             * Idem than the 'truncate' paste behavior, except that when a range limit is hit, we try to replace the subsequent initial numbers with the pasted ones, until we hit the range limit a second (and last) time, or we run out of numbers to paste\n             */\n            /* eslint no-case-declarations: 0 */\n            case 'truncate':\n            case 'replace':\n                var leftFormattedPart = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart + rightFormattedPart, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                var leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                var rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // c. Add numbers one by one at the caret position, while testing if the result is valid and within the range of the minimum and maximum value\n                //    Continue until you either run out of numbers to paste, or that you get out of the range limits\n                var minParse = parseStr(holder.settings.minimumValue);\n                var maxParse = parseStr(holder.settings.maximumValue);\n                var lastGoodKnownResult = result; // This is set as the default, in case we do not add even one number\n                var pastedTextIndex = 0;\n                var modifiedLeftPart = leftPart;\n\n                while (pastedTextIndex < pastedText.length) {\n                    // Modify the result with another pasted character\n                    modifiedLeftPart += pastedText[pastedTextIndex];\n                    result = modifiedLeftPart + rightPart;\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting += pastedTextIndex;\n\n                //XXX Here we have the result for the `truncate` option\n                if (holder.settings.onInvalidPaste === 'truncate') {\n                    //TODO If the user as defined a truncate callback and there are still some numbers (that will be dropped), then call this callback with the initial paste as well as the remaining numbers\n                    result = lastGoodKnownResult;\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                    break;\n                }\n                //XXX ...else we need to continue modifying the result for the 'replace' option\n\n                // d. Until there are numbers to paste, replace the initial numbers one by one, and still do the range test.\n                //    Stop when you have no more numbers to paste, or if you are out of the range limits.\n                //    If you do get to the range limits, use the previous known good value within those limits.\n                //    Note: The numbers are replaced one by one, in the integer then decimal part, while ignoring the decimal character\n                //TODO What should happen if the user try to paste a decimal number? Should we override the current initial decimal character in favor of this new one? If we do, then we have to recalculate the vMin/vMax from the start in order to take into account this new decimal character position..\n                var lastGoodKnownResultIndex = caretPositionOnInitialTextAfterPasting;\n                var lastGoodKnownResultSize = lastGoodKnownResult.length;\n\n                while (pastedTextIndex < pastedText.length && lastGoodKnownResultIndex < lastGoodKnownResultSize) {\n                    if (lastGoodKnownResult[lastGoodKnownResultIndex] === '.') {\n                        // We skip the decimal character 'replacement'. That way, we do not change the decimal character position regarding the remaining numbers.\n                        lastGoodKnownResultIndex++;\n                        continue;\n                    }\n\n                    // This replace one character at a time\n                    result = replaceCharAt(lastGoodKnownResult, lastGoodKnownResultIndex, pastedText[pastedTextIndex]);\n\n                    // Check the range limits\n                    if (!checkIfInRange(result, minParse, maxParse)) {\n                        // The result is out of the range limits, stop the loop here\n                        break;\n                    }\n\n                    // Save the last good known result\n                    lastGoodKnownResult = result;\n\n                    // Update the local variables for the next loop\n                    pastedTextIndex++;\n                    lastGoodKnownResultIndex++;\n                }\n\n                // Update the last caret position where to insert a new number\n                caretPositionOnInitialTextAfterPasting = lastGoodKnownResultIndex;\n\n                if (leftPartContainedADot) {\n                    // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                    caretPositionOnInitialTextAfterPasting--;\n                }\n\n                result = lastGoodKnownResult;\n\n                break;\n            /* 4c. Normal paste behavior:\n             * Insert the pasted number inside the current unformatted text, at the right caret position or selection\n             */\n            case 'error':\n            case 'ignore':\n            case 'clamp':\n            default:\n                // 1. Generate the unformatted result\n                var leftFormattedPart2 = initialFormattedValue.slice(0, selectionStart);\n                var rightFormattedPart2 = initialFormattedValue.slice(selectionEnd, initialFormattedValue.length);\n\n                if (selectionStart !== selectionEnd) {\n                    // a. If there is a selection, remove the selected part, and return the left and right part\n                    result = preparePastedText(leftFormattedPart2 + rightFormattedPart2, holder);\n                } else {\n                    // b. Else if this is only one caret (and therefore no selection), then return the left and right part\n                    result = preparePastedText(initialFormattedValue, holder);\n                }\n\n                // Add back the negative sign if needed\n                if (isInitialValueNegative) {\n                    result = setRawNegativeSign(result);\n                }\n\n                // Build the unformatted result string\n                caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                if (isPasteNegativeAndInitialValueIsPositive) {\n                    // If the initial paste is negative and the initial value is not, then I must offset the caret position by one place to the right to take the additional hyphen into account\n                    caretPositionOnInitialTextAfterPasting++;\n                    //TODO Quid if the negative sign is not on the left (negativePositiveSignPlacement and currencySymbolPlacement)?\n                }\n\n                leftPart = result.slice(0, caretPositionOnInitialTextAfterPasting);\n                rightPart = result.slice(caretPositionOnInitialTextAfterPasting, result.length);\n                if (pastedText === '.') {\n                    // If the user only paste a single decimal character, then we remove the previously existing one (if any)\n                    if (contains(leftPart, '.')) {\n                        // If I remove a dot here, then I need to update the caret position (decrement it by 1) when positioning it\n                        // To do so, we keep that info in order to modify the caret position later\n                        leftPartContainedADot = true;\n                        leftPart = leftPart.replace('.', '');\n                    }\n                    rightPart = rightPart.replace('.', '');\n                }\n                // -- Here, we are good to go to continue on the same basis\n\n                // Generate the unformatted result\n                result = '' + leftPart + pastedText + rightPart;\n\n                // 2. Calculate the caret position in the unformatted value, for later use\n                if (selectionStart === selectionEnd) {\n                    // There is no selection, then the caret position is set after the pasted text\n                    var indexWherePastedTextHasBeenInserted = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter));\n                    caretPositionOnInitialTextAfterPasting = indexWherePastedTextHasBeenInserted + pastedText.length; // I must not count the characters that have been removed from the pasted text (ie. '.')\n                } else {\n                    if (isAllInputTextSelected) {\n                        // Special case when all the input text is selected before pasting, which means we'll completely erase its content and paste only the clipboard content\n                        caretPositionOnInitialTextAfterPasting = result.length;\n                    } else if (rightPart === '') {\n                        // If the user selected from the caret position to the end of the input (on the far right)\n                        caretPositionOnInitialTextAfterPasting = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionStart, holder.settings.decimalCharacter)) + pastedText.length;\n                    } else {\n                        // Normal case\n                        var indexSelectionEndInRawValue = convertCharacterCountToIndexPosition(countNumberCharactersOnTheCaretLeftSide(initialFormattedValue, selectionEnd, holder.settings.decimalCharacter));\n\n                        // Here I must not count the characters that have been removed from the pasted text (ie. '.'), or the thousand separators in the initial selected text\n                        var selectedText = e.target.value.slice(selectionStart, selectionEnd);\n                        caretPositionOnInitialTextAfterPasting = indexSelectionEndInRawValue - selectionSize + countCharInText(holder.settings.digitGroupSeparator, selectedText) + pastedText.length;\n                    }\n                }\n\n                // Modify the caret position for special cases, only if the whole input has not been selected\n                if (!isAllInputTextSelected) {\n                    if (isPasteNegativeAndInitialValueIsPositive) {\n                        // If the pasted value has a '-' sign, but the initial value does not, offset the index by one\n                        caretPositionOnInitialTextAfterPasting++;\n                    }\n\n                    if (leftPartContainedADot) {\n                        // If a dot has been removed for the part on the left of the caret, we decrement the caret index position\n                        caretPositionOnInitialTextAfterPasting--;\n                    }\n                }\n        }\n\n        // 5. Check if the result is a valid number, if not, drop the paste and do nothing.\n        if (!isNumber(result) || result === '') {\n            if (holder.settings.onInvalidPaste === 'error') {\n                throwError('The pasted value \\'' + rawPastedText + '\\' would result into an invalid content \\'' + result + '\\'.'); //TODO Should we send a warning instead of throwing an error?\n                //TODO This is not DRY ; refactor with above\n            }\n            return;\n        }\n\n        // 6. If it's a valid number, check if it falls inside the minimum and maximum value. If this fails, modify the value following this procedure :\n        /*\n         * If 'error' (this is the default) :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, then throw an error in the console.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'ignore' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, do nothing more.\n         *      - Do not change the input value, do not change the current selection.\n         * If 'clamp' :\n         *      - Normal paste behavior.\n         *      - Try to set the new value, if it fails, set the value to the minimum or maximum limit, whichever is closest to the\n         *        paste result.\n         *      - Change the caret position to be positioned on the left hand side of the decimal character.\n         * If 'truncate' :\n         *      - Truncate paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n         *      - Drop the remaining non-pasted numbers, and keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         * If 'replace' :\n         *      - Replace paste behavior.\n         *      - Try to set the new value, until it fails (if the result is out of the min and max value limits).\n         *     - Then try to replace as many numbers as possible with the pasted ones. Once it fails, keep the last known non-failing result.\n         *      - Change the caret position to be positioned after the last pasted character.\n         */\n        var valueHasBeenSet = false;\n        var valueHasBeenClamped = false;\n        try {\n            $this.autoNumeric('set', result);\n            valueHasBeenSet = true;\n        } catch (error) {\n            var clampedValue = void 0;\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    clampedValue = clampToRangeLimits(result, holder.settings);\n                    try {\n                        $this.autoNumeric('set', clampedValue);\n                    } catch (error) {\n                        throwError('Fatal error: Unable to set the clamped value \\'' + clampedValue + '\\'.');\n                    }\n\n                    valueHasBeenClamped = true;\n                    valueHasBeenSet = true;\n                    result = clampedValue; // This is used only for setting the caret position later\n                    break;\n                case 'error':\n                case 'truncate':\n                case 'replace':\n                    // Throw an error message\n                    throwError('The pasted value \\'' + rawPastedText + '\\' results in a value \\'' + result + '\\' that is outside of the minimum [' + holder.settings.minimumValue + '] and maximum [' + holder.settings.maximumValue + '] value range.');\n                // falls through\n                case 'ignore':\n                // Do nothing\n                // falls through\n                default:\n                    return; // ...and nothing else should be changed\n            }\n        }\n\n        // 7. Then lastly, set the caret position at the right logical place\n        var caretPositionInFormattedNumber = void 0;\n        if (valueHasBeenSet) {\n            switch (holder.settings.onInvalidPaste) {\n                case 'clamp':\n                    if (valueHasBeenClamped) {\n                        if (holder.settings.currencySymbolPlacement === 's') {\n                            setElementSelection(e.target, e.target.value.length - holder.settings.currencySymbol.length); // This puts the caret on the right of the last decimal place\n                        } else {\n                            setElementSelection(e.target, e.target.value.length); // ..and this on the far right\n                        }\n\n                        break;\n                    } // else if the value has not been clamped, the default behavior is used...\n                // falls through\n                case 'error':\n                case 'ignore':\n                case 'truncate':\n                case 'replace':\n                default:\n                    // Whenever one or multiple characters are pasted, this means we have to manage the potential thousand separators that could be added by the formatting\n                    caretPositionInFormattedNumber = findCaretPositionInFormattedNumber(result, caretPositionOnInitialTextAfterPasting, e.target.value, holder.settings.decimalCharacter);\n                    setElementSelection(e.target, caretPositionInFormattedNumber);\n            }\n        }\n\n        // 8. We make sure we send an input event only if the result is different than the initial value before the paste\n        if (valueHasBeenSet && initialFormattedValue !== e.target.value) {\n            // On a 'normal' non-autoNumeric input, an `input` event is sent when a paste is done. We mimic that.\n            triggerEvent('input', e.target);\n        }\n    }\n\n    /**\n     * When focusing out of the input, we check if the value has changed, and if it has, then we send a `change` event (since the native one would have been prevented by `e.preventDefault()` called in the other event listeners).\n     *\n     * @param {AutoNumericHolder} holder\n     * @param {Event} e\n     */\n    function onBlur(holder, e) {\n        if (e.target.value !== holder.valueOnFocus) {\n            triggerEvent('change', e.target);\n            // e.preventDefault(); // ...and immediately prevent the browser to send a second change event (that somehow gets picked up by jQuery, but not by `addEventListener()` //FIXME KNOWN BUG : This does not prevent the second change event to be picked up by jQuery, which adds '.00' at the end of an integer\n        }\n    }\n\n    /**\n     * Handler for 'submit' events\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @param {AutoNumericHolder} holder\n     */\n    function onSubmit($this, holder) {\n        $this.closest('form').on('submit.autoNumeric', function () {\n            if (holder) {\n                var $settings = holder.settingsClone;\n\n                if ($settings.unformatOnSubmit) {\n                    $this.val($settings.rawValue);\n                }\n            }\n        });\n    }\n\n    /**\n     * Return the jQuery selected input if the tag and type are supported by autoNumeric.\n     *\n     * @param {object} $this jQuery-selected DOM element\n     * @returns {boolean|*}\n     */\n    function getInputIfSupportedTagAndType($this) {\n        // Supported input type\n        var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n        // Checks for non-supported input types\n        if (!$input && $this.prop('tagName').toLowerCase() === 'input') {\n            throwError('The input type \"' + $this.prop('type') + '\" is not supported by autoNumeric');\n        }\n\n        // Checks for non-supported tags\n        var currentElementTag = $this.prop('tagName').toLowerCase();\n        if (currentElementTag !== 'input' && !isInArray(currentElementTag, allowedTagList)) {\n            throwError('The <' + currentElementTag + '> tag is not supported by autoNumeric');\n        }\n\n        return $input;\n    }\n\n    /**\n     * Formats the default value on page load.\n     * This is called only if the `formatOnPageLoad` option is set to `true`.\n     *\n     * @param {object} settings\n     * @param {object} $input jQuery-selected <input> element\n     * @param {object} $this jQuery-selected DOM element\n     */\n    function formatDefaultValueOnPageLoad(settings, $input, $this) {\n        var setValue = true;\n\n        if ($input) {\n            var currentValue = $this.val();\n            /*\n             * If the input value has been set by the dev, but not directly as an attribute in the html, then it takes\n             * precedence and should get formatted on init (if this input value is a valid number and that the\n             * developer wants it formatted on init (cf. `settings.formatOnPageLoad`)).\n             * Note; this is true whatever the developer has set for `data-an-default` in the html (asp.net users).\n             *\n             * In other words : if `defaultValueOverride` is not null, it means the developer is trying to prevent postback problems.\n             * But if `input.value` is set to a number, and `$this.attr('value')` is not set, then it means the dev has\n             * changed the input value, and then it means we should not overwrite his own decision to do so.\n             * Hence, if `defaultValueOverride` is not null, but `input.value` is a number and `$this.attr('value')` is not set,\n             * we should ignore `defaultValueOverride` altogether.\n             */\n            var unLocalizedCurrentValue = toNumericValue(currentValue, settings); // This allows to use a localized value on startup\n            if (settings.formatOnPageLoad && currentValue !== '' && isUndefinedOrNullOrEmpty($this.attr('value'))) {\n                // Check if the `value` is valid or not\n                if (!isNaN(unLocalizedCurrentValue) && Infinity !== unLocalizedCurrentValue) {\n                    $this.autoNumeric('set', unLocalizedCurrentValue);\n                    setValue = false;\n                } else {\n                    // If not, inform the developer that nothing usable has been provided\n                    throwError('The value [' + currentValue + '] used in the input is not a valid value autoNumeric can work with.');\n                }\n            } else {\n                /* Checks for :\n                 * - page reload from back button, and\n                 * - ASP.net form post back\n                 *      The following HTML data attribute is REQUIRED (data-an-default=\"same value as the value attribute\")\n                 *      example: <asp:TextBox runat=\"server\" id=\"someID\" text=\"1234.56\" data-an-default=\"1234.56\">\n                 */\n                if (settings.defaultValueOverride !== null && settings.defaultValueOverride.toString() !== currentValue || settings.defaultValueOverride === null && currentValue !== '' && currentValue !== $this.attr('value') || currentValue !== '' && $this.attr('type') === 'hidden' && !isNumber(unLocalizedCurrentValue)) {\n                    if (settings.decimalPlacesShownOnFocus !== null && settings.saveValueToSessionStorage || settings.scaleDivisor && settings.saveValueToSessionStorage) {\n                        settings.rawValue = saveValueToPersistentStorage($this[0], settings, 'get');\n                    }\n\n                    // If the decimalPlacesShownOnFocus value should NOT be saved in sessionStorage\n                    if (!settings.saveValueToSessionStorage) {\n                        var toStrip = void 0;\n\n                        if (settings.negativeBracketsTypeOnBlur !== null && settings.negativeSignCharacter !== '') {\n                            settings.hasFocus = true;\n                            toStrip = toggleNegativeBracket(currentValue, settings);\n                        } else {\n                            toStrip = currentValue;\n                        }\n\n                        if ((settings.negativePositiveSignPlacement === 's' || settings.negativePositiveSignPlacement !== 'p' && settings.currencySymbolPlacement === 's') && settings.negativeSignCharacter !== '' && isNegative(currentValue)) {\n                            settings.rawValue = settings.negativeSignCharacter + stripAllNonNumberCharacters(toStrip, settings, true);\n                        } else {\n                            settings.rawValue = stripAllNonNumberCharacters(toStrip, settings, true);\n                        }\n                    }\n\n                    setValue = false;\n                }\n            }\n\n            if (currentValue === '') {\n                switch (settings.emptyInputBehavior) {\n                    case 'focus':\n                        setValue = false;\n                        break;\n                    case 'always':\n                        $this.val(settings.currencySymbol);\n                        setValue = false;\n                        break;\n                    case 'zero':\n                        $this.autoNumeric('set', '0');\n                        setValue = false;\n                        break;\n                    default:\n                    //\n                }\n            } else if (setValue && currentValue === $this.attr('value')) {\n                $this.autoNumeric('set', currentValue);\n            }\n        }\n\n        if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList) && $this.text() !== '') {\n            if (settings.defaultValueOverride !== null) {\n                if (settings.defaultValueOverride === $this.text()) {\n                    $this.autoNumeric('set', $this.text());\n                }\n            } else {\n                $this.autoNumeric('set', $this.text());\n            }\n        }\n    }\n\n    /**\n     * Enhance the user experience by modifying the default `negativePositiveSignPlacement` option depending on `currencySymbol` and `currencySymbolPlacement`.\n     *\n     * If the user has not set the placement of the negative sign (`negativePositiveSignPlacement`), but has set a currency symbol (`currencySymbol`),\n     * then we modify the default value of `negativePositiveSignPlacement` in order to keep the resulting output logical by default :\n     * - \"$-1,234.56\" instead of \"-$1,234.56\" ({currencySymbol: \"$\", negativePositiveSignPlacement: \"r\"})\n     * - \"-1,234.56$\" instead of \"1,234.56-$\" ({currencySymbol: \"$\", currencySymbolPlacement: \"s\", negativePositiveSignPlacement: \"p\"})\n     *\n     * @param {object} settings\n     */\n    function correctNegativePositiveSignPlacementOption(settings) {\n        // If negativePositiveSignPlacement is already set, we do not overwrite it\n        if (!isNull(settings.negativePositiveSignPlacement)) {\n            return;\n        }\n\n        if (!isUndefined(settings) && isUndefinedOrNullOrEmpty(settings.negativePositiveSignPlacement) && !isUndefinedOrNullOrEmpty(settings.currencySymbol)) {\n            switch (settings.currencySymbolPlacement) {\n                case 's':\n                    settings.negativePositiveSignPlacement = 'p'; // Default -1,234.56 \n                    break;\n                case 'p':\n                    settings.negativePositiveSignPlacement = 'l'; // Default -$1,234.56\n                    break;\n                default:\n                //\n            }\n        } else {\n            // Sets the default value if `negativePositiveSignPlacement` is `null`\n            settings.negativePositiveSignPlacement = 'l';\n        }\n    }\n\n    /**\n     * Analyze and save the minimumValue and maximumValue integer size for later uses\n     *\n     * @param {object} settings\n     */\n    function calculateVMinAndVMaxIntegerSizes(settings) {\n        var _settings$maximumValu = settings.maximumValue.toString().split('.'),\n            _settings$maximumValu2 = _slicedToArray(_settings$maximumValu, 1),\n            maximumValueIntegerPart = _settings$maximumValu2[0];\n\n        var _ref3 = !settings.minimumValue && settings.minimumValue !== 0 ? [] : settings.minimumValue.toString().split('.'),\n            _ref4 = _slicedToArray(_ref3, 1),\n            minimumValueIntegerPart = _ref4[0];\n\n        maximumValueIntegerPart = maximumValueIntegerPart.replace('-', '');\n        minimumValueIntegerPart = minimumValueIntegerPart.replace('-', '');\n\n        settings.mIntPos = Math.max(maximumValueIntegerPart.length, 1);\n        settings.mIntNeg = Math.max(minimumValueIntegerPart.length, 1);\n    }\n\n    /**\n     * Modify `decimalPlacesOverride` as needed\n     *\n     * @param {object} settings\n     */\n    function correctDecimalPlacesOverrideOption(settings) {\n        if (!isNull(settings.scaleDivisor) && !isNull(settings.scaleDecimalPlaces)) {\n            // Override the maximum number of decimal places with the one defined with the number of decimals to show when not in focus, if set\n            settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\n        } else if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n        settings.oDec = String(settings.decimalPlacesOverride);\n\n        // Most calculus assume `decimalPlacesOverride` is an integer, the following statement makes it clear (otherwise having it as a string leads to problems in rounding for instance)\n        settings.decimalPlacesOverride = Number(settings.decimalPlacesOverride);\n    }\n\n    /**\n     * Sets the alternative decimal separator key.\n     *\n     * @param {object} settings\n     */\n    function setsAlternativeDecimalSeparatorCharacter(settings) {\n        if (isNull(settings.decimalCharacterAlternative) && Number(settings.decimalPlacesOverride) > 0) {\n            if (settings.decimalCharacter === '.' && settings.digitGroupSeparator !== ',') {\n                settings.decimalCharacterAlternative = ',';\n            } else if (settings.decimalCharacter === ',' && settings.digitGroupSeparator !== '.') {\n                settings.decimalCharacterAlternative = '.';\n            }\n        }\n    }\n\n    /**\n     * Caches regular expressions for stripAllNonNumberCharacters\n     *\n     * @param {object} settings\n     */\n    function cachesUsualRegularExpressions(settings) {\n        var allNumbersReg = '[0-9]';\n        var noAllNumbersReg = '[^0-9]';\n\n        // Test if there is a negative character in the string\n        var aNegReg = settings.negativeSignCharacter ? '([-\\\\' + settings.negativeSignCharacter + ']?)' : '(-?)';\n        settings.aNegRegAutoStrip = aNegReg;\n\n        var negativeSignRegPart = void 0;\n        if (settings.negativeSignCharacter) {\n            negativeSignRegPart = '\\\\' + settings.negativeSignCharacter;\n        } else {\n            negativeSignRegPart = '';\n        }\n        settings.skipFirstAutoStrip = new RegExp(aNegReg + '[^-' + negativeSignRegPart + '\\\\' + settings.decimalCharacter + allNumbersReg + '].*?(' + allNumbersReg + '|\\\\' + settings.decimalCharacter + allNumbersReg + ')');\n        settings.skipLastAutoStrip = new RegExp('(' + allNumbersReg + '\\\\' + settings.decimalCharacter + '?)[^\\\\' + settings.decimalCharacter + allNumbersReg + ']' + noAllNumbersReg + '*$');\n\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        settings.allowedAutoStrip = new RegExp('[^' + allowed + ']', 'g');\n        settings.numRegAutoStrip = new RegExp(aNegReg + '(?:\\\\' + settings.decimalCharacter + '?(' + allNumbersReg + '+\\\\' + settings.decimalCharacter + allNumbersReg + '+)|(' + allNumbersReg + '*(?:\\\\' + settings.decimalCharacter + allNumbersReg + '*)?))');\n\n        // Using this regex version `^${settings.aNegRegAutoStrip}0*(\\\\d|$)` entirely clear the input on blur\n        settings.stripReg = new RegExp('^' + settings.aNegRegAutoStrip + '0*(' + allNumbersReg + ')');\n    }\n\n    /**\n     * Modify the user settings to make them 'exploitable' later.\n     *\n     * @param {object} settings\n     */\n    function transformOptionsValuesToDefaultTypes(settings) {\n        $.each(settings, function (key, value) {\n            // Convert the string 'true' and 'false' to real Boolean\n            if (value === 'true' || value === 'false') {\n                settings[key] = value === 'true';\n            }\n\n            // Convert numbers in options to strings\n            //TODO if a value is already of type 'Number', shouldn't we keep it as a number for further manipulation, instead of using a string?\n            if (typeof value === 'number' && key !== 'aScale') {\n                settings[key] = value.toString();\n            }\n        });\n    }\n\n    /**\n     * Convert the old settings options name to new ones.\n     *\n     * @param {object} options\n     */\n    function convertOldOptionsToNewOnes(options) {\n        //TODO Delete this function once the old options are not used anymore\n        var oldOptionsConverter = {\n            // Old option name, with their corresponding new option\n            aSep: 'digitGroupSeparator',\n            nSep: 'noSeparatorOnFocus',\n            dGroup: 'digitalGroupSpacing',\n            aDec: 'decimalCharacter',\n            altDec: 'decimalCharacterAlternative',\n            aSign: 'currencySymbol',\n            pSign: 'currencySymbolPlacement',\n            pNeg: 'negativePositiveSignPlacement',\n            aSuffix: 'suffixText',\n            oLimits: 'overrideMinMaxLimits',\n            vMax: 'maximumValue',\n            vMin: 'minimumValue',\n            mDec: 'decimalPlacesOverride',\n            eDec: 'decimalPlacesShownOnFocus',\n            scaleDecimal: 'scaleDecimalPlaces',\n            aStor: 'saveValueToSessionStorage',\n            mRound: 'roundingMethod',\n            aPad: 'allowDecimalPadding',\n            nBracket: 'negativeBracketsTypeOnBlur',\n            wEmpty: 'emptyInputBehavior',\n            lZero: 'leadingZero',\n            aForm: 'formatOnPageLoad',\n            sNumber: 'selectNumberOnly',\n            anDefault: 'defaultValueOverride',\n            unSetOnSubmit: 'unformatOnSubmit',\n            outputType: 'outputFormat',\n            debug: 'showWarnings',\n            // Current options :\n            digitGroupSeparator: true,\n            noSeparatorOnFocus: true,\n            digitalGroupSpacing: true,\n            decimalCharacter: true,\n            decimalCharacterAlternative: true,\n            currencySymbol: true,\n            currencySymbolPlacement: true,\n            negativePositiveSignPlacement: true,\n            showPositiveSign: true,\n            suffixText: true,\n            overrideMinMaxLimits: true,\n            maximumValue: true,\n            minimumValue: true,\n            decimalPlacesOverride: true,\n            decimalPlacesShownOnFocus: true,\n            scaleDivisor: true,\n            scaleDecimalPlaces: true,\n            scaleSymbol: true,\n            saveValueToSessionStorage: true,\n            onInvalidPaste: true,\n            roundingMethod: true,\n            allowDecimalPadding: true,\n            negativeBracketsTypeOnBlur: true,\n            emptyInputBehavior: true,\n            leadingZero: true,\n            formatOnPageLoad: true,\n            selectNumberOnly: true,\n            defaultValueOverride: true,\n            unformatOnSubmit: true,\n            outputFormat: true,\n            showWarnings: true,\n            failOnUnknownOption: true,\n            //FIXME Find a way to exclude those internal data from the settings object (ideally by using another object, or better yet, class attributes) -->\n            hasFocus: true,\n            runOnce: true,\n            rawValue: true,\n            trailingNegative: true,\n            caretFix: true,\n            throwInput: true,\n            strip: true,\n            tagList: true,\n            negativeSignCharacter: true,\n            positiveSignCharacter: true,\n            mIntPos: true,\n            mIntNeg: true,\n            oDec: true,\n            oPad: true,\n            oBracket: true,\n            oSep: true,\n            oSign: true,\n            oSuffix: true,\n            aNegRegAutoStrip: true,\n            skipFirstAutoStrip: true,\n            skipLastAutoStrip: true,\n            allowedAutoStrip: true,\n            numRegAutoStrip: true,\n            stripReg: true,\n            holder: true\n        };\n\n        for (var option in options) {\n            if (options.hasOwnProperty(option)) {\n                if (oldOptionsConverter[option] === true) {\n                    // If the option is a 'new' option, we continue looping\n                    continue;\n                }\n\n                if (oldOptionsConverter.hasOwnProperty(option)) {\n                    // Else we have an 'old' option name\n                    warning('You are using the deprecated option name \\'' + option + '\\'. Please use \\'' + oldOptionsConverter[option] + '\\' instead from now on. The old option name will be dropped soon.', true);\n\n                    // Then we modify the initial option object to use the new options instead of the old ones\n                    options[oldOptionsConverter[option]] = options[option];\n                    delete options[option];\n                } else if (options.failOnUnknownOption) {\n                    // ...or the option name is unknown. This means there is a problem with the options object, therefore we throw an error.\n                    throwError('Option name \\'' + option + '\\' is unknown. Please fix the options passed to autoNumeric');\n                }\n            }\n        }\n    }\n\n    /**\n     * Analyse the settings/options passed by the user, validate and clean them, then return them.\n     * Note: This returns `null` if somehow the settings returned by jQuery is not an object.\n     *\n     * @param {object} options\n     * @param {object} $this jQuery-selected DOM element\n     * @param {boolean} update - If TRUE, then the settings already exists and this function only updates them instead of recreating them from scratch\n     * @returns {object|null}\n     */\n    function getInitialSettings(options, $this) {\n        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n        // Attempt to grab \"autoNumeric\" settings. If they do not exist, it returns \"undefined\".\n        var settings = $this.data('autoNumeric');\n\n        // If the user used old options, we convert them to new ones\n        if (update || !isNull(options)) {\n            convertOldOptionsToNewOnes(options);\n        }\n\n        if (update || isUndefined(settings)) {\n            if (update) {\n                // The settings are updated\n                settings = $.extend(settings, options);\n            } else {\n                // If we couldn't grab any settings, create them from the default ones and combine them with the options passed\n                // The settings are generated for the first time\n                // This also attempt to grab the HTML5 data. If it doesn't exist, we'll get \"undefined\"\n                var tagData = $this.data();\n                settings = $.extend({}, defaultSettings, tagData, options, {\n                    hasFocus: false,\n                    runOnce: false,\n                    rawValue: '',\n                    trailingNegative: false,\n                    caretFix: false,\n                    throwInput: true, // Throw input event\n                    strip: true,\n                    tagList: allowedTagList\n                });\n            }\n\n            // Modify the user settings to make them 'exploitable'\n            transformOptionsValuesToDefaultTypes(settings);\n\n            // Improve the `negativePositiveSignPlacement` option if needed\n            correctNegativePositiveSignPlacementOption(settings);\n\n            // Set the negative and positive signs, as needed\n            settings.negativeSignCharacter = settings.minimumValue < 0 ? '-' : '';\n            settings.positiveSignCharacter = settings.maximumValue >= 0 ? '+' : '';\n\n            // Additional changes to the settings object (from the original autoCode() function)\n            runCallbacksFoundInTheSettingsObject($this, settings);\n            calculateVMinAndVMaxIntegerSizes(settings);\n            correctDecimalPlacesOverrideOption(settings);\n            setsAlternativeDecimalSeparatorCharacter(settings);\n            cachesUsualRegularExpressions(settings);\n\n            // Validate the settings\n            validate(settings, false); // Throws if necessary\n\n            // Original settings saved for use when decimalPlacesShownOnFocus, scaleDivisor & noSeparatorOnFocus options are being used\n            keepAnOriginalSettingsCopy(settings);\n\n            // Save our new settings\n            $this.data('autoNumeric', settings);\n\n            return settings;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Convert the `value` parameter that can either be :\n     * - a real number,\n     * - a string representing a real number, or\n     * - a string representing a localized number (with specific group separators and decimal character),\n     * ...to a string representing a real 'javascript' number (ie. '1234' or '1234.567').\n     *\n     * This function returns `NaN` if such conversion fails.\n     *\n     * @param {int|float|string} value\n     * @param {object} settings\n     * @returns {string|NaN}\n     */\n    function toNumericValue(value, settings) {\n        var result = void 0;\n        if (isNumber(Number(value))) {\n            // The value has either already been stripped, or a 'real' javascript number is passed as a parameter\n            result = value;\n        } else {\n            // Else if it's a string that `Number()` cannot typecast, then we try to convert the localized numeric string to a numeric one\n            // Convert the value to a numeric string, stripping unnecessary characters in the process\n            result = convertToNumericString(value.toString(), settings);\n\n            // If the result is still not a numeric string, then we throw a warning\n            if (!isNumber(Number(result))) {\n                warning('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.', settings.showWarnings);\n                result = NaN;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Methods supported by autoNumeric\n     */\n    var methods = {\n        /**\n         * Method to initialize autoNumeric and attach the settings (options can be passed as a parameter)\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '})\n         *\n         * @example\n         * $(someSelector).autoNumeric('init');            // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric();                  // Initiate autoNumeric with defaults\n         * $(someSelector).autoNumeric('init', {options}); // Initiate autoNumeric with options\n         * $(someSelector).autoNumeric({options});         // Initiate autoNumeric with options\n         *\n         * @param {object} options\n         * @returns {*|{statements, branches, lines, functions, excludes, overrides}|{statements, branches, lines, functions, excludes}|{statements, lines, branches, functions, excludes}}\n         */\n        init: function init(options) {\n            return this.each(function () {\n                var $this = $(this);\n                var $input = getInputIfSupportedTagAndType($this);\n\n                var settings = getInitialSettings(options, $this, false);\n                if (isNull(settings)) {\n                    return this;\n                }\n\n                // Create the AutoNumericHolder object that store the field properties\n                var holder = getAutoNumericHolder($this, settings, false);\n\n                if (!settings.runOnce && settings.formatOnPageLoad) {\n                    formatDefaultValueOnPageLoad(settings, $input, $this);\n                }\n\n                settings.runOnce = true;\n\n                // Add the events listeners to supported input types (\"text\", \"hidden\", \"tel\" and no type)\n                if ($input) {\n                    this.addEventListener('focusin', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseenter', function (e) {\n                        onFocusInAndMouseEnter($this, holder, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('mouseleave', function (e) {\n                        onFocusOutAndMouseLeave($this, holder, e);\n                    }, false);\n                    this.addEventListener('keydown', function (e) {\n                        onKeydown(holder, e);\n                    }, false);\n                    this.addEventListener('keypress', function (e) {\n                        onKeypress(holder, e);\n                    }, false);\n                    this.addEventListener('keyup', function (e) {\n                        onKeyup(holder, settings, e);\n                    }, false);\n                    this.addEventListener('blur', function (e) {\n                        onBlur(holder, e);\n                    }, false);\n                    this.addEventListener('paste', function (e) {\n                        onPaste($this, holder, e);\n                    }, false);\n                    onSubmit($this, holder); //TODO Switch to `addEventListener'\n                }\n            });\n        },\n\n\n        /**\n         * Method to stop and remove autoNumeric for the current element.\n         * Note: this does not remove the formatting.\n         *\n         * @example $(someSelector).autoNumeric(\"destroy\"); // Destroys autoNumeric on this selected element\n         *\n         * @returns {*|jQuery}\n         */\n        destroy: function destroy() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                    $this.removeData('autoNumeric');\n                    $this.off('.autoNumeric');\n                }\n            });\n        },\n\n\n        /**\n         * Method to clear the value from sessionStorage (or cookie, depending on browser supports).\n         *\n         * @example $(someSelector).autoNumeric(\"wipe\"); // Removes session storage and cookies from memory\n         *\n         * @returns {*|jQuery}\n         */\n        wipe: function wipe() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.val('');\n                    settings.rawValue = '';\n                    saveValueToPersistentStorage($this[0], settings, 'wipe');\n                }\n            });\n        },\n\n\n        /**\n         * Method that updates the autoNumeric settings.\n         * It can be called multiple times if needed.\n         * The options passed as a parameter is an object that contains the settings (ie. {digitGroupSeparator: \".\", decimalCharacter: \",\", currencySymbol: ' '}).\n         *\n         * @example $(someSelector).autoNumeric(\"update\", {options}); // Updates the settings\n         *\n         * @param {object} options\n         * @returns {*|jQuery}\n         */\n        update: function update(options) {\n            return $(this).each(function () {\n                // Retrieve the current unformatted input value\n                var $this = getCurrentElement(this);\n                var strip = $this.autoNumeric('get');\n\n                // Update the settings\n                var settings = getInitialSettings(options, $this, true);\n\n                // Update the AutoNumericHolder object that store the field properties\n                getAutoNumericHolder($this, settings, true);\n\n                // Reformat the input value with the new settings\n                if ($this.val() !== '' || $this.text() !== '') {\n                    return $this.autoNumeric('set', strip);\n                }\n            });\n        },\n\n\n        /**\n         * Method to format the value passed as a parameter.\n         * If the value is passed as a string, it can be an integer '1234' or a double '1234.56789'\n         * and must contain only numbers and one decimal (period) character\n         *\n         * @example $(someSelector).autoNumeric('set', '12345.67'); // Formats the value being passed as the second parameter\n         *\n         * @param {*} newValue\n         * @returns {*|jQuery}\n         */\n        set: function set(newValue) {\n            return $(this).each(function () {\n                if (newValue === null || isUndefined(newValue)) {\n                    return;\n                }\n\n                //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                    throwError('Initializing autoNumeric is required prior to calling the \"set\" method.');\n                }\n                // Reset the trailing negative settings, since it's possible the previous value was negative, but not the newly set one\n                settings.trailingNegative = false;\n\n                var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n\n                var value = toNumericValue(newValue, settings);\n                if (isNaN(value)) {\n                    return $this.val('');\n                }\n\n                if (value !== '') {\n                    var _checkIfInRangeWithOv5 = checkIfInRangeWithOverrideOption(value, settings),\n                        _checkIfInRangeWithOv6 = _slicedToArray(_checkIfInRangeWithOv5, 2),\n                        minTest = _checkIfInRangeWithOv6[0],\n                        maxTest = _checkIfInRangeWithOv6[1];\n                    // This test is needed by the showPositiveSign option\n\n\n                    var isZero = isZeroOrHasNoValue(value);\n                    if (isZero) {\n                        value = '0';\n                    }\n\n                    if (minTest && maxTest) {\n                        if ($input || isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                            // to ensure rounding does not happen twice\n                            var hasBeenRounded = false;\n\n                            // rounds the the extended decimal places\n                            if (settings.decimalPlacesShownOnFocus) {\n                                var tempDecimal = settings.decimalPlacesOverride;\n                                settings.decimalPlacesOverride = settings.decimalPlacesShownOnFocus;\n                                value = roundValue(value, settings);\n                                hasBeenRounded = true;\n                                settings.decimalPlacesOverride = tempDecimal;\n                            }\n\n                            if (settings.scaleDivisor && !settings.onOff) {\n                                value = toNumericValue(value, settings);\n                                value = value / settings.scaleDivisor;\n                                value = value.toString();\n                                if (settings.scaleDecimalPlaces) {\n                                    var _tempDecimal = settings.decimalPlacesOverride;\n                                    settings.decimalPlacesOverride = settings.scaleDecimalPlaces;\n                                    value = roundValue(value, settings);\n                                    hasBeenRounded = true;\n                                    settings.decimalPlacesOverride = _tempDecimal;\n                                }\n                            }\n\n                            // Rounds if this has not been done already\n                            if (!hasBeenRounded) {\n                                value = roundValue(value, settings);\n                            }\n\n                            // Stores rawValue including the decimalPlacesShownOnFocus\n                            settings.rawValue = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\n                            value = modifyNegativeSignAndDecimalCharacterForFormattedValue(value, settings);\n                            value = addGroupSeparators(value, settings);\n                        }\n\n                        if (settings.saveValueToSessionStorage && (settings.decimalPlacesShownOnFocus || settings.scaleDivisor)) {\n                            saveValueToPersistentStorage($this[0], settings, 'set');\n                        }\n                    } else {\n                        settings.rawValue = '';\n                        saveValueToPersistentStorage($this[0], settings, 'wipe');\n                        var attemptedValue = value;\n                        value = '';\n                        if (!minTest) {\n                            $this.trigger('autoNumeric:minExceeded');\n                        }\n\n                        if (!maxTest) {\n                            $this.trigger('autoNumeric:maxExceeded');\n                        }\n\n                        throwError('The value [' + attemptedValue + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n\n                        return $this.val('');\n                    }\n                } else {\n                    return $this.val('');\n                }\n\n                if (!settings.hasFocus && settings.scaleSymbol) {\n                    value = value + settings.scaleSymbol;\n                }\n\n                if ($input) {\n                    return $this.val(value);\n                }\n\n                if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                    return $this.text(value);\n                }\n\n                return false;\n            });\n        },\n\n\n        /**\n         * Method to un-format inputs.\n         * This is handy to use right before form submission.\n         *\n         * By default, values are returned as ISO numeric strings (ie. \"1234.56\" or \"-1234.56\"), where the decimal character is a period.\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\", or even plain numbers.\n         * Please see option \"outputFormat\" for more details\n         *\n         * @example $(someSelector).autoNumeric('unSet');\n         *\n         * @returns {*|jQuery}\n         */\n        unSet: function unSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    settings.hasFocus = true;\n                    $this.val($this.autoNumeric('getLocalized'));\n                }\n            });\n        },\n\n\n        /**\n         * Method to re-format inputs.\n         * This is handy to use right after form submission.\n         *\n         * This is called after the 'unSet' method to reformat the input\n         *\n         * @example $(someSelector).autoNumeric('reSet');\n         *\n         * @returns {*|jQuery}\n         */\n        reSet: function reSet() {\n            return $(this).each(function () {\n                var $this = getCurrentElement(this);\n                var settings = $this.data('autoNumeric');\n                if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) === 'object') {\n                    $this.autoNumeric('set', $this.val());\n                }\n            });\n        },\n\n\n        /**\n         * Return the unformatted value as a string.\n         *\n         * @usage $(someSelector).autoNumeric('get');\n         *\n         * @returns {string}\n         */\n        get: function get() {\n            //TODO Why would we need to get a new reference to $this since it has been done in `init()`?\n            var $this = getCurrentElement(this);\n            //TODO This looks a lot like `getInputIfSupportedTagAndType()`. Is that necessary? Can the input element be changed since autoNumeric has been initialized?\n            var $input = $this.is('input[type=text], input[type=hidden], input[type=tel], input:not([type])');\n            var settings = $this.data('autoNumeric');\n            if ((typeof settings === 'undefined' ? 'undefined' : _typeof(settings)) !== 'object') {\n                throwError('Initializing autoNumeric is required prior to calling the \"get\" method.');\n            }\n\n            // determine the element type then use .eq(0) selector to grab the value of the first element in selector\n            var value = '';\n            if ($input) {\n                value = $this.eq(0).val();\n            } else if (isInArray($this.prop('tagName').toLowerCase(), settings.tagList)) {\n                value = $this.eq(0).text();\n            } else {\n                throwError('The \"<' + $this.prop('tagName').toLowerCase() + '>\" tag is not supported by autoNumeric');\n            }\n\n            if (settings.decimalPlacesShownOnFocus || settings.scaleDivisor) {\n                value = settings.rawValue;\n            } else {\n                // Test if the value is negative\n                var isValueNegative = isNegative(value);\n\n                if (!/\\d/.test(value) && settings.emptyInputBehavior === 'focus') {\n                    return '';\n                }\n\n                if (value !== '' && settings.negativeBracketsTypeOnBlur !== null) {\n                    settings.hasFocus = true;\n                    value = toggleNegativeBracket(value, settings);\n                }\n\n                if (settings.runOnce || settings.formatOnPageLoad === false) {\n                    // Strips trailing negative symbol\n                    value = stripAllNonNumberCharacters(value, settings, true);\n                    // Trims leading and trailing zeros when leadingZero does NOT equal \"keep\".\n                    value = cleanLeadingTrailingZeros(value.replace(settings.decimalCharacter, '.'), settings);\n\n                    // Places the negative symbol in front of the trailing negative\n                    if (settings.trailingNegative && isValueNegative && !isNegative(value) && Number(value) !== 0) {\n                        value = '-' + value;\n                    }\n                }\n\n                if (value !== '' || value === '' && settings.emptyInputBehavior === 'zero') {\n                    value = modifyNegativeSignAndDecimalCharacterForRawValue(value, settings);\n                }\n            }\n\n            // Always return a numeric string\n            // This gets rid of the trailing zeros in the decimal places since `get` does not pad decimals\n            return trimPaddedZerosFromDecimalPlaces(value);\n        },\n\n\n        /**\n         * Returns the unformatted value, but following the `outputFormat` setting, which means the output can either be :\n         * - a string (that could or could not represent a number (ie. \"12345,67-\")), or\n         * - a plain number (if the setting 'number' is used).\n         *\n         * By default the returned values are an ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period.\n         * Check the \"outputFormat\" option definition for more details.\n         *\n         * @usage $(someSelector).autoNumeric('getLocalized');\n         *\n         * @returns {*}\n         */\n        getLocalized: function getLocalized() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n            var settings = $this.data('autoNumeric');\n\n            if (Number(value) === 0 && settings.leadingZero !== 'keep') {\n                value = '0';\n            }\n\n            return toLocale(value, settings.outputFormat);\n        },\n\n\n        /**\n         * Return the input unformatted value as a real Javascript number.\n         *\n         * @usage $(someSelector).autoNumeric('getNumber');\n         *\n         * @returns {number}\n         */\n        getNumber: function getNumber() {\n            var $this = getCurrentElement(this);\n            var value = $this.autoNumeric('get');\n\n            return toLocale(value, 'number');\n        },\n\n\n        /**\n         * Return the current formatted value of the autoNumeric element.\n         * @usage aNInput.autoNumeric('getFormatted'))\n         *\n         * @returns {string}\n         */\n        getFormatted: function getFormatted() {\n            // Make sure `this[0]` exists as well as `.value` before trying to access that property\n            if (!this.hasOwnProperty('0') || !('value' in this[0])) {\n                throwError('Unable to get the formatted string from the element.');\n            }\n\n            return this[0].value;\n        },\n\n\n        /**\n         * The \"getString\" method uses jQuery's .serialize() method that creates a text string in standard URL-encoded notation.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {string}\n         */\n        getString: function getString() {\n            return _getStringOrArray(false, this);\n        },\n\n\n        /**\n         * The \"getArray\" method on the other hand uses jQuery's .serializeArray() method that creates array or objects that can be encoded as a JSON string.\n         *\n         * It then loops through the string and un-formats the inputs with autoNumeric.\n         * By defaults values returned as ISO numeric string \"1234.56\" or \"-1234.56\" where the decimal character is a period\n         * Locale formats are supported \"1234.56-\" or \"1234,56\" or \"-1234,56 or \"1234,56-\" or plain numbers => please see option \"outputFormat\" for details\n         *\n         * @returns {{}|[]}\n         */\n        getArray: function getArray() {\n            return _getStringOrArray(true, this);\n        },\n\n\n        /**\n         * The 'getSettings' function returns an object containing all the current autoNumeric settings.\n         *\n         * @example\n         * $(someSelector).autoNumeric('getSettings');\n         * $(someSelector).autoNumeric('getSettings').decimalCharacter; // Return the decimalCharacter setting as a string - any valid option name can be used\n         *\n         * @returns {object}\n         */\n        getSettings: function getSettings() {\n            //TODO Add an option argument `optionName` to this function so that it return only the value of that option, not the entire settings object\n            return this.data('autoNumeric');\n        }\n    };\n\n    /**\n     * The autoNumeric function accepts methods names (in string format) and those method parameters if needed.\n     * It initialize autoNumeric on the given element.\n     *\n     * @param {string} method The method name (ie. 'set', 'get', etc.)\n     * @param {*} args\n     * @returns {*}\n     */\n    $.fn.autoNumeric = function (method) {\n        if (methods[method]) {\n            for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n                args[_key - 1] = arguments[_key];\n            }\n\n            return methods[method].apply(this, args);\n        }\n\n        if ((typeof method === 'undefined' ? 'undefined' : _typeof(method)) === 'object' || !method) {\n            // The options have been passed directly, without using a named method\n            return methods.init.apply(this, [method]);\n        }\n\n        throwError('Method \"' + method + '\" is not supported by autoNumeric');\n    };\n\n    /**\n     * Return the default autoNumeric settings.\n     *\n     * @returns {object}\n     */\n    getDefaultConfig = function getDefaultConfig() {\n        return defaultSettings;\n    };\n\n    $.fn.autoNumeric.defaults = defaultSettings; // Make those settings public via jQuery too.\n\n    /**\n     * Return all the predefined language options in one object.\n     * You can also access a specific language object directly by using `an.getLanguages().French` for instance.\n     *\n     * @returns {object}\n     */\n    getLanguages = function getLanguages() {\n        return languageOption;\n    };\n\n    $.fn.autoNumeric.lang = languageOption; // Make those predefined language options public via jQuery too.\n\n    /**\n     * Public function that allows formatting without an element trigger.\n     *\n     * @param {number|string} value A number, or a string that represent a javascript number\n     * @param {object|null} options\n     * @returns {*}\n     */\n    autoFormat = function autoFormat(value) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        if (!isString(value) && !isNumber(value)) {\n            throwError('The value \"' + value + '\" being \"set\" is not numeric and therefore cannot be used appropriately.');\n        }\n\n        // Initiate a very basic settings object\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        if (value < 0) {\n            settings.negativeSignCharacter = '-';\n        }\n\n        if (isNull(settings.decimalPlacesOverride)) {\n            settings.decimalPlacesOverride = maximumVMinAndVMaxDecimalLength(settings.minimumValue, settings.maximumValue);\n        }\n\n        // Check the validity of the `value` parameter\n        // Convert the value to a numeric string, stripping unnecessary characters in the process\n        var valueString = toNumericValue(value, settings);\n        if (isNaN(valueString)) {\n            throwError('The value [' + valueString + '] that you are trying to format is not a recognized number.');\n        }\n\n        // Basic tests to check if the given valueString is valid\n\n        var _checkIfInRangeWithOv7 = checkIfInRangeWithOverrideOption(valueString, settings),\n            _checkIfInRangeWithOv8 = _slicedToArray(_checkIfInRangeWithOv7, 2),\n            minTest = _checkIfInRangeWithOv8[0],\n            maxTest = _checkIfInRangeWithOv8[1];\n\n        if (!minTest || !maxTest) {\n            // Throw a custom event\n            triggerEvent('autoFormat.autoNumeric', document, 'Range test failed');\n            throwError('The value [' + valueString + '] being set falls outside of the minimumValue [' + settings.minimumValue + '] and maximumValue [' + settings.maximumValue + '] range set for this element');\n        }\n\n        // Everything is ok, proceed to rounding, formatting and grouping\n        valueString = roundValue(valueString, settings);\n        valueString = modifyNegativeSignAndDecimalCharacterForFormattedValue(valueString, settings);\n        valueString = addGroupSeparators(valueString, settings);\n\n        return valueString;\n    };\n\n    $.fn.autoFormat = autoFormat; // The jQuery export\n\n    /**\n     * Public function that allows unformatting without an element.\n     *\n     * @param {string|number} value\n     * @param {object} options\n     * @returns {*}\n     */\n    autoUnFormat = function autoUnFormat(value, options) {\n        if (isUndefined(value) || value === null) {\n            return null;\n        }\n\n        // Giving an unformatted value should return the same unformatted value, whatever the options passed as a parameter\n        if (isNumber(value)) {\n            return Number(value);\n        }\n\n        if (isArray(value) || isObject(value)) {\n            //TODO Complete the test to throw when given a wrongly formatted number (ie. 'foobar')\n            // Check the validity of the `value` parameter\n            throwError('A number or a string representing a number is needed to be able to unformat it, [' + value + '] given.');\n        }\n\n        var settings = $.extend({}, defaultSettings, { strip: false }, options);\n        var allowed = '-0123456789\\\\' + settings.decimalCharacter;\n        var autoStrip = new RegExp('[^' + allowed + ']', 'gi');\n        value = value.toString();\n\n        // This checks is a negative sign is anywhere in the `value`, not just on the very first character (ie. '12345.67-')\n        if (isNegative(value)) {\n            settings.negativeSignCharacter = '-';\n        } else if (settings.negativeBracketsTypeOnBlur && settings.negativeBracketsTypeOnBlur.split(',')[0] === value.charAt(0)) {\n            settings.negativeSignCharacter = '-';\n            settings.hasFocus = true;\n            value = toggleNegativeBracket(value, settings);\n        }\n\n        value = value.replace(autoStrip, '');\n        value = value.replace(settings.decimalCharacter, '.');\n        value = toLocale(value, settings.outputFormat);\n\n        return value;\n    };\n\n    $.fn.autoUnformat = autoUnFormat; // The jQuery export\n\n    /**\n     * Validate the given option object.\n     * If the options are valid, this function returns nothing, otherwise if the options are invalid, this function throws an error.\n     *\n     * This tests if the options are not conflicting and are well formatted.\n     * This function is lenient since it only tests the settings properties ; it ignores any other properties the options object could have.\n     *\n     * @param {*} userOptions\n     * @param {Boolean} shouldExtendDefaultOptions If TRUE, then this function will extends the `userOptions` passed by the user, with the default options.\n     * @throws Error\n     */\n    validate = function validate(userOptions) {\n        var shouldExtendDefaultOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n        if (isUndefinedOrNullOrEmpty(userOptions) || !isObject(userOptions) || isEmptyObj(userOptions)) {\n            throwError('The userOptions are invalid ; it should be a valid object, [' + userOptions + '] given.');\n        }\n\n        // If the user used old options, we convert them to new ones\n        if (!isNull(userOptions)) {\n            convertOldOptionsToNewOnes(userOptions);\n        }\n\n        // The user can choose if the `userOptions` has already been extended with the default options, or not\n        var options = void 0;\n        if (shouldExtendDefaultOptions) {\n            options = $.extend({}, defaultSettings, userOptions);\n        } else {\n            options = userOptions;\n        }\n\n        // First things first, we test that the `showWarnings` option is valid\n        if (!isTrueOrFalseString(options.showWarnings) && !isBoolean(options.showWarnings)) {\n            throwError('The debug option \\'showWarnings\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showWarnings + '] given.');\n        }\n\n        // Define the regular expressions needed for the following tests\n        var testPositiveInteger = /^[0-9]+$/;\n        var testNumericalCharacters = /[0-9]+/;\n        // const testFloatAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)$/;\n        var testFloatOrIntegerAndPossibleNegativeSign = /^-?[0-9]+(\\.?[0-9]+)?$/;\n        var testPositiveFloatOrInteger = /^[0-9]+(\\.?[0-9]+)?$/;\n\n        // Then tests the options individually\n        if (!isInArray(options.digitGroupSeparator, [',', // Comma\n        '.', // Dot\n        ' ', // Normal space\n        '\\u2009', // Thin-space\n        '\\u202F', // Narrow no-break space\n        '\\xA0', // No-break space\n        '', // No separator\n        \"'\", // Apostrophe\n        '', // Arabic thousands separator\n        ''])) {\n            throwError('The thousand separator character option \\'digitGroupSeparator\\' is invalid ; it should be \\',\\', \\'.\\', \\'\\u066C\\', \\'\\u02D9\\', \"\\'\", \\' \\', \\'\\u2009\\', \\'\\u202F\\', \\'\\xA0\\' or empty (\\'\\'), [' + options.digitGroupSeparator + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.noSeparatorOnFocus) && !isBoolean(options.noSeparatorOnFocus)) {\n            throwError('The \\'noSeparatorOnFocus\\' option is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.noSeparatorOnFocus + '] given.');\n        }\n\n        if (!testPositiveInteger.test(options.digitalGroupSpacing)) {\n            throwError('The digital grouping for thousand separator option \\'digitalGroupSpacing\\' is invalid ; it should be a positive integer, [' + options.digitalGroupSpacing + '] given.');\n        }\n\n        if (!isInArray(options.decimalCharacter, [',', // Comma\n        '.', // Dot\n        '', // Middle-dot\n        '', // Arabic decimal separator\n        ''])) {\n            throwError('The decimal separator character option \\'decimalCharacter\\' is invalid ; it should be \\'.\\', \\',\\', \\'\\xB7\\', \\'\\u2396\\' or \\'\\u066B\\', [' + options.decimalCharacter + '] given.');\n        }\n\n        // Checks if the decimal and thousand characters are the same\n        if (options.decimalCharacter === options.digitGroupSeparator) {\n            throwError('autoNumeric will not function properly when the decimal character \\'decimalCharacter\\' [' + options.decimalCharacter + '] and the thousand separator \\'digitGroupSeparator\\' [' + options.digitGroupSeparator + '] are the same character.');\n        }\n\n        if (!isNull(options.decimalCharacterAlternative) && !isString(options.decimalCharacterAlternative)) {\n            throwError('The alternate decimal separator character option \\'decimalCharacterAlternative\\' is invalid ; it should be a string, [' + options.decimalCharacterAlternative + '] given.');\n        }\n\n        if (options.currencySymbol !== '' && !isString(options.currencySymbol)) {\n            throwError('The currency symbol option \\'currencySymbol\\' is invalid ; it should be a string, [' + options.currencySymbol + '] given.');\n        }\n\n        if (!isInArray(options.currencySymbolPlacement, ['p', 's'])) {\n            throwError('The placement of the currency sign option \\'currencySymbolPlacement\\' is invalid ; it should either be \\'p\\' (prefix) or \\'s\\' (suffix), [' + options.currencySymbolPlacement + '] given.');\n        }\n\n        if (!isInArray(options.negativePositiveSignPlacement, ['p', 's', 'l', 'r', null])) {\n            throwError('The placement of the negative sign option \\'negativePositiveSignPlacement\\' is invalid ; it should either be \\'p\\' (prefix), \\'s\\' (suffix), \\'l\\' (left), \\'r\\' (right) or \\'null\\', [' + options.negativePositiveSignPlacement + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.showPositiveSign) && !isBoolean(options.showPositiveSign)) {\n            throwError('The show positive sign option \\'showPositiveSign\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.showPositiveSign + '] given.');\n        }\n\n        if (!isString(options.suffixText) || options.suffixText !== '' && (isNegative(options.suffixText) || testNumericalCharacters.test(options.suffixText))) {\n            throwError('The additional suffix option \\'suffixText\\' is invalid ; it should not contains the negative sign \\'-\\' nor any numerical characters, [' + options.suffixText + '] given.');\n        }\n\n        if (!isNull(options.overrideMinMaxLimits) && !isInArray(options.overrideMinMaxLimits, ['ceiling', 'floor', 'ignore'])) {\n            throwError('The override min & max limits option \\'overrideMinMaxLimits\\' is invalid ; it should either be \\'ceiling\\', \\'floor\\' or \\'ignore\\', [' + options.overrideMinMaxLimits + '] given.');\n        }\n\n        if (!isString(options.maximumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.maximumValue)) {\n            throwError('The maximum possible value option \\'maximumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.maximumValue + '] given.');\n        }\n\n        if (!isString(options.minimumValue) || !testFloatOrIntegerAndPossibleNegativeSign.test(options.minimumValue)) {\n            throwError('The minimum possible value option \\'minimumValue\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.minimumValue + '] given.');\n        }\n\n        if (parseFloat(options.minimumValue) > parseFloat(options.maximumValue)) {\n            throwError('The minimum possible value option is greater than the maximum possible value option ; \\'minimumValue\\' [' + options.minimumValue + '] should be smaller than \\'maximumValue\\' [' + options.maximumValue + '].');\n        }\n\n        if (!(isNull(options.decimalPlacesOverride) || isInt(options.decimalPlacesOverride) && options.decimalPlacesOverride >= 0 || // If integer option\n        isString(options.decimalPlacesOverride) && testPositiveInteger.test(options.decimalPlacesOverride)) // If string option\n        ) {\n                throwError('The maximum number of decimal places option \\'decimalPlacesOverride\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesOverride + '] given.');\n            }\n\n        // Write a warning message in the console if the number of decimal in minimumValue/maximumValue is overridden by decimalPlacesOverride (and not if decimalPlacesOverride is equal to the number of decimal used in minimumValue/maximumValue)\n        var vMinAndVMaxMaximumDecimalPlaces = maximumVMinAndVMaxDecimalLength(options.minimumValue, options.maximumValue);\n        if (!isNull(options.decimalPlacesOverride) && vMinAndVMaxMaximumDecimalPlaces !== Number(options.decimalPlacesOverride)) {\n            warning('Setting \\'decimalPlacesOverride\\' to [' + options.decimalPlacesOverride + '] will override the decimals declared in \\'minimumValue\\' [' + options.minimumValue + '] and \\'maximumValue\\' [' + options.maximumValue + '].', options.showWarnings);\n        }\n\n        if (!options.allowDecimalPadding && !isNull(options.decimalPlacesOverride)) {\n            warning('Setting \\'allowDecimalPadding\\' to [false] will override the current \\'decimalPlacesOverride\\' setting [' + options.decimalPlacesOverride + '].', options.showWarnings);\n        }\n\n        if (!isNull(options.decimalPlacesShownOnFocus) && (!isString(options.decimalPlacesShownOnFocus) || !testPositiveInteger.test(options.decimalPlacesShownOnFocus))) {\n            throwError('The number of expanded decimal places option \\'decimalPlacesShownOnFocus\\' is invalid ; it should be a positive integer, [' + options.decimalPlacesShownOnFocus + '] given.');\n        }\n\n        // Checks if the extended decimal places \"decimalPlacesShownOnFocus\" is greater than the normal decimal places \"decimalPlacesOverride\"\n        if (!isNull(options.decimalPlacesShownOnFocus) && !isNull(options.decimalPlacesOverride) && Number(options.decimalPlacesOverride) > Number(options.decimalPlacesShownOnFocus)) {\n            warning('The extended decimal places \\'decimalPlacesShownOnFocus\\' [' + options.decimalPlacesShownOnFocus + '] should be greater than the \\'decimalPlacesOverride\\' [' + options.decimalPlacesOverride + '] value. Currently, this will limit the ability of your client to manually change some of the decimal places. Do you really want to do that?', options.showWarnings);\n        }\n\n        if (!isNull(options.scaleDivisor) && !testPositiveFloatOrInteger.test(options.scaleDivisor)) {\n            throwError('The scale divisor option \\'scaleDivisor\\' is invalid ; it should be a positive number, preferably an integer, [' + options.scaleDivisor + '] given.');\n        }\n\n        if (!isNull(options.scaleDecimalPlaces) && !testPositiveInteger.test(options.scaleDecimalPlaces)) {\n            throwError('The scale number of decimals option \\'scaleDecimalPlaces\\' is invalid ; it should be a positive integer, [' + options.scaleDecimalPlaces + '] given.');\n        }\n\n        if (!isNull(options.scaleSymbol) && !isString(options.scaleSymbol)) {\n            throwError('The scale symbol option \\'scaleSymbol\\' is invalid ; it should be a string, [' + options.scaleSymbol + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.saveValueToSessionStorage) && !isBoolean(options.saveValueToSessionStorage)) {\n            throwError('The save to session storage option \\'saveValueToSessionStorage\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.saveValueToSessionStorage + '] given.');\n        }\n\n        if (!isInArray(options.onInvalidPaste, ['error', 'ignore', 'clamp', 'truncate', 'replace'])) {\n            throwError('The paste behavior option \\'onInvalidPaste\\' is invalid ; it should either be \\'error\\', \\'ignore\\', \\'clamp\\', \\'truncate\\' or \\'replace\\' (cf. documentation), [' + options.onInvalidPaste + '] given.');\n        }\n\n        if (!isInArray(options.roundingMethod, ['S', 'A', 's', 'a', 'B', 'U', 'D', 'C', 'F', 'N05', 'CHF', 'U05', 'D05'])) {\n            throwError('The rounding method option \\'roundingMethod\\' is invalid ; it should either be \\'S\\', \\'A\\', \\'s\\', \\'a\\', \\'B\\', \\'U\\', \\'D\\', \\'C\\', \\'F\\', \\'N05\\', \\'CHF\\', \\'U05\\' or \\'D05\\' (cf. documentation), [' + options.roundingMethod + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.allowDecimalPadding) && !isBoolean(options.allowDecimalPadding)) {\n            throwError('The control decimal padding option \\'allowDecimalPadding\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.allowDecimalPadding + '] given.');\n        }\n\n        if (!isNull(options.negativeBracketsTypeOnBlur) && !isInArray(options.negativeBracketsTypeOnBlur, ['(,)', '[,]', '<,>', '{,}'])) {\n            throwError('The brackets for negative values option \\'negativeBracketsTypeOnBlur\\' is invalid ; it should either be \\'(,)\\', \\'[,]\\', \\'<,>\\' or \\'{,}\\', [' + options.negativeBracketsTypeOnBlur + '] given.');\n        }\n\n        if (!isInArray(options.emptyInputBehavior, ['focus', 'press', 'always', 'zero'])) {\n            throwError('The display on empty string option \\'emptyInputBehavior\\' is invalid ; it should either be \\'focus\\', \\'press\\', \\'always\\' or \\'zero\\', [' + options.emptyInputBehavior + '] given.');\n        }\n\n        if (!isInArray(options.leadingZero, ['allow', 'deny', 'keep'])) {\n            throwError('The leading zero behavior option \\'leadingZero\\' is invalid ; it should either be \\'allow\\', \\'deny\\' or \\'keep\\', [' + options.leadingZero + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.formatOnPageLoad) && !isBoolean(options.formatOnPageLoad)) {\n            throwError('The format on initialization option \\'formatOnPageLoad\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.formatOnPageLoad + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.selectNumberOnly) && !isBoolean(options.selectNumberOnly)) {\n            throwError('The select number only option \\'selectNumberOnly\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.selectNumberOnly + '] given.');\n        }\n\n        if (!isNull(options.defaultValueOverride) && options.defaultValueOverride !== '' && !testFloatOrIntegerAndPossibleNegativeSign.test(options.defaultValueOverride)) {\n            throwError('The unformatted default value option \\'defaultValueOverride\\' is invalid ; it should be a string that represents a positive or negative number, [' + options.defaultValueOverride + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.unformatOnSubmit) && !isBoolean(options.unformatOnSubmit)) {\n            throwError('The remove formatting on submit option \\'unformatOnSubmit\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.unformatOnSubmit + '] given.');\n        }\n\n        if (!isNull(options.outputFormat) && !isInArray(options.outputFormat, ['string', 'number', '.', '-.', ',', '-,', '.-', ',-'])) {\n            throwError('The custom locale format option \\'outputFormat\\' is invalid ; it should either be null, \\'string\\', \\'number\\', \\'.\\', \\'-.\\', \\',\\', \\'-,\\', \\'.-\\' or \\',-\\', [' + options.outputFormat + '] given.');\n        }\n\n        if (!isTrueOrFalseString(options.failOnUnknownOption) && !isBoolean(options.failOnUnknownOption)) {\n            throwError('The debug option \\'failOnUnknownOption\\' is invalid ; it should be either \\'false\\' or \\'true\\', [' + options.failOnUnknownOption + '] given.');\n        }\n    };\n\n    $.fn.autoValidate = validate;\n\n    /**\n     * Return TRUE is the settings/options are valid, FALSE otherwise.\n     *\n     * @param {object} options\n     * @returns {boolean}\n     */\n    areSettingsValid = function areSettingsValid(options) {\n        var isValid = true;\n        try {\n            validate(options);\n        } catch (error) {\n            isValid = false;\n        }\n\n        return isValid;\n    };\n\n    /**\n     * Take an arabic number as a string and return a javascript number.\n     * By default, this function does not try to convert the arabic decimal and thousand separator characters.\n     * This returns `NaN` is the conversion is not possible.\n     * Based on http://stackoverflow.com/a/17025392/2834898\n     *\n     * @param {string} arabicNumbers\n     * @param {boolean} returnANumber If `true`, return a Number, otherwise return a String\n     * @param {boolean} parseDecimalCharacter\n     * @param {boolean} parseThousandSeparator\n     * @returns {string|number|NaN}\n     */\n    function arabicToLatinNumbers(arabicNumbers) {\n        var returnANumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        var parseDecimalCharacter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var parseThousandSeparator = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n        var result = arabicNumbers.toString();\n        if (result === '') {\n            return arabicNumbers;\n        }\n\n        if (parseDecimalCharacter) {\n            result = result.replace(//, '.'); // Decimal character\n        }\n\n        if (parseThousandSeparator) {\n            result = result.replace(//g, ''); // Thousand separator\n        }\n\n        // Replace the numbers only\n        result = result.replace(/[]/g, function (d) {\n            return d.charCodeAt(0) - 1632;\n        }) // Arabic numbers\n        .replace(/[]/g, function (d) {\n            return d.charCodeAt(0) - 1776;\n        }); // Persian numbers\n\n        // `NaN` has precedence over the string `'NaN'`\n        var resultAsNumber = Number(result);\n        if (isNaN(resultAsNumber)) {\n            return resultAsNumber;\n        }\n\n        if (returnANumber) {\n            result = resultAsNumber;\n        }\n\n        return result;\n    }\n\n    /**\n     * Create a custom event and immediately sent it from the given element.\n     * By default, if no element is given, the event is thrown from `document`.\n     *\n     * @param {string} eventName\n     * @param {Element} element\n     * @param {object} detail\n     */\n    function triggerEvent(eventName) {\n        var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n        var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n        var event = void 0;\n        if (window.CustomEvent) {\n            event = new CustomEvent(eventName, { detail: detail, bubbles: false, cancelable: false }); // This is not supported by default by IE ; We use the polyfill for IE9 and later.\n        } else {\n            event = document.createEvent('CustomEvent');\n            event.initCustomEvent(eventName, true, true, { detail: detail });\n        }\n\n        element.dispatchEvent(event);\n    }\n\n    /**\n     * Polyfill from https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/CustomEvent for obsolete browsers (IE)\n     */\n    (function () {\n        if (typeof window.CustomEvent === 'function') {\n            return false;\n        }\n\n        function CustomEvent(event, params) {\n            params = params || { bubbles: false, cancelable: false, detail: void 0 };\n            var evt = document.createEvent('CustomEvent');\n            evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);\n            return evt;\n        }\n\n        CustomEvent.prototype = window.Event.prototype;\n        window.CustomEvent = CustomEvent;\n    })();\n});\n\n/**\n * This exports the interface for the autoNumeric object\n */\nexports.default = {\n    format: autoFormat,\n    unFormat: autoUnFormat,\n    getDefaultConfig: getDefaultConfig,\n    getLanguages: getLanguages,\n    validate: validate, // an.validate(options) : throws if necessary\n    areSettingsValid: areSettingsValid };\n}.call(window));//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXV0b051bWVyaWMuanM/YTRlZSJdLCJuYW1lcyI6WyJhdXRvRm9ybWF0IiwiYXV0b1VuRm9ybWF0IiwiZ2V0RGVmYXVsdENvbmZpZyIsImdldExhbmd1YWdlcyIsInZhbGlkYXRlIiwiYXJlU2V0dGluZ3NWYWxpZCIsImFsbG93ZWRUYWdMaXN0IiwiZGVmYXVsdFNldHRpbmdzIiwiZGlnaXRHcm91cFNlcGFyYXRvciIsIm5vU2VwYXJhdG9yT25Gb2N1cyIsImRpZ2l0YWxHcm91cFNwYWNpbmciLCJkZWNpbWFsQ2hhcmFjdGVyIiwiZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlIiwiY3VycmVuY3lTeW1ib2wiLCJjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCIsIm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50Iiwic2hvd1Bvc2l0aXZlU2lnbiIsInN1ZmZpeFRleHQiLCJvdmVycmlkZU1pbk1heExpbWl0cyIsIm1heGltdW1WYWx1ZSIsIm1pbmltdW1WYWx1ZSIsImRlY2ltYWxQbGFjZXNPdmVycmlkZSIsImRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMiLCJzY2FsZURpdmlzb3IiLCJzY2FsZURlY2ltYWxQbGFjZXMiLCJzY2FsZVN5bWJvbCIsInNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UiLCJvbkludmFsaWRQYXN0ZSIsInJvdW5kaW5nTWV0aG9kIiwiYWxsb3dEZWNpbWFsUGFkZGluZyIsIm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyIiwiZW1wdHlJbnB1dEJlaGF2aW9yIiwibGVhZGluZ1plcm8iLCJmb3JtYXRPblBhZ2VMb2FkIiwic2VsZWN0TnVtYmVyT25seSIsImRlZmF1bHRWYWx1ZU92ZXJyaWRlIiwidW5mb3JtYXRPblN1Ym1pdCIsIm91dHB1dEZvcm1hdCIsInNob3dXYXJuaW5ncyIsImZhaWxPblVua25vd25PcHRpb24iLCJrZXlDb2RlIiwiQmFja3NwYWNlIiwiVGFiIiwiRW50ZXIiLCJTaGlmdCIsIkN0cmwiLCJBbHQiLCJQYXVzZUJyZWFrIiwiQ2Fwc0xvY2siLCJFc2MiLCJTcGFjZSIsIlBhZ2VVcCIsIlBhZ2VEb3duIiwiRW5kIiwiSG9tZSIsIkxlZnRBcnJvdyIsIlVwQXJyb3ciLCJSaWdodEFycm93IiwiRG93bkFycm93IiwiSW5zZXJ0IiwiRGVsZXRlIiwibnVtMCIsIm51bTEiLCJudW0yIiwibnVtMyIsIm51bTQiLCJudW01IiwibnVtNiIsIm51bTciLCJudW04IiwibnVtOSIsImEiLCJiIiwiYyIsImQiLCJlIiwiZiIsImciLCJoIiwiaSIsImoiLCJrIiwibCIsIm0iLCJuIiwibyIsInAiLCJxIiwiciIsInMiLCJ0IiwidSIsInYiLCJ3IiwieCIsInkiLCJ6IiwiV2luZG93cyIsIlJpZ2h0Q2xpY2siLCJudW1wYWQwIiwibnVtcGFkMSIsIm51bXBhZDIiLCJudW1wYWQzIiwibnVtcGFkNCIsIm51bXBhZDUiLCJudW1wYWQ2IiwibnVtcGFkNyIsIm51bXBhZDgiLCJudW1wYWQ5IiwiTXVsdGlwbHlOdW1wYWQiLCJQbHVzTnVtcGFkIiwiTWludXNOdW1wYWQiLCJEb3ROdW1wYWQiLCJTbGFzaE51bXBhZCIsIkYxIiwiRjIiLCJGMyIsIkY0IiwiRjUiLCJGNiIsIkY3IiwiRjgiLCJGOSIsIkYxMCIsIkYxMSIsIkYxMiIsIk51bUxvY2siLCJTY3JvbGxMb2NrIiwiTXlDb21wdXRlciIsIk15Q2FsY3VsYXRvciIsIlNlbWljb2xvbiIsIkVxdWFsIiwiQ29tbWEiLCJIeXBoZW4iLCJEb3QiLCJTbGFzaCIsIkJhY2txdW90ZSIsIkxlZnRCcmFja2V0IiwiQmFja3NsYXNoIiwiUmlnaHRCcmFja2V0IiwiUXVvdGUiLCJDb21tYW5kIiwia2V5TmFtZSIsIlVuaWRlbnRpZmllZCIsIkFsdEdyIiwiRm4iLCJGbkxvY2siLCJIeXBlciIsIk1ldGEiLCJTdXBlciIsIlN5bWJvbCIsIlN5bWJvbExvY2siLCJDbGVhciIsIkNvcHkiLCJDclNlbCIsIkN1dCIsIkVyYXNlRW9mIiwiRXhTZWwiLCJQYXN0ZSIsIlJlZG8iLCJVbmRvIiwiQWNjZXB0IiwiQWdhaW4iLCJBdHRuIiwiQ2FuY2VsIiwiQ29udGV4dE1lbnUiLCJFeGVjdXRlIiwiRmluZCIsIkZpbmlzaCIsIkhlbHAiLCJQYXVzZSIsIlBsYXkiLCJQcm9wcyIsIlNlbGVjdCIsIlpvb21JbiIsIlpvb21PdXQiLCJCcmlnaHRuZXNzRG93biIsIkJyaWdodG5lc3NVcCIsIkVqZWN0IiwiTG9nT2ZmIiwiUG93ZXIiLCJQb3dlck9mZiIsIlByaW50U2NyZWVuIiwiSGliZXJuYXRlIiwiU3RhbmRieSIsIldha2VVcCIsIkNvbXBvc2UiLCJEZWFkIiwiUHJpbnQiLCJNaW51cyIsIlBsdXMiLCJkZWZhdWx0TWluaW11bVZhbHVlIiwiZGVmYXVsdE1heGltdW1WYWx1ZSIsImRlZmF1bHRSb3VuZGluZ01ldGhvZCIsImRlZmF1bHRMZWFkaW5nWmVybyIsImRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5IiwibGFuZ3VhZ2VPcHRpb24iLCJGcmVuY2giLCJOb3J0aEFtZXJpY2FuIiwiQnJpdGlzaCIsIlN3aXNzIiwiSmFwYW5lc2UiLCJTcGFuaXNoIiwiQ2hpbmVzZSIsImZhY3RvcnkiLCJkZWZpbmUiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSIsIndpbmRvdyIsImpRdWVyeSIsImlzTnVsbCIsInZhbHVlIiwiaXNVbmRlZmluZWQiLCJpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkiLCJpc1N0cmluZyIsInN0ciIsIlN0cmluZyIsImlzQm9vbGVhbiIsImlzVHJ1ZU9yRmFsc2VTdHJpbmciLCJsb3dlcmNhc2VWYWx1ZSIsInRvTG93ZXJDYXNlIiwiaXNPYmplY3QiLCJyZWZlcmVuY2UiLCJBcnJheSIsImlzQXJyYXkiLCJpc0VtcHR5T2JqIiwib2JqIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiaXNOdW1iZXIiLCJpc05hTiIsInBhcnNlRmxvYXQiLCJpc0Zpbml0ZSIsImlzSW50IiwicGFyc2VJbnQiLCJwcmVwYXJlUGFzdGVkVGV4dCIsInRleHQiLCJob2xkZXIiLCJzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMiLCJzZXR0aW5nc0Nsb25lIiwicmVwbGFjZSIsImNvbnRhaW5zIiwibmVlZGxlIiwiaW5kZXhPZiIsImlzSW5BcnJheSIsImFycmF5IiwiYXJyIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwiRXJyb3IiLCJkZWNpbWFsUGxhY2VzIiwic3BsaXQiLCJkZWNpbWFsUGFydCIsImxlbmd0aCIsImtleUNvZGVOdW1iZXIiLCJldmVudCIsIndoaWNoIiwiY2hhcmFjdGVyIiwia2V5IiwiZnJvbUNoYXJDb2RlIiwiY2hlY2tJZkluUmFuZ2UiLCJwYXJzZWRNaW5WYWx1ZSIsInBhcnNlZE1heFZhbHVlIiwicGFyc2VkVmFsdWUiLCJwYXJzZVN0ciIsInRlc3RNaW5NYXgiLCJpc05lZ2F0aXZlIiwibnVtZXJpY1N0cmluZyIsImNoZWNrRXZlcnl3aGVyZSIsImlzTmVnYXRpdmVTdHJpY3QiLCJjaGFyQXQiLCJpc1plcm9Pckhhc05vVmFsdWUiLCJ0ZXN0Iiwic2V0UmF3TmVnYXRpdmVTaWduIiwicmVwbGFjZUNoYXJBdCIsInN0cmluZyIsImluZGV4IiwibmV3Q2hhcmFjdGVyIiwic3Vic3RyIiwiY2xhbXBUb1JhbmdlTGltaXRzIiwic2V0dGluZ3MiLCJNYXRoIiwibWF4IiwibWluIiwiY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlIiwiZm9ybWF0dGVkTnVtYmVyU3RyaW5nIiwiY2FyZXRQb3NpdGlvbiIsIm51bWJlckRvdE9yTmVnYXRpdmVTaWduIiwiUmVnRXhwIiwibnVtYmVyRG90QW5kTmVnYXRpdmVTaWduQ291bnQiLCJmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyIiwicmF3TnVtYmVyU3RyaW5nIiwiY2FyZXRQb3NpdGlvbkluUmF3VmFsdWUiLCJmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplIiwicmF3TnVtYmVyU3RyaW5nU2l6ZSIsImZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4IiwicmF3TnVtYmVyU3RyaW5nSW5kZXgiLCJjb3VudENoYXJJblRleHQiLCJjaGFyQ291bnRlciIsImNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbiIsImNoYXJhY3RlckNvdW50IiwiZ2V0RWxlbWVudFNlbGVjdGlvbiIsInRoYXQiLCJwb3NpdGlvbiIsInNlbGVjdGlvblN0YXJ0IiwiZm9jdXMiLCJzZWxlY3QiLCJkb2N1bWVudCIsInNlbGVjdGlvbiIsImNyZWF0ZVJhbmdlIiwibW92ZVN0YXJ0IiwiZW5kIiwic3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJzZXRFbGVtZW50U2VsZWN0aW9uIiwicmFuZ2UiLCJjcmVhdGVUZXh0UmFuZ2UiLCJjb2xsYXBzZSIsIm1vdmVFbmQiLCJ0aHJvd0Vycm9yIiwibWVzc2FnZSIsIndhcm5pbmciLCJzaG93V2FybmluZyIsImNvbnNvbGUiLCJ3YXJuIiwicnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0IiwiJHRoaXMiLCIkIiwiZWFjaCIsInZhbCIsImF1dG9OdW1lcmljIiwibWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aCIsImxlZnRPckFsbCIsInNraXBGaXJzdEF1dG9TdHJpcCIsInRyYWlsaW5nTmVnYXRpdmUiLCJza2lwTGFzdEF1dG9TdHJpcCIsImFsbG93ZWRBdXRvU3RyaXAiLCJtYXRjaCIsIm51bVJlZ0F1dG9TdHJpcCIsImpvaW4iLCJuU2lnbiIsImludGVnZXJQYXJ0IiwibW9kaWZpZWRJbnRlZ2VyUGFydCIsIm5lZ2F0aXZlU2lnbkNoYXJhY3RlciIsIm1JbnRQb3MiLCJzbGljZSIsIm1JbnROZWciLCJoYXNGb2N1cyIsInN0cmlwUmVnIiwidG9nZ2xlTmVnYXRpdmVCcmFja2V0IiwiZmlyc3RCcmFja2V0IiwibGFzdEJyYWNrZXQiLCJjb252ZXJ0VG9OdW1lcmljU3RyaW5nIiwibGFzdEluZGV4T2YiLCJ0ZW1wIiwiYXJhYmljVG9MYXRpbk51bWJlcnMiLCJ0b0xvY2FsZSIsImxvY2FsZSIsInJlc3VsdCIsIk51bWJlciIsIm1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JSYXdWYWx1ZSIsIm1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSIsImNoZWNrRW1wdHkiLCJpbnB1dFZhbHVlIiwic2lnbk9uRW1wdHkiLCJhZGRHcm91cFNlcGFyYXRvcnMiLCJzdHJpcCIsImVtcHR5IiwiaXNWYWx1ZU5lZ2F0aXZlIiwiaXNaZXJvIiwiZGlnaXRhbEdyb3VwIiwic3Vic3RyaW5nIiwicG9zaXRpdmVTaWduQ2hhcmFjdGVyIiwicmF3VmFsdWUiLCJ0cnVuY2F0ZVplcm9zIiwicm91bmRlZElucHV0VmFsdWUiLCJ0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUiLCJyZWdleCIsInJvdW5kVmFsdWUiLCJyb3VuZCIsImNlaWwiLCJmbG9vciIsIml2Um91bmRlZCIsImRQb3MiLCJpbnB1dFZhbHVlSGFzQURvdCIsInZkUG9zIiwiY0RlYyIsInplcm9zIiwickxlbmd0aCIsInRSb3VuZCIsIm9kZCIsIml2QXJyYXkiLCJ0cnVuY2F0ZURlY2ltYWwiLCJpc1Bhc3RlIiwibW9kaWZpZWREZWNpbWFsUGFydCIsIm5MIiwic2VhcmNoIiwieGMiLCJ5YyIsInhOZWciLCJjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbiIsIm1pblBhcnNlIiwibWF4UGFyc2UiLCJ2YWxQYXJzZSIsImdldEN1cnJlbnRFbGVtZW50IiwiZWxlbWVudCIsImdldEF1dG9OdW1lcmljSG9sZGVyIiwidXBkYXRlIiwiZGF0YSIsIkF1dG9OdW1lcmljSG9sZGVyIiwiZ2V0Iiwia2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkiLCJvRGVjIiwib1BhZCIsIm9CcmFja2V0Iiwib1NlcCIsIm9TaWduIiwib1N1ZmZpeCIsInJlYWRDb29raWUiLCJuYW1lIiwibmFtZUVRIiwiY2EiLCJjb29raWUiLCJzdG9yYWdlVGVzdCIsIm1vZCIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zIiwidHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXMiLCJ0cmltbWVkRGVjaW1hbFBhcnQiLCJzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlIiwiYWN0aW9uIiwic3RvcmVkTmFtZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkIiwiZGF0ZSIsImV4cGlyZXMiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJ0b1VUQ1N0cmluZyIsImdldEl0ZW0iLCIkdGhhdCIsImZvcm1hdHRlZCIsInByb2Nlc3NlZCIsImV2ZW50S2V5Q29kZSIsInNldFJlYWwiLCJwb3MiLCJfc2V0U2VsZWN0aW9uIiwibGVmdCIsInJpZ2h0IiwiX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24iLCJzdHJpcFplcm9zIiwibmV3VmFsdWUiLCJhTmVnUmVnQXV0b1N0cmlwIiwicGFydHMiLCJfbm9ybWFsaXplUGFydHMiLCJtaW5UZXN0IiwibWF4VGVzdCIsInRlc3RWYWx1ZSIsIl9zZXRDYXJldFBvc2l0aW9uIiwidHJpZ2dlciIsImN1cnJlbmN5U3ltYm9sTGVuIiwiaGFzTmVnIiwidmFsdWVMZW4iLCJzaWduUG9zaXRpb24iLCJfZ2V0U2lnblBvc2l0aW9uIiwidmFsdWVQYXJ0c0JlZm9yZVBhc3RlIiwib2xkUGFydHMiLCJtb2RpZmllZExlZnRQYXJ0IiwiX3NldFZhbHVlUGFydHMiLCJjdHJsS2V5IiwibWV0YUtleSIsInR5cGUiLCJzaGlmdEtleSIsIl9jaGVja1Bhc3RlIiwicHJldmVudERlZmF1bHQiLCJuZWdMZW4iLCJzdWZmaXhUZXh0TGVuIiwiX2V4cGFuZFNlbGVjdGlvbk9uU2lnbiIsImNhcmV0Rml4IiwiX2dldFVuZm9ybWF0dGVkTGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbiIsInRocm93SW5wdXQiLCJfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uSWZUcmFpbGluZ05lZ2F0aXZlU2lnbiIsImV2ZW50Q2hhcmFjdGVyIiwiZXZlbnROdW1iZXIiLCJsZWZ0TGVuZ3RoIiwic3ViUGFydHMiLCJsZWZ0QXIiLCJzaGlmdCIsInB1c2giLCJzaWduUGFydHMiLCJlc2NhcGVDaHIiLCJlc2NhcGVkUGFydHMiLCJtaW5pUGFydHMiLCJsZWZ0UmVnIiwibmV3TGVmdCIsImlucHV0IiwiX2dldFN0cmluZ09yQXJyYXkiLCJnZXRBcnJheUJlaGF2aW9yIiwiZm9ybUluZGV4IiwiYWxsRm9ybUVsZW1lbnRzIiwiYWlJbmRleCIsInNjSW5kZXgiLCJyU3VibWl0dGVyVHlwZXMiLCJyU3VibWl0dGFibGUiLCJyQ2hlY2thYmxlVHlwZSIsInJOb25BdXRvTnVtZXJpY1R5cGVzIiwiY291bnQiLCJmaWVsZCIsImxvY2FsTmFtZSIsImRpc2FibGVkIiwiY2hlY2tlZCIsImZvcm1GaWVsZHMiLCJzZXJpYWxpemVBcnJheSIsInNjRWxlbWVudCIsInRlc3RJbnB1dCIsInNlcmlhbGl6ZSIsImZvcm1QYXJ0cyIsImlucHV0TmFtZSIsIm1vZGlmaWVkSW5wdXRWYWx1ZSIsIm9uRm9jdXNJbkFuZE1vdXNlRW50ZXIiLCJpcyIsInRhcmdldCIsInZhbHVlT25Gb2N1cyIsImxhc3RWYWwiLCJvbkVtcHR5Iiwib25LZXlkb3duIiwiX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyRXZlbnRLZXljb2RlIiwiaW5pdGlhbFZhbHVlT25LZXlkb3duIiwicmVhZE9ubHkiLCJ0cmlnZ2VyRXZlbnQiLCJfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzIiwiX3NraXBBbHdheXMiLCJfcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uIiwiX2Zvcm1hdFZhbHVlIiwib25LZXlwcmVzcyIsImlzQ2hhcmFjdGVySW5zZXJ0aW9uQWxsb3dlZCIsIl9wcm9jZXNzQ2hhcmFjdGVySW5zZXJ0aW9uIiwib25LZXl1cCIsInNraXAiLCJvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSIsIm9yaWdWYWx1ZSIsImdyb3VwZWRWYWx1ZSIsImNoYW5nZSIsIm9uUGFzdGUiLCJyYXdQYXN0ZWRUZXh0IiwiY2xpcGJvYXJkRGF0YSIsImdldERhdGEiLCJpbml0aWFsRm9ybWF0dGVkVmFsdWUiLCJzZWxlY3Rpb25TaXplIiwiaXNBbGxJbnB1dFRleHRTZWxlY3RlZCIsImlzUGFzdGVOZWdhdGl2ZSIsInVudHJhbnNsYXRlZFBhc3RlZFRleHQiLCJwYXN0ZWRUZXh0IiwiY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmciLCJpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIiLCJpc0luaXRpYWxWYWx1ZU5lZ2F0aXZlIiwiaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSIsImxlZnRQYXJ0Q29udGFpbmVkQURvdCIsImxlZnRGb3JtYXR0ZWRQYXJ0IiwicmlnaHRGb3JtYXR0ZWRQYXJ0IiwibGVmdFBhcnQiLCJyaWdodFBhcnQiLCJsYXN0R29vZEtub3duUmVzdWx0IiwicGFzdGVkVGV4dEluZGV4IiwibGFzdEdvb2RLbm93blJlc3VsdEluZGV4IiwibGFzdEdvb2RLbm93blJlc3VsdFNpemUiLCJsZWZ0Rm9ybWF0dGVkUGFydDIiLCJyaWdodEZvcm1hdHRlZFBhcnQyIiwiaW5kZXhXaGVyZVBhc3RlZFRleHRIYXNCZWVuSW5zZXJ0ZWQiLCJpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUiLCJzZWxlY3RlZFRleHQiLCJ2YWx1ZUhhc0JlZW5TZXQiLCJ2YWx1ZUhhc0JlZW5DbGFtcGVkIiwiZXJyb3IiLCJjbGFtcGVkVmFsdWUiLCJjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIiLCJvbkJsdXIiLCJvblN1Ym1pdCIsImNsb3Nlc3QiLCJvbiIsIiRzZXR0aW5ncyIsImdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlIiwiJGlucHV0IiwiY3VycmVudEVsZW1lbnRUYWciLCJmb3JtYXREZWZhdWx0VmFsdWVPblBhZ2VMb2FkIiwic2V0VmFsdWUiLCJjdXJyZW50VmFsdWUiLCJ1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSIsInRvTnVtZXJpY1ZhbHVlIiwiYXR0ciIsIkluZmluaXR5IiwidG9TdHJpcCIsInRhZ0xpc3QiLCJjb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24iLCJjYWxjdWxhdGVWTWluQW5kVk1heEludGVnZXJTaXplcyIsIm1heGltdW1WYWx1ZUludGVnZXJQYXJ0IiwibWluaW11bVZhbHVlSW50ZWdlclBhcnQiLCJjb3JyZWN0RGVjaW1hbFBsYWNlc092ZXJyaWRlT3B0aW9uIiwic2V0c0FsdGVybmF0aXZlRGVjaW1hbFNlcGFyYXRvckNoYXJhY3RlciIsImNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zIiwiYWxsTnVtYmVyc1JlZyIsIm5vQWxsTnVtYmVyc1JlZyIsImFOZWdSZWciLCJuZWdhdGl2ZVNpZ25SZWdQYXJ0IiwiYWxsb3dlZCIsInRyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcyIsImNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzIiwib3B0aW9ucyIsIm9sZE9wdGlvbnNDb252ZXJ0ZXIiLCJhU2VwIiwiblNlcCIsImRHcm91cCIsImFEZWMiLCJhbHREZWMiLCJhU2lnbiIsInBTaWduIiwicE5lZyIsImFTdWZmaXgiLCJvTGltaXRzIiwidk1heCIsInZNaW4iLCJtRGVjIiwiZURlYyIsInNjYWxlRGVjaW1hbCIsImFTdG9yIiwibVJvdW5kIiwiYVBhZCIsIm5CcmFja2V0Iiwid0VtcHR5IiwibFplcm8iLCJhRm9ybSIsInNOdW1iZXIiLCJhbkRlZmF1bHQiLCJ1blNldE9uU3VibWl0Iiwib3V0cHV0VHlwZSIsImRlYnVnIiwicnVuT25jZSIsIm9wdGlvbiIsImdldEluaXRpYWxTZXR0aW5ncyIsImV4dGVuZCIsInRhZ0RhdGEiLCJOYU4iLCJtZXRob2RzIiwiaW5pdCIsImFkZEV2ZW50TGlzdGVuZXIiLCJkZXN0cm95IiwicmVtb3ZlRGF0YSIsIm9mZiIsIndpcGUiLCJzZXQiLCJoYXNCZWVuUm91bmRlZCIsInRlbXBEZWNpbWFsIiwib25PZmYiLCJhdHRlbXB0ZWRWYWx1ZSIsInVuU2V0IiwicmVTZXQiLCJlcSIsImdldExvY2FsaXplZCIsImdldE51bWJlciIsImdldEZvcm1hdHRlZCIsImdldFN0cmluZyIsImdldEFycmF5IiwiZ2V0U2V0dGluZ3MiLCJmbiIsIm1ldGhvZCIsImFyZ3MiLCJhcHBseSIsImRlZmF1bHRzIiwibGFuZyIsInZhbHVlU3RyaW5nIiwiYXV0b1N0cmlwIiwiYXV0b1VuZm9ybWF0IiwidXNlck9wdGlvbnMiLCJzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyIsInRlc3RQb3NpdGl2ZUludGVnZXIiLCJ0ZXN0TnVtZXJpY2FsQ2hhcmFjdGVycyIsInRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduIiwidGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIiLCJ2TWluQW5kVk1heE1heGltdW1EZWNpbWFsUGxhY2VzIiwiYXV0b1ZhbGlkYXRlIiwiaXNWYWxpZCIsImFyYWJpY051bWJlcnMiLCJyZXR1cm5BTnVtYmVyIiwicGFyc2VEZWNpbWFsQ2hhcmFjdGVyIiwicGFyc2VUaG91c2FuZFNlcGFyYXRvciIsImNoYXJDb2RlQXQiLCJyZXN1bHRBc051bWJlciIsImV2ZW50TmFtZSIsImRldGFpbCIsIkN1c3RvbUV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJwYXJhbXMiLCJldnQiLCJFdmVudCIsImZvcm1hdCIsInVuRm9ybWF0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThDQTs7QUFFQTtBQUNBLElBQUlBLG1CQUFKO0FBQ0EsSUFBSUMscUJBQUo7QUFDQSxJQUFJQyx5QkFBSjtBQUNBLElBQUlDLHFCQUFKO0FBQ0EsSUFBSUMsaUJBQUo7QUFDQSxJQUFJQyx5QkFBSjs7QUFF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T0osVUFBbEQsRUFBOERJLE9BQU9QLE1BQXJFO0FBQ0EsbUJBQU9RLEdBQVA7QUFDSDs7QUFFRFAsb0JBQVk5YixTQUFaLEdBQXdCeEMsT0FBTzhlLEtBQVAsQ0FBYXRjLFNBQXJDO0FBQ0F4QyxlQUFPc2UsV0FBUCxHQUFxQkEsV0FBckI7QUFDSCxLQWREO0FBZUgsQ0E3OElBLENBQUQ7O0FBKzhJQTs7O2tCQUdlO0FBQ1hTLFlBQVVoc0IsVUFEQztBQUVYaXNCLGNBQVVoc0IsWUFGQztBQUdYQyxzQ0FIVztBQUlYQyw4QkFKVztBQUtYQyxzQkFMVyxFQUtEO0FBQ1ZDLHNDQU5XLEUiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogICAgICAgICAgICAgICBhdXRvTnVtZXJpYy5qc1xuICpcbiAqIEB2ZXJzaW9uICAgICAgMi4wLjhcbiAqIEBkYXRlICAgICAgICAgMjAxNy0wMi0wMSBVVEMgMTk6MzBcbiAqXG4gKiBAYXV0aG9yICAgICAgIEJvYiBLbm90aGVcbiAqIEBjb250cmlidXRvcnMgQWxleGFuZHJlIEJvbm5lYXUsIFNva29sb3YgWXVyYSBhbmQgb3RoZXIgR2l0aHViIHVzZXJzLFxuICogICAgICAgICAgICAgICBjZi4gQVVUSE9SUy5tZC5cbiAqIEBjb3B5cmlnaHQgICAgMjAwOSBSb2JlcnQgSi4gS25vdGhlIGh0dHA6Ly93d3cuZGVjb3JwbGFuaXQuY29tL3BsdWdpbi9cbiAqIEBzaW5jZSAgICAgICAgMjAwOS0wOC0wOVxuICpcbiAqIEBzdW1tYXJ5ICAgICAgYXV0b051bWVyaWMgaXMgYSBsaWJyYXJ5IHRoYXQgcHJvdmlkZXMgbGl2ZSBhcy15b3UtdHlwZVxuICogICAgICAgICAgICAgICBmb3JtYXR0aW5nIGZvciBpbnRlcm5hdGlvbmFsIG51bWJlcnMgYW5kIGN1cnJlbmNpZXMuXG4gKlxuICogICAgICAgICAgICAgICBOb3RlIDogU29tZSBmdW5jdGlvbnMgYXJlIGJvcnJvd2VkIGZyb20gYmlnLmpzXG4gKiBAbGluayAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy9cbiAqXG4gKiBQbGVhc2UgcmVwb3J0IGFueSBidWdzIHRvIGh0dHBzOi8vZ2l0aHViLmNvbS9Cb2JLbm90aGUvYXV0b051bWVyaWNcbiAqXG4gKiBAbGljZW5zZSAgICAgIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogQGxpbmsgICAgICAgICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gKiBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICogZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0XG4gKiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiAqIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YiBsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gKiBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICogY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICogaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbiAqIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICogT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAqIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUXG4gKiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAqIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUlxuICogT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG5cblxuLyogZ2xvYmFsIG1vZHVsZSwgcmVxdWlyZSwgZGVmaW5lICovXG5cbi8vIEZ1bmN0aW9ucyBuYW1lcyBmb3IgRVM2IGV4cG9ydHNcbmxldCBhdXRvRm9ybWF0O1xubGV0IGF1dG9VbkZvcm1hdDtcbmxldCBnZXREZWZhdWx0Q29uZmlnO1xubGV0IGdldExhbmd1YWdlcztcbmxldCB2YWxpZGF0ZTtcbmxldCBhcmVTZXR0aW5nc1ZhbGlkO1xuXG4vLyBBdXRvTnVtZXJpYyBkZWZhdWx0IHNldHRpbmdzXG4vKipcbiAqIExpc3Qgb2YgYWxsb3dlZCB0YWcgb24gd2hpY2ggYXV0b051bWVyaWMgY2FuIGJlIHVzZWQuXG4gKi9cbmNvbnN0IGFsbG93ZWRUYWdMaXN0ID0gW1xuICAgICdiJyxcbiAgICAnY2FwdGlvbicsXG4gICAgJ2NpdGUnLFxuICAgICdjb2RlJyxcbiAgICAnY29uc3QnLFxuICAgICdkZCcsXG4gICAgJ2RlbCcsXG4gICAgJ2RpdicsXG4gICAgJ2RmbicsXG4gICAgJ2R0JyxcbiAgICAnZW0nLFxuICAgICdoMScsXG4gICAgJ2gyJyxcbiAgICAnaDMnLFxuICAgICdoNCcsXG4gICAgJ2g1JyxcbiAgICAnaDYnLFxuICAgICdpbnMnLFxuICAgICdrZGInLFxuICAgICdsYWJlbCcsXG4gICAgJ2xpJyxcbiAgICAnb3B0aW9uJyxcbiAgICAnb3V0cHV0JyxcbiAgICAncCcsXG4gICAgJ3EnLFxuICAgICdzJyxcbiAgICAnc2FtcGxlJyxcbiAgICAnc3BhbicsXG4gICAgJ3N0cm9uZycsXG4gICAgJ3RkJyxcbiAgICAndGgnLFxuICAgICd1Jyxcbl07XG5cbi8qKlxuICogRGVmYXVsdHMgb3B0aW9ucyBhcmUgcHVibGljIC0gdGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGZvbGxvd2luZyBtZXRob2Q6XG4gKiAtIEhUTUw1IGRhdGEgYXR0cmlidXRlcyAoaWUuIGA8aW5wdXQgdHlwZT1cInRleHRcIiBkYXRhLWN1cnJlbmN5LXN5bWJvbD1cIiDigqxcIj5gKVxuICogLSBPcHRpb25zIHBhc3NlZCBieSB0aGUgJ2luaXQnIG9yICd1cGRhdGUnIG1ldGhvZHMgKGllLiBgYU5JbnB1dC5hdXRvTnVtZXJpYygndXBkYXRlJywgeyBjdXJyZW5jeVN5bWJvbDogJyDigqwnIH0pO2ApXG4gKiAtIFVzZSBqUXVlcnkncyBgJC5leHRlbmRgIG1ldGhvZCBmb3IgZ2xvYmFsIGNoYW5nZXMgLSBhbHNvIGEgZ3JlYXQgd2F5IHRvIHBhc3MgQVNQLk5FVCBjdXJyZW50IGN1bHR1cmUgc2V0dGluZ3NcbiAqL1xuY29uc3QgZGVmYXVsdFNldHRpbmdzID0ge1xuICAgIC8qIEFsbG93ZWQgdGhvdXNhbmQgZ3JvdXBpbmcgc2VwYXJhdG9yIGNoYXJhY3RlcnMgOlxuICAgICAqICcsJyAgICAgIC8vIENvbW1hXG4gICAgICogJy4nICAgICAgLy8gRG90XG4gICAgICogJyAnICAgICAgLy8gTm9ybWFsIHNwYWNlXG4gICAgICogJ1xcdTIwMDknIC8vIFRoaW4tc3BhY2VcbiAgICAgKiAnXFx1MjAyZicgLy8gTmFycm93IG5vLWJyZWFrIHNwYWNlXG4gICAgICogJ1xcdTAwYTAnIC8vIE5vLWJyZWFrIHNwYWNlXG4gICAgICogJycgICAgICAgLy8gTm8gc2VwYXJhdG9yXG4gICAgICogXCInXCIgICAgICAvLyBBcG9zdHJvcGhlXG4gICAgICogJ9msJyAgICAgIC8vIEFyYWJpYyB0aG91c2FuZHMgc2VwYXJhdG9yXG4gICAgICogJ8uZJyAgICAgIC8vIERvdCBhYm92ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU2VwXG4gICAgICovXG4gICAgZGlnaXRHcm91cFNlcGFyYXRvcjogJywnLFxuXG4gICAgLyogUmVtb3ZlIHRoZSB0aG91c2FuZCBzZXBhcmF0b3Igb24gZm9jdXMsIGN1cnJlbmN5IHN5bWJvbCBhbmQgc3VmZml4IG9uIGZvY3VzXG4gICAgICogZXhhbXBsZSBpZiB0aGUgaW5wdXQgdmFsdWUgXCIkIDEsOTk5Ljg4IHN1ZmZpeFwiXG4gICAgICogb24gXCJmb2N1c2luXCIgaXQgYmVjb21lcyBcIjE5OTkuODhcIiBhbmQgYmFjayB0byBcIiQgMSw5OTkuODggc3VmZml4XCIgb24gZm9jdXMgb3V0LlxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBuU2VwXG4gICAgICovXG4gICAgbm9TZXBhcmF0b3JPbkZvY3VzOiBmYWxzZSxcblxuICAgIC8qIERpZ2l0YWwgZ3JvdXBpbmcgZm9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3IgdXNlZCBpbiBGb3JtYXRcbiAgICAgKiBkaWdpdGFsR3JvdXBTcGFjaW5nOiBcIjJcIiwgcmVzdWx0cyBpbiA5OSw5OSw5OSw5OTkgSW5kaWEncyBsYWtoc1xuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiMnNcIiwgcmVzdWx0cyBpbiA5OSw5OTksOTksOTksOTk5IEluZGlhJ3MgbGFraHMgc2NhbGVkXG4gICAgICogZGlnaXRhbEdyb3VwU3BhY2luZzogXCIzXCIsIHJlc3VsdHMgaW4gOTk5LDk5OSw5OTkgZGVmYXVsdFxuICAgICAqIGRpZ2l0YWxHcm91cFNwYWNpbmc6IFwiNFwiLCByZXN1bHRzIGluIDk5OTksOTk5OSw5OTk5IHVzZWQgaW4gc29tZSBBc2lhbiBjb3VudHJpZXNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZEdyb3VwXG4gICAgICovXG4gICAgZGlnaXRhbEdyb3VwU3BhY2luZzogJzMnLFxuXG4gICAgLyogQWxsb3dlZCBkZWNpbWFsIHNlcGFyYXRvciBjaGFyYWN0ZXJzIDpcbiAgICAgKiAnLCcgOiBDb21tYVxuICAgICAqICcuJyA6IERvdFxuICAgICAqICfCtycgOiBNaWRkbGUtZG90XG4gICAgICogJ9mrJyA6IEFyYWJpYyBkZWNpbWFsIHNlcGFyYXRvclxuICAgICAqICfijpYnIDogRGVjaW1hbCBzZXBhcmF0b3Iga2V5IHN5bWJvbFxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhRGVjXG4gICAgICovXG4gICAgZGVjaW1hbENoYXJhY3RlcjogJy4nLFxuXG4gICAgLyogQWxsb3cgdG8gZGVjbGFyZSBhbiBhbHRlcm5hdGl2ZSBkZWNpbWFsIHNlcGFyYXRvciB3aGljaCBpcyBhdXRvbWF0aWNhbGx5IHJlcGxhY2VkIGJ5IGBkZWNpbWFsQ2hhcmFjdGVyYCB3aGVuIHR5cGVkLlxuICAgICAqIFRoaXMgaXMgdXNlZCBieSBjb3VudHJpZXMgdGhhdCB1c2UgYSBjb21tYSBcIixcIiBhcyB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgYW5kIGhhdmUga2V5Ym9hcmRzXFxudW1lcmljIHBhZHMgdGhhdCBoYXZlXG4gICAgICogYSBwZXJpb2QgJ2Z1bGwgc3RvcCcgYXMgdGhlIGRlY2ltYWwgY2hhcmFjdGVycyAoRnJhbmNlIG9yIFNwYWluIGZvciBpbnN0YW5jZSkuXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFsdERlY1xuICAgICAqL1xuICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZTogbnVsbCxcblxuICAgIC8qIGN1cnJlbmN5U3ltYm9sID0gYWxsb3dlZCBjdXJyZW5jeSBzeW1ib2xcbiAgICAgKiBNdXN0IGJlIGluIHF1b3RlcyBjdXJyZW5jeVN5bWJvbDogXCIkXCJcbiAgICAgKiBzcGFjZSB0byB0aGUgcmlnaHQgb2YgdGhlIGN1cnJlbmN5IHN5bWJvbCBjdXJyZW5jeVN5bWJvbDogJyQgJ1xuICAgICAqIHNwYWNlIHRvIHRoZSBsZWZ0IG9mIHRoZSBjdXJyZW5jeSBzeW1ib2wgY3VycmVuY3lTeW1ib2w6ICcgJCdcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYVNpZ25cbiAgICAgKi9cbiAgICBjdXJyZW5jeVN5bWJvbDogJycsXG5cbiAgICAvKiBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9IHBsYWNlbWVudCBvZiBjdXJyZW5jeSBzaWduIGFzIGEgcD1wcmVmaXggb3Igcz1zdWZmaXhcbiAgICAgKiBmb3IgcHJlZml4IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInBcIiAoZGVmYXVsdClcbiAgICAgKiBmb3Igc3VmZml4IGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIlxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBwU2lnblxuICAgICAqL1xuICAgIC8vVE9ETyBSZW5hbWUgdGhlIG9wdGlvbnMgdG8gbW9yZSBleHBsaWNpdCBuYW1lcyAoJ3AnID0+ICdwcmVmaXgnLCBldGMuKVxuICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXG5cbiAgICAvKiBQbGFjZW1lbnQgb2YgbmVnYXRpdmUvcG9zaXRpdmUgc2lnbiByZWxhdGl2ZSB0byB0aGUgY3VycmVuY3lTeW1ib2wgb3B0aW9uIGw9bGVmdCwgcj1yaWdodCwgcD1wcmVmaXggJiBzPXN1ZmZpeFxuICAgICAqIC0xLDIzNC41NiAgPT4gZGVmYXVsdCBubyBvcHRpb25zIHJlcXVpcmVkXG4gICAgICogLSQxLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwifSBvciB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJsXCJ9XG4gICAgICogJC0xLDIzNC41NiA9PiB7Y3VycmVuY3lTeW1ib2w6IFwiJFwiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9IC8vIERlZmF1bHQgaWYgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgaXMgJ251bGwnIGFuZCBjdXJyZW5jeVN5bWJvbCBpcyBub3QgZW1wdHlcbiAgICAgKiAtMSwyMzQuNTYkID0+IHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwicFwifSAvLyBEZWZhdWx0IGlmIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50IGlzICdudWxsJyBhbmQgY3VycmVuY3lTeW1ib2wgaXMgbm90IGVtcHR5XG4gICAgICogMSwyMzQuNTYtICA9PiB7bmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwic1wifVxuICAgICAqICQxLDIzNC41Ni0gPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwic1wifVxuICAgICAqIDEsMjM0LjU2LSQgPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wifVxuICAgICAqIDEsMjM0LjU2JC0gPT4ge2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQ6IFwic1wiLCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogXCJyXCJ9XG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHBOZWdcbiAgICAgKi9cbiAgICAvL1RPRE8gUmVuYW1lIHRoZSBvcHRpb25zIHRvIG1vcmUgZXhwbGljaXQgbmFtZXMgKCdwJyA9PiAncHJlZml4JywgZXRjLilcbiAgICBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudDogbnVsbCxcblxuXG4gICAgLyogQWxsb3cgdGhlIHBvc2l0aXZlIHNpZ24gc3ltYm9sIGArYCB0byBiZSBkaXNwbGF5ZWQgZm9yIHBvc2l0aXZlIG51bWJlcnMuXG4gICAgICogQnkgZGVmYXVsdCwgdGhpcyBwb3NpdGl2ZSBzaWduIGlzIG5vdCBzaG93bi5cbiAgICAgKiBUaGUgc2lnbiBwbGFjZW1lbnQgaXMgY29udHJvbGxlZCBieSB0aGUgJ25lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50JyBvcHRpb24sIG1pbWlja2luZyB0aGUgbmVnYXRpdmUgc2lnbiBwbGFjZW1lbnQgcnVsZXMuXG4gICAgICovXG4gICAgc2hvd1Bvc2l0aXZlU2lnbjogZmFsc2UsXG5cbiAgICAvKiBBZGRpdGlvbmFsIHN1ZmZpeFxuICAgICAqIE11c3QgYmUgaW4gcXVvdGVzIHN1ZmZpeFRleHQ6ICdncm9zcycsIGEgc3BhY2UgaXMgYWxsb3dlZCBzdWZmaXhUZXh0OiAnIGRvbGxhcnMnXG4gICAgICogTnVtZXJpYyBjaGFyYWN0ZXJzIGFuZCBuZWdhdGl2ZSBzaWduIG5vdCBhbGxvd2VkJ1xuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU3VmZml4XG4gICAgICovXG4gICAgc3VmZml4VGV4dDogJycsXG5cbiAgICAvKiBPdmVycmlkZSBtaW4gbWF4IGxpbWl0c1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImNlaWxpbmdcIiBhZGhlcmVzIHRvIG1heGltdW1WYWx1ZSBhbmQgaWdub3JlcyBtaW5pbXVtVmFsdWUgc2V0dGluZ3NcbiAgICAgKiBvdmVycmlkZU1pbk1heExpbWl0czogXCJmbG9vclwiIGFkaGVyZXMgdG8gbWluaW11bVZhbHVlIGFuZCBpZ25vcmVzIG1heGltdW1WYWx1ZSBzZXR0aW5nc1xuICAgICAqIG92ZXJyaWRlTWluTWF4TGltaXRzOiBcImlnbm9yZVwiIGlnbm9yZXMgYm90aCBtaW5pbXVtVmFsdWUgJiBtYXhpbXVtVmFsdWVcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogb0xpbWl0c1xuICAgICAqL1xuICAgIG92ZXJyaWRlTWluTWF4TGltaXRzOiBudWxsLFxuXG4gICAgLyogTWF4aW11bSBwb3NzaWJsZSB2YWx1ZVxuICAgICAqIHZhbHVlIG11c3QgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCB1c2UgdGhlIHBlcmlvZCBmb3IgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgKiB2YWx1ZSBtdXN0IGJlIGxhcmdlciB0aGFuIG1pbmltdW1WYWx1ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB2TWF4XG4gICAgICovXG4gICAgbWF4aW11bVZhbHVlOiAnOTk5OTk5OTk5OTk5OS45OScsIC8vIDkuOTk5Ljk5OS45OTkuOTk5LDk5IH49IDEwMDAwIGJpbGxpb25zXG5cbiAgICAvKiBNaW5pbXVtIHBvc3NpYmxlIHZhbHVlXG4gICAgICogdmFsdWUgbXVzdCBiZSBlbmNsb3NlZCBpbiBxdW90ZXMgYW5kIHVzZSB0aGUgcGVyaW9kIGZvciB0aGUgZGVjaW1hbCBwb2ludFxuICAgICAqIHZhbHVlIG11c3QgYmUgc21hbGxlciB0aGFuIG1heGltdW1WYWx1ZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB2TWluXG4gICAgICovXG4gICAgbWluaW11bVZhbHVlOiAnLTk5OTk5OTk5OTk5OTkuOTknLCAvLyAtOS45OTkuOTk5Ljk5OS45OTksOTkgfj0gMTAwMDAgYmlsbGlvbnNcblxuICAgIC8qIE1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzID0gdXNlZCB0byBvdmVycmlkZSBkZWNpbWFsIHBsYWNlcyBzZXQgYnkgdGhlIG1pbmltdW1WYWx1ZSAmIG1heGltdW1WYWx1ZSB2YWx1ZXNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogbURlY1xuICAgICAqL1xuICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZTogbnVsbCxcblxuICAgIC8qIEV4cGFuZGVkIGRlY2ltYWwgcGxhY2VzIHZpc2libGUgd2hlbiBpbnB1dCBoYXMgZm9jdXMgLSBleGFtcGxlOlxuICAgICAqIHtkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzOiBcIjVcIn0gYW5kIHRoZSBkZWZhdWx0IDIgZGVjaW1hbCBwbGFjZXMgd2l0aCBmb2N1cyBcIjEsMDAwLjEyMzQ1XCIgd2l0aG91dCBmb2N1cyBcIjEsMDAwLjEyXCIgdGhlIHJlc3VsdHMgZGVwZW5kcyBvbiB0aGUgcm91bmRpbmcgbWV0aG9kIHVzZWRcbiAgICAgKiB0aGUgXCJnZXRcIiBtZXRob2QgcmV0dXJucyB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZURlY1xuICAgICAqL1xuICAgIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXM6IG51bGwsXG5cbiAgICAvKiBUaGUgbmV4dCB0aHJlZSBvcHRpb25zIChzY2FsZURpdmlzb3IsIHNjYWxlRGVjaW1hbFBsYWNlcyAmIHNjYWxlU3ltYm9sKSBoYW5kbGUgc2NhbGluZyBvZiB0aGUgaW5wdXQgd2hlbiB0aGUgaW5wdXQgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICAgICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG5vbi1zY2FsZWQgdmFsdWUgaXMgaGVsZCBpbiBkYXRhIGFuZCBpdCBpcyBhZHZpc2VkIHRoYXQgeW91IHVzZSB0aGUgXCJzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlXCIgb3B0aW9uIHRvIGVuc3VyZSByZXRhaW5pbmcgdGhlIHZhbHVlXG4gICAgICogW1wiZGl2aXNvclwiLCBcImRlY2ltYWwgcGxhY2VzXCIsIFwic3ltYm9sXCJdXG4gICAgICogRXhhbXBsZTogd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbnMgc2V0IHtzY2FsZURpdmlzb3I6ICcxMDAwJywgc2NhbGVEZWNpbWFsUGxhY2VzOiAnMScsIHNjYWxlU3ltYm9sOiAnIEsnfVxuICAgICAqIEV4YW1wbGU6IGZvY3VzaW4gdmFsdWUgXCIxLDExMS4xMVwiIGZvY3Vzb3V0IHZhbHVlIFwiMS4xIEtcIlxuICAgICAqL1xuXG4gICAgLyogVGhlIGBzY2FsZURpdmlzb3JgIGRlY2lkZXMgdGhlIG9uIGZvY3VzIHZhbHVlIGFuZCBwbGFjZXMgdGhlIHJlc3VsdCBpbiB0aGUgaW5wdXQgb24gZm9jdXNvdXRcbiAgICAgKiBFeGFtcGxlIHtzY2FsZURpdmlzb3I6ICcxMDAwJ30gb3IgPGlucHV0IGRhdGEtc2NhbGUtZGl2aXNvcj1cIjEwMDBcIj5cbiAgICAgKiBUaGUgZGl2aXNvciB2YWx1ZSAtIGRvZXMgbm90IG5lZWQgdG8gYmUgd2hvbGUgbnVtYmVyIGJ1dCBwbGVhc2UgdW5kZXJzdGFuZCB0aGF0IEphdmFzY3JpcHQgaGFzIGxpbWl0ZWQgYWNjdXJhY3kgaW4gbWF0aFxuICAgICAqIFRoZSBcImdldFwiIG1ldGhvZCByZXR1cm5zIHRoZSBmdWxsIHZhbHVlLCBpbmNsdWRpbmcgdGhlICdoaWRkZW4nIGRlY2ltYWxzLlxuICAgICAqL1xuICAgIHNjYWxlRGl2aXNvcjogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZURlY2ltYWxQbGFjZXNgIG9wdGlvbiBpcyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2Ugd2hlbiBub3QgaW4gZm9jdXMgLSBmb3IgdGhpcyB0byB3b3JrLCBgc2NhbGVkRGl2aXNvcmAgbXVzdCBub3QgYmUgYG51bGxgLlxuICAgICAqIFRoaXMgaXMgb3B0aW9uYWwgOyBpZiBvbWl0dGVkIHRoZSBkZWNpbWFsIHBsYWNlcyB3aWxsIGJlIHRoZSBzYW1lIHdoZW4gdGhlIGlucHV0IGhhcyB0aGUgZm9jdXMuXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IHNjYWxlRGVjaW1hbFxuICAgICAqL1xuICAgIHNjYWxlRGVjaW1hbFBsYWNlczogbnVsbCxcblxuICAgIC8qXG4gICAgICogVGhlIGBzY2FsZVN5bWJvbGAgb3B0aW9uIGlzIGEgc3ltYm9sIHBsYWNlZCBhcyBhIHN1ZmZpeCB3aGVuIG5vdCBpbiBmb2N1cy5cbiAgICAgKiBUaGlzIGlzIG9wdGlvbmFsIHRvby5cbiAgICAgKi9cbiAgICBzY2FsZVN5bWJvbDogbnVsbCxcblxuICAgIC8qIFNldCB0byB0cnVlIHRvIGFsbG93IHRoZSBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHZhbHVlIHRvIGJlIHNhdmVkIHdpdGggc2Vzc2lvblN0b3JhZ2VcbiAgICAgKiBpZiBpZSA2IG9yIDcgdGhlIHZhbHVlIHdpbGwgYmUgc2F2ZWQgYXMgYSBzZXNzaW9uIGNvb2tpZVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBhU3RvclxuICAgICAqL1xuICAgIHNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2U6IGZhbHNlLFxuXG4gICAgLypcbiAgICAgKiBNYW5hZ2UgaG93IGF1dG9OdW1lcmljIHJlYWN0IHdoZW4gdGhlIHVzZXIgdHJpZXMgdG8gcGFzdGUgYW4gaW52YWxpZCBudW1iZXIuXG4gICAgICogLSAnZXJyb3InICAgIDogKFRoaXMgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IpIFRoZSBpbnB1dCB2YWx1ZSBpcyBub3QgY2hhbmdlZCBhbmQgYW4gZXJyb3IgaXMgb3V0cHV0IGluIHRoZSBjb25zb2xlLlxuICAgICAqIC0gJ2lnbm9yZScgICA6IGlkZW0gdGhhbiAnZXJyb3InLCBidXQgZmFpbCBzaWxlbnRseSB3aXRob3V0IG91dHB1dHRpbmcgYW55IGVycm9yL3dhcm5pbmcgaW4gdGhlIGNvbnNvbGUuXG4gICAgICogLSAnY2xhbXAnICAgIDogaWYgdGhlIHBhc3RlZCB2YWx1ZSBpcyBlaXRoZXIgdG9vIHNtYWxsIG9yIHRvbyBiaWcgcmVnYXJkaW5nIHRoZSBtaW5pbXVtVmFsdWUgYW5kIG1heGltdW1WYWx1ZSByYW5nZSwgdGhlbiB0aGUgcmVzdWx0IGlzIGNsYW1wZWQgdG8gdGhvc2UgbGltaXRzLlxuICAgICAqIC0gJ3RydW5jYXRlJyA6IGF1dG9OdW1lcmljIHdpbGwgaW5zZXJ0IGFzIG1hbnkgcGFzdGVkIG51bWJlcnMgaXQgY2FuIGF0IHRoZSBpbml0aWFsIGNhcmV0L3NlbGVjdGlvbiwgdW50aWwgZXZlcnl0aGluZyBpcyBwYXN0ZWQsIG9yIHRoZSByYW5nZSBsaW1pdCBpcyBoaXQuXG4gICAgICogICAgICAgICAgICAgICAgVGhlIG5vbi1wYXN0ZWQgbnVtYmVycyBhcmUgZHJvcHBlZCBhbmQgdGhlcmVmb3JlIG5vdCB1c2VkIGF0IGFsbC5cbiAgICAgKiAtICdyZXBsYWNlJyAgOiBhdXRvTnVtZXJpYyB3aWxsIGZpcnN0IGluc2VydCBhcyBtYW55IHBhc3RlZCBudW1iZXJzIGl0IGNhbiBhdCB0aGUgaW5pdGlhbCBjYXJldC9zZWxlY3Rpb24sIHRoZW4gaWYgdGhlIHJhbmdlIGxpbWl0IGlzIGhpdCwgaXQgd2lsbCB0cnlcbiAgICAgKiAgICAgICAgICAgICAgICB0byByZXBsYWNlIG9uZSBieSBvbmUgdGhlIHJlbWFpbmluZyBpbml0aWFsIG51bWJlcnMgKG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBjYXJldCkgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcGFzdGVkIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBOb3RlIDEgOiBBIHBhc3RlIGNvbnRlbnQgc3RhcnRpbmcgd2l0aCBhIG5lZ2F0aXZlIHNpZ24gJy0nIHdpbGwgYmUgYWNjZXB0ZWQgYW55d2hlcmUgaW4gdGhlIGlucHV0LCBhbmQgd2lsbCBzZXQgdGhlIHJlc3VsdGluZyB2YWx1ZSBhcyBhIG5lZ2F0aXZlIG51bWJlclxuICAgICAqIE5vdGUgMiA6IEEgcGFzdGUgY29udGVudCBzdGFydGluZyB3aXRoIGEgbnVtYmVyIHdpbGwgYmUgYWNjZXB0ZWQsIGV2ZW4gaWYgdGhlIHJlc3QgaXMgZ2liYmVyaXNoIChpZS4gJzEyM2Zvb2JhcjQ1NicpLlxuICAgICAqICAgICAgICAgIE9ubHkgdGhlIGZpcnN0IG51bWJlciB3aWxsIGJlIHVzZWQgKGhlcmUgJzEyMycpLlxuICAgICAqIE5vdGUgMyA6IFRoZSBwYXN0ZSBldmVudCB3b3JrcyB3aXRoIHRoZSBgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c2Agb3B0aW9uIHRvby5cbiAgICAgKi9cbiAgICAvL1RPRE8gU2hvdWxkbid0IHdlIHVzZSBgdHJ1bmNhdGVgIGFzIHRoZSBkZWZhdWx0IHZhbHVlP1xuICAgIG9uSW52YWxpZFBhc3RlOiAnZXJyb3InLFxuXG4gICAgLyogbWV0aG9kIHVzZWQgZm9yIHJvdW5kaW5nXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiU1wiLCBSb3VuZC1IYWxmLVVwIFN5bW1ldHJpYyAoZGVmYXVsdClcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJBXCIsIFJvdW5kLUhhbGYtVXAgQXN5bW1ldHJpY1xuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcInNcIiwgUm91bmQtSGFsZi1Eb3duIFN5bW1ldHJpYyAobG93ZXIgY2FzZSBzKVxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcImFcIiwgUm91bmQtSGFsZi1Eb3duIEFzeW1tZXRyaWMgKGxvd2VyIGNhc2UgYSlcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJCXCIsIFJvdW5kLUhhbGYtRXZlbiBcIkJhbmtlcnMgUm91bmRpbmdcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIlVcIiwgUm91bmQgVXAgXCJSb3VuZC1Bd2F5LUZyb20tWmVyb1wiXG4gICAgICogcm91bmRpbmdNZXRob2Q6IFwiRFwiLCBSb3VuZCBEb3duIFwiUm91bmQtVG93YXJkLVplcm9cIiAtIHNhbWUgYXMgdHJ1bmNhdGVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJDXCIsIFJvdW5kIHRvIENlaWxpbmcgXCJUb3dhcmQgUG9zaXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIkZcIiwgUm91bmQgdG8gRmxvb3IgXCJUb3dhcmQgTmVnYXRpdmUgSW5maW5pdHlcIlxuICAgICAqIHJvdW5kaW5nTWV0aG9kOiBcIk4wNVwiIFJvdW5kcyB0byB0aGUgbmVhcmVzdCAuMDUgPT4gc2FtZSBhcyBcIkNIRlwiIHVzZWQgaW4gMS45WCBhbmQgc3RpbGwgdmFsaWRcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJVMDVcIiBSb3VuZHMgdXAgdG8gbmV4dCAuMDVcbiAgICAgKiByb3VuZGluZ01ldGhvZDogXCJEMDVcIiBSb3VuZHMgZG93biB0byBuZXh0IC4wNVxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBtUm91bmRcbiAgICAgKi9cbiAgICAvL1RPRE8gUmVuYW1lIHRoZSBvcHRpb25zIHRvIG1vcmUgZXhwbGljaXQgbmFtZXMgKCdTJyA9PiAnUm91bmRIYWxmVXBTeW1tZXRyaWMnLCBldGMuKVxuICAgIC8vVE9ETyBBZGQgYW4gYGFuLnJvdW5kaW5nTWV0aG9kYCBvYmplY3QgdGhhdCBlbnVtIHRob3NlIG9wdGlvbnMgY2xlYXJseVxuICAgIHJvdW5kaW5nTWV0aG9kOiAnUycsXG5cbiAgICAvKiBBbGxvdyBwYWRkaW5nIHRoZSBkZWNpbWFsIHBsYWNlcyB3aXRoIHplcm9zXG4gICAgICogYWxsb3dEZWNpbWFsUGFkZGluZzogdHJ1ZSAtIGFsd2F5cyBQYWQgZGVjaW1hbHMgd2l0aCB6ZXJvc1xuICAgICAqIGFsbG93RGVjaW1hbFBhZGRpbmc6IGZhbHNlIC0gZG9lcyBub3QgcGFkIHdpdGggemVyb3MuXG4gICAgICogTm90ZTogc2V0dGluZyBhbGxvd0RlY2ltYWxQYWRkaW5nIHRvICdmYWxzZScgd2lsbCBvdmVycmlkZSB0aGUgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgc2V0dGluZy5cbiAgICAgKlxuICAgICAqIHRoYW5rcyB0byBKb25hcyBKb2hhbnNzb24gZm9yIHRoZSBzdWdnZXN0aW9uXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFQYWRcbiAgICAgKi9cbiAgICBhbGxvd0RlY2ltYWxQYWRkaW5nOiB0cnVlLFxuXG4gICAgLyogQWRkcyBicmFja2V0cyBvbiBuZWdhdGl2ZSB2YWx1ZXMgKGllLiB0cmFuc2Zvcm1zICctJCA5OTkuOTknIHRvICcoOTk5Ljk5KScpXG4gICAgICogVGhvc2UgYnJhY2tldHMgYXJlIHZpc2libGUgb25seSB3aGVuIHRoZSBmaWVsZCBkb2VzIE5PVCBoYXZlIHRoZSBmb2N1cy5cbiAgICAgKiBUaGUgbGVmdCBhbmQgcmlnaHQgc3ltYm9scyBzaG91bGQgYmUgZW5jbG9zZWQgaW4gcXVvdGVzIGFuZCBzZXBhcmF0ZWQgYnkgYSBjb21tYVxuICAgICAqIFRoaXMgb3B0aW9uIGNhbiBiZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlcyA6XG4gICAgICogbnVsbCwgLy8gVGhpcyBpcyB0aGUgZGVmYXVsdCB2YWx1ZSwgd2hpY2ggZGVhY3RpdmF0ZSB0aGlzIGZlYXR1cmVcbiAgICAgKiAnKCwpJyxcbiAgICAgKiAnWyxdJyxcbiAgICAgKiAnPCw+JyBvclxuICAgICAqICd7LH0nXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG5CcmFja2V0XG4gICAgICovXG4gICAgLy9UT0RPIFJlbmFtZSB0aGUgb3B0aW9ucyB0byBtb3JlIGV4cGxpY2l0IG5hbWVzICgnKCwpJyA9PiAncGFyZW50aGVzZXMnLCBldGMuKVxuICAgIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyOiBudWxsLFxuXG4gICAgLyogRGlzcGxheWVkIG9uIGVtcHR5IHN0cmluZyBcIlwiXG4gICAgICogZW1wdHlJbnB1dEJlaGF2aW9yOiBcImZvY3VzXCIgLSAoZGVmYXVsdCkgY3VycmVuY3kgc2lnbiBkaXNwbGF5ZWQgYW5kIHRoZSBpbnB1dCByZWNlaXZlcyBmb2N1c1xuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJwcmVzc1wiIC0gY3VycmVuY3kgc2lnbiBkaXNwbGF5cyBvbiBhbnkga2V5IGJlaW5nIHByZXNzZWRcbiAgICAgKiBlbXB0eUlucHV0QmVoYXZpb3I6IFwiYWx3YXlzXCIgLSBhbHdheXMgZGlzcGxheXMgdGhlIGN1cnJlbmN5IHNpZ24gb25seVxuICAgICAqIGVtcHR5SW5wdXRCZWhhdmlvcjogXCJ6ZXJvXCIgLSBpZiB0aGUgaW5wdXQgaGFzIG5vIHZhbHVlIG9uIGZvY3VzIG91dCBkaXNwbGF5cyBhIHplcm8gXCJyb3VuZGVkXCIgd2l0aCBvciB3aXRob3V0IGEgY3VycmVuY3kgc2lnblxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiB3RW1wdHlcbiAgICAgKi9cbiAgICBlbXB0eUlucHV0QmVoYXZpb3I6ICdmb2N1cycsXG5cbiAgICAvKiBDb250cm9scyBsZWFkaW5nIHplcm8gYmVoYXZpb3JcbiAgICAgKiBsZWFkaW5nWmVybzogXCJhbGxvd1wiLCAtIGFsbG93cyBsZWFkaW5nIHplcm9zIHRvIGJlIGVudGVyZWQuIFplcm9zIHdpbGwgYmUgdHJ1bmNhdGVkIHdoZW4gZW50ZXJpbmcgYWRkaXRpb25hbCBkaWdpdHMuIE9uIGZvY3Vzb3V0IHplcm9zIHdpbGwgYmUgZGVsZXRlZC5cbiAgICAgKiBsZWFkaW5nWmVybzogXCJkZW55XCIsIC0gYWxsb3dzIG9ubHkgb25lIGxlYWRpbmcgemVybyBvbiB2YWx1ZXMgbGVzcyB0aGFuIG9uZVxuICAgICAqIGxlYWRpbmdaZXJvOiBcImtlZXBcIiwgLSBhbGxvd3MgbGVhZGluZyB6ZXJvcyB0byBiZSBlbnRlcmVkLiBvbiBmb2N1c291dCB6ZXJvcyB3aWxsIGJlIHJldGFpbmVkLlxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBsWmVyb1xuICAgICAqL1xuICAgIGxlYWRpbmdaZXJvOiAnZGVueScsXG5cbiAgICAvKiBEZXRlcm1pbmUgaWYgdGhlIGRlZmF1bHQgdmFsdWUgd2lsbCBiZSBmb3JtYXR0ZWQgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICogdHJ1ZSA9IGF1dG9tYXRpY2FsbHkgZm9ybWF0cyB0aGUgZGVmYXVsdCB2YWx1ZSBvbiBpbml0aWFsaXphdGlvblxuICAgICAqIGZhbHNlID0gd2lsbCBub3QgZm9ybWF0IHRoZSBkZWZhdWx0IHZhbHVlIG9uIGluaXRpYWxpemF0aW9uXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IGFGb3JtXG4gICAgICovXG4gICAgZm9ybWF0T25QYWdlTG9hZDogdHJ1ZSxcblxuICAgIC8qIERldGVybWluZSBpZiB0aGUgc2VsZWN0IGFsbCBrZXlib2FyZCBjb21tYW5kIHdpbGwgc2VsZWN0IHRoZSBjb21wbGV0ZSBpbnB1dCB0ZXh0LCBvciBvbmx5IHRoZSBpbnB1dCBudW1lcmljIHZhbHVlXG4gICAgICogTm90ZSA6IElmIHRoZSBjdXJyZW5jeSBzeW1ib2wgaXMgYmV0d2VlbiB0aGUgbnVtZXJpYyB2YWx1ZSBhbmQgdGhlIG5lZ2F0aXZlIHNpZ24sIG9ubHkgdGhlIG51bWVyaWMgdmFsdWUgd2lsbCBzZWxlY3RlZFxuICAgICAqIERlcHJlY2F0ZWQgb2xkZXIgb3B0aW9uIG5hbWUgOiBzTnVtYmVyXG4gICAgICovXG4gICAgc2VsZWN0TnVtYmVyT25seTogZmFsc2UsXG5cbiAgICAvKiBIZWxwZXIgb3B0aW9uIGZvciBBU1AuTkVUIHBvc3RiYWNrXG4gICAgICogc2hvdWxkIGJlIHRoZSB2YWx1ZSBvZiB0aGUgdW5mb3JtYXR0ZWQgZGVmYXVsdCB2YWx1ZVxuICAgICAqIGV4YW1wbGVzOlxuICAgICAqIG5vIGRlZmF1bHQgdmFsdWU9XCJcIiB7ZGVmYXVsdFZhbHVlT3ZlcnJpZGU6IFwiXCJ9XG4gICAgICogdmFsdWU9MTIzNC41NiB7ZGVmYXVsdFZhbHVlT3ZlcnJpZGU6ICcxMjM0LjU2J31cbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogYW5EZWZhdWx0XG4gICAgICovXG4gICAgZGVmYXVsdFZhbHVlT3ZlcnJpZGU6IG51bGwsXG5cbiAgICAvKiBSZW1vdmVzIGZvcm1hdHRpbmcgb24gc3VibWl0IGV2ZW50XG4gICAgICogdGhpcyBvdXRwdXQgZm9ybWF0OiBwb3NpdGl2ZSBubm5uLm5uLCBuZWdhdGl2ZSAtbm5ubi5ublxuICAgICAqIHJldmlldyB0aGUgJ3VuU2V0JyBtZXRob2QgZm9yIG90aGVyIGZvcm1hdHNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogdW5TZXRPblN1Ym1pdFxuICAgICAqL1xuICAgIHVuZm9ybWF0T25TdWJtaXQ6IGZhbHNlLFxuXG4gICAgLyogQWxsb3dzIHRoZSBvdXRwdXQgdG8gYmUgaW4gdGhlIGxvY2FsZSBmb3JtYXQgdmlhIHRoZSBcImdldFwiLCBcImdldFN0cmluZ1wiICYgXCJnZXRBcnJheVwiIG1ldGhvZHNcbiAgICAgKiBudWxsIG9yICdzdHJpbmcnID0+ICdubm5uLm5uJyBvciAnLW5ubm4ubm4nIGFzIHRleHQgdHlwZS4gVGhpcyBpcyB0aGUgZGVmYXVsdCBiZWhhdmlvci5cbiAgICAgKiAnbnVtYmVyJyAgICAgICAgID0+IG5ubm4ubm4gb3IgLW5ubm4ubm4gYXMgYSBOdW1iZXIgKFdhcm5pbmc6IHRoaXMgd29ya3Mgb25seSBmb3IgaW50ZWdlcnMgaW5mZXJpb3IgdG8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpXG4gICAgICogJywnIG9yICctLCcgICAgICA9PiAnbm5ubixubicgb3IgJy1ubm5uLG5uJ1xuICAgICAqICcuLScgICAgICAgICAgICAgPT4gJ25ubm4ubm4nIG9yICdubm5uLm5uLSdcbiAgICAgKiAnLC0nICAgICAgICAgICAgID0+ICdubm5uLG5uJyBvciAnbm5ubixubi0nXG4gICAgICogRGVwcmVjYXRlZCBvbGRlciBvcHRpb24gbmFtZSA6IG91dHB1dFR5cGVcbiAgICAgKi9cbiAgICBvdXRwdXRGb3JtYXQ6IG51bGwsXG5cbiAgICAvKiBEZWZpbmVzIGlmIHdhcm5pbmdzIHNob3VsZCBiZSBzaG93blxuICAgICAqIEVycm9yIGhhbmRsaW5nIGZ1bmN0aW9uXG4gICAgICogdHJ1ZSA9PiBhbGwgd2FybmluZyBhcmUgc2hvd25cbiAgICAgKiBmYWxzZSA9PiBubyB3YXJuaW5ncyBhcmUgc2hvd24sIG9ubHkgdGhlIHRocm93biBlcnJvcnNcbiAgICAgKiBEZXByZWNhdGVkIG9sZGVyIG9wdGlvbiBuYW1lIDogZGVidWdcbiAgICAgKi9cbiAgICBzaG93V2FybmluZ3M6IHRydWUsXG5cbiAgICAvKlxuICAgICAqIFRoaXMgb3B0aW9uIGlzIHRoZSAnc3RyaWN0IG1vZGUnIChha2EgJ2RlYnVnJyBtb2RlKSwgd2hpY2ggYWxsb3dzIGF1dG9OdW1lcmljIHRvIHN0cmljdGx5IGFuYWx5c2UgdGhlIG9wdGlvbnMgcGFzc2VkLCBhbmQgZmFpbHMgaWYgYW4gdW5rbm93biBvcHRpb25zIGlzIHVzZWQgaW4gdGhlIHNldHRpbmdzIG9iamVjdC5cbiAgICAgKiBZb3Ugc2hvdWxkIHNldCB0aGF0IHRvICdUUlVFJyBpZiB5b3Ugd2FudCB0byBtYWtlIHN1cmUgeW91IGFyZSBvbmx5IHVzaW5nICdwdXJlJyBhdXRvTnVtZXJpYyBzZXR0aW5ncyBvYmplY3RzIGluIHlvdXIgY29kZS5cbiAgICAgKiBJZiB5b3Ugc2VlIHVuY2F1Z2h0IGVycm9ycyBpbiB0aGUgY29uc29sZSBhbmQgeW91ciBjb2RlIHN0YXJ0cyB0byBmYWlsLCB0aGlzIG1lYW5zIHNvbWVob3cgdGhvc2Ugb3B0aW9ucyBnZXRzIGNvcnJ1cHRlZCBieSBhbm90aGVyIHByb2dyYW0uXG4gICAgICovXG4gICAgZmFpbE9uVW5rbm93bk9wdGlvbjogZmFsc2UsXG59O1xuXG4vKipcbiAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleUNvZGUgYXMgc2VlbiBpbiBET00gZXZlbnRzLlxuICogLy9UT0RPIFJlcGxhY2UgZXZlcnkgY2FsbCB0byB0aGlzIG9iamVjdCB3aXRoIGEgY2FsbCB0byBga2V5TmFtZWBcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmNvbnN0IGtleUNvZGUgPSB7XG4gICAgQmFja3NwYWNlOiAgICAgIDgsXG4gICAgVGFiOiAgICAgICAgICAgIDksXG4gICAgRW50ZXI6ICAgICAgICAgIDEzLFxuICAgIFNoaWZ0OiAgICAgICAgICAxNixcbiAgICBDdHJsOiAgICAgICAgICAgMTcsXG4gICAgQWx0OiAgICAgICAgICAgIDE4LFxuICAgIFBhdXNlQnJlYWs6ICAgICAxOSxcbiAgICBDYXBzTG9jazogICAgICAgMjAsXG4gICAgRXNjOiAgICAgICAgICAgIDI3LFxuICAgIFNwYWNlOiAgICAgICAgICAzMixcbiAgICBQYWdlVXA6ICAgICAgICAgMzMsXG4gICAgUGFnZURvd246ICAgICAgIDM0LFxuICAgIEVuZDogICAgICAgICAgICAzNSxcbiAgICBIb21lOiAgICAgICAgICAgMzYsXG4gICAgTGVmdEFycm93OiAgICAgIDM3LFxuICAgIFVwQXJyb3c6ICAgICAgICAzOCxcbiAgICBSaWdodEFycm93OiAgICAgMzksXG4gICAgRG93bkFycm93OiAgICAgIDQwLFxuICAgIEluc2VydDogICAgICAgICA0NSxcbiAgICBEZWxldGU6ICAgICAgICAgNDYsXG4gICAgbnVtMDogICAgICAgICAgIDQ4LFxuICAgIG51bTE6ICAgICAgICAgICA0OSxcbiAgICBudW0yOiAgICAgICAgICAgNTAsXG4gICAgbnVtMzogICAgICAgICAgIDUxLFxuICAgIG51bTQ6ICAgICAgICAgICA1MixcbiAgICBudW01OiAgICAgICAgICAgNTMsXG4gICAgbnVtNjogICAgICAgICAgIDU0LFxuICAgIG51bTc6ICAgICAgICAgICA1NSxcbiAgICBudW04OiAgICAgICAgICAgNTYsXG4gICAgbnVtOTogICAgICAgICAgIDU3LFxuICAgIGE6ICAgICAgICAgICAgICA2NSxcbiAgICBiOiAgICAgICAgICAgICAgNjYsXG4gICAgYzogICAgICAgICAgICAgIDY3LFxuICAgIGQ6ICAgICAgICAgICAgICA2OCxcbiAgICBlOiAgICAgICAgICAgICAgNjksXG4gICAgZjogICAgICAgICAgICAgIDcwLFxuICAgIGc6ICAgICAgICAgICAgICA3MSxcbiAgICBoOiAgICAgICAgICAgICAgNzIsXG4gICAgaTogICAgICAgICAgICAgIDczLFxuICAgIGo6ICAgICAgICAgICAgICA3NCxcbiAgICBrOiAgICAgICAgICAgICAgNzUsXG4gICAgbDogICAgICAgICAgICAgIDc2LFxuICAgIG06ICAgICAgICAgICAgICA3NyxcbiAgICBuOiAgICAgICAgICAgICAgNzgsXG4gICAgbzogICAgICAgICAgICAgIDc5LFxuICAgIHA6ICAgICAgICAgICAgICA4MCxcbiAgICBxOiAgICAgICAgICAgICAgODEsXG4gICAgcjogICAgICAgICAgICAgIDgyLFxuICAgIHM6ICAgICAgICAgICAgICA4MyxcbiAgICB0OiAgICAgICAgICAgICAgODQsXG4gICAgdTogICAgICAgICAgICAgIDg1LFxuICAgIHY6ICAgICAgICAgICAgICA4NixcbiAgICB3OiAgICAgICAgICAgICAgODcsXG4gICAgeDogICAgICAgICAgICAgIDg4LFxuICAgIHk6ICAgICAgICAgICAgICA4OSxcbiAgICB6OiAgICAgICAgICAgICAgOTAsXG4gICAgV2luZG93czogICAgICAgIDkxLFxuICAgIFJpZ2h0Q2xpY2s6ICAgICA5MyxcbiAgICBudW1wYWQwOiAgICAgICAgOTYsXG4gICAgbnVtcGFkMTogICAgICAgIDk3LFxuICAgIG51bXBhZDI6ICAgICAgICA5OCxcbiAgICBudW1wYWQzOiAgICAgICAgOTksXG4gICAgbnVtcGFkNDogICAgICAgIDEwMCxcbiAgICBudW1wYWQ1OiAgICAgICAgMTAxLFxuICAgIG51bXBhZDY6ICAgICAgICAxMDIsXG4gICAgbnVtcGFkNzogICAgICAgIDEwMyxcbiAgICBudW1wYWQ4OiAgICAgICAgMTA0LFxuICAgIG51bXBhZDk6ICAgICAgICAxMDUsXG4gICAgTXVsdGlwbHlOdW1wYWQ6IDEwNixcbiAgICBQbHVzTnVtcGFkOiAgICAgMTA3LFxuICAgIE1pbnVzTnVtcGFkOiAgICAxMDksXG4gICAgRG90TnVtcGFkOiAgICAgIDExMCxcbiAgICBTbGFzaE51bXBhZDogICAgMTExLFxuICAgIEYxOiAgICAgICAgICAgICAxMTIsXG4gICAgRjI6ICAgICAgICAgICAgIDExMyxcbiAgICBGMzogICAgICAgICAgICAgMTE0LFxuICAgIEY0OiAgICAgICAgICAgICAxMTUsXG4gICAgRjU6ICAgICAgICAgICAgIDExNixcbiAgICBGNjogICAgICAgICAgICAgMTE3LFxuICAgIEY3OiAgICAgICAgICAgICAxMTgsXG4gICAgRjg6ICAgICAgICAgICAgIDExOSxcbiAgICBGOTogICAgICAgICAgICAgMTIwLFxuICAgIEYxMDogICAgICAgICAgICAxMjEsXG4gICAgRjExOiAgICAgICAgICAgIDEyMixcbiAgICBGMTI6ICAgICAgICAgICAgMTIzLFxuICAgIE51bUxvY2s6ICAgICAgICAxNDQsXG4gICAgU2Nyb2xsTG9jazogICAgIDE0NSxcbiAgICBNeUNvbXB1dGVyOiAgICAgMTgyLFxuICAgIE15Q2FsY3VsYXRvcjogICAxODMsXG4gICAgU2VtaWNvbG9uOiAgICAgIDE4NixcbiAgICBFcXVhbDogICAgICAgICAgMTg3LFxuICAgIENvbW1hOiAgICAgICAgICAxODgsXG4gICAgSHlwaGVuOiAgICAgICAgIDE4OSxcbiAgICBEb3Q6ICAgICAgICAgICAgMTkwLFxuICAgIFNsYXNoOiAgICAgICAgICAxOTEsXG4gICAgQmFja3F1b3RlOiAgICAgIDE5MixcbiAgICBMZWZ0QnJhY2tldDogICAgMjE5LFxuICAgIEJhY2tzbGFzaDogICAgICAyMjAsXG4gICAgUmlnaHRCcmFja2V0OiAgIDIyMSxcbiAgICBRdW90ZTogICAgICAgICAgMjIyLFxuICAgIENvbW1hbmQ6ICAgICAgICAyMjQsXG59O1xuXG4vKipcbiAqIFdyYXBwZXIgdmFyaWFibGUgdGhhdCBob2xkIG5hbWVkIGtleWJvYXJkIGtleXMgd2l0aCB0aGVpciByZXNwZWN0aXZlIGtleSBuYW1lIChhcyBzZXQgaW4gS2V5Ym9hcmRFdmVudC5rZXkpLlxuICogVGhvc2UgbmFtZXMgYXJlIGxpc3RlZCBoZXJlIDpcbiAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleS9LZXlfVmFsdWVzXG4gKi9cbmNvbnN0IGtleU5hbWUgPSB7XG4gICAgLy8gU3BlY2lhbCB2YWx1ZXNcbiAgICBVbmlkZW50aWZpZWQ6ICAgJ1VuaWRlbnRpZmllZCcsXG5cbiAgICAvLyBNb2RpZmllciBrZXlzXG4gICAgQWx0OiAgICAgICAgICAgICdBbHQnLFxuICAgIEFsdEdyOiAgICAgICAgICAnQWx0R3JhcGgnLFxuICAgIENhcHNMb2NrOiAgICAgICAnQ2Fwc0xvY2snLCAvLyBVbmRlciBDaHJvbWUsIGUua2V5IGlzIGVtcHR5IGZvciBDYXBzTG9ja1xuICAgIEN0cmw6ICAgICAgICAgICAnQ29udHJvbCcsXG4gICAgRm46ICAgICAgICAgICAgICdGbicsXG4gICAgRm5Mb2NrOiAgICAgICAgICdGbkxvY2snLFxuICAgIEh5cGVyOiAgICAgICAgICAnSHlwZXInLCAvLyAnT1MnIHVuZGVyIEZpcmVmb3hcbiAgICBNZXRhOiAgICAgICAgICAgJ01ldGEnLCAvLyBUaGUgV2luZG93cywgQ29tbWFuZCBvciDijJgga2V5IC8vICdPUycgdW5kZXIgRmlyZWZveCBhbmQgSUU5XG4gICAgV2luZG93czogICAgICAgICdNZXRhJywgLy8gVGhpcyBpcyBhIG5vbi1vZmZpY2lhbCBrZXkgbmFtZVxuICAgIENvbW1hbmQ6ICAgICAgICAnTWV0YScsIC8vIFRoaXMgaXMgYSBub24tb2ZmaWNpYWwga2V5IG5hbWVcbiAgICBOdW1Mb2NrOiAgICAgICAgJ051bUxvY2snLFxuICAgIFNjcm9sbExvY2s6ICAgICAnU2Nyb2xsTG9jaycsXG4gICAgU2hpZnQ6ICAgICAgICAgICdTaGlmdCcsXG4gICAgU3VwZXI6ICAgICAgICAgICdTdXBlcicsIC8vICdPUycgdW5kZXIgRmlyZWZveFxuICAgIFN5bWJvbDogICAgICAgICAnU3ltYm9sJyxcbiAgICBTeW1ib2xMb2NrOiAgICAgJ1N5bWJvbExvY2snLFxuXG4gICAgLy8gV2hpdGVzcGFjZSBrZXlzXG4gICAgRW50ZXI6ICAgICAgICAgICdFbnRlcicsXG4gICAgVGFiOiAgICAgICAgICAgICdUYWInLFxuICAgIFNwYWNlOiAgICAgICAgICAnICcsIC8vICdTcGFjZWJhcicgZm9yIEZpcmVmb3ggPDM3LCBhbmQgSUU5XG5cbiAgICAvLyBOYXZpZ2F0aW9uIGtleXNcbiAgICBEb3duQXJyb3c6ICAgICAgJ0Fycm93RG93bicsIC8vICdEb3duJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgTGVmdEFycm93OiAgICAgICdBcnJvd0xlZnQnLCAvLyAnTGVmdCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIFJpZ2h0QXJyb3c6ICAgICAnQXJyb3dSaWdodCcsIC8vICdSaWdodCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIFVwQXJyb3c6ICAgICAgICAnQXJyb3dVcCcsIC8vICdVcCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIEVuZDogICAgICAgICAgICAnRW5kJyxcbiAgICBIb21lOiAgICAgICAgICAgJ0hvbWUnLFxuICAgIFBhZ2VEb3duOiAgICAgICAnUGFnZURvd24nLFxuICAgIFBhZ2VVcDogICAgICAgICAnUGFnZVVwJyxcblxuICAgIC8vIEVkaXRpbmcga2V5c1xuICAgIEJhY2tzcGFjZTogICAgICAnQmFja3NwYWNlJyxcbiAgICBDbGVhcjogICAgICAgICAgJ0NsZWFyJyxcbiAgICBDb3B5OiAgICAgICAgICAgJ0NvcHknLFxuICAgIENyU2VsOiAgICAgICAgICAnQ3JTZWwnLCAvLyAnQ3JzZWwnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBDdXQ6ICAgICAgICAgICAgJ0N1dCcsXG4gICAgRGVsZXRlOiAgICAgICAgICdEZWxldGUnLCAvLyAnRGVsJyBmb3IgRmlyZWZveCA8PTM2LCBhbmQgSUU5XG4gICAgRXJhc2VFb2Y6ICAgICAgICdFcmFzZUVvZicsXG4gICAgRXhTZWw6ICAgICAgICAgICdFeFNlbCcsIC8vICdFeHNlbCcgZm9yIEZpcmVmb3ggPD0zNiwgYW5kIElFOVxuICAgIEluc2VydDogICAgICAgICAnSW5zZXJ0JyxcbiAgICBQYXN0ZTogICAgICAgICAgJ1Bhc3RlJyxcbiAgICBSZWRvOiAgICAgICAgICAgJ1JlZG8nLFxuICAgIFVuZG86ICAgICAgICAgICAnVW5kbycsXG5cbiAgICAvLyBVSSBrZXlzXG4gICAgQWNjZXB0OiAgICAgICAgICdBY2NlcHQnLFxuICAgIEFnYWluOiAgICAgICAgICAnQWdhaW4nLFxuICAgIEF0dG46ICAgICAgICAgICAnQXR0bicsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94LCBDaHJvbWUsIGFuZCBJRTkgKCdLYW5hTW9kZScgd2hlbiB1c2luZyB0aGUgSmFwYW5lc2Uga2V5Ym9hcmQgbGF5b3V0KVxuICAgIENhbmNlbDogICAgICAgICAnQ2FuY2VsJyxcbiAgICBDb250ZXh0TWVudTogICAgJ0NvbnRleHRNZW51JywgLy8gJ0FwcHMnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBFc2M6ICAgICAgICAgICAgJ0VzY2FwZScsIC8vICdFc2MnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBFeGVjdXRlOiAgICAgICAgJ0V4ZWN1dGUnLFxuICAgIEZpbmQ6ICAgICAgICAgICAnRmluZCcsXG4gICAgRmluaXNoOiAgICAgICAgICdGaW5pc2gnLCAvLyAnVW5pZGVudGlmaWVkJyBmb3IgRmlyZWZveCwgQ2hyb21lLCBhbmQgSUU5ICgnS2F0YWthbmEnIHdoZW4gdXNpbmcgdGhlIEphcGFuZXNlIGtleWJvYXJkIGxheW91dClcbiAgICBIZWxwOiAgICAgICAgICAgJ0hlbHAnLFxuICAgIFBhdXNlOiAgICAgICAgICAnUGF1c2UnLFxuICAgIFBsYXk6ICAgICAgICAgICAnUGxheScsXG4gICAgUHJvcHM6ICAgICAgICAgICdQcm9wcycsXG4gICAgU2VsZWN0OiAgICAgICAgICdTZWxlY3QnLFxuICAgIFpvb21JbjogICAgICAgICAnWm9vbUluJyxcbiAgICBab29tT3V0OiAgICAgICAgJ1pvb21PdXQnLFxuXG4gICAgLy8gRGV2aWNlIGtleXNcbiAgICBCcmlnaHRuZXNzRG93bjogJ0JyaWdodG5lc3NEb3duJyxcbiAgICBCcmlnaHRuZXNzVXA6ICAgJ0JyaWdodG5lc3NVcCcsXG4gICAgRWplY3Q6ICAgICAgICAgICdFamVjdCcsXG4gICAgTG9nT2ZmOiAgICAgICAgICdMb2dPZmYnLFxuICAgIFBvd2VyOiAgICAgICAgICAnUG93ZXInLFxuICAgIFBvd2VyT2ZmOiAgICAgICAnUG93ZXJPZmYnLFxuICAgIFByaW50U2NyZWVuOiAgICAnUHJpbnRTY3JlZW4nLFxuICAgIEhpYmVybmF0ZTogICAgICAnSGliZXJuYXRlJywgLy8gJ1VuaWRlbnRpZmllZCcgZm9yIEZpcmVmb3ggPD0zN1xuICAgIFN0YW5kYnk6ICAgICAgICAnU3RhbmRieScsIC8vICdVbmlkZW50aWZpZWQnIGZvciBGaXJlZm94IDw9MzYsIGFuZCBJRTlcbiAgICBXYWtlVXA6ICAgICAgICAgJ1dha2VVcCcsXG5cbiAgICAvLyBJTUUgYW5kIGNvbXBvc2l0aW9uIGtleXNcbiAgICBDb21wb3NlOiAgICAgICAgJ0NvbXBvc2UnLFxuICAgIERlYWQ6ICAgICAgICAgICAnRGVhZCcsXG5cbiAgICAvLyBGdW5jdGlvbiBrZXlzXG4gICAgRjE6ICAgICAgICAgICAgICdGMScsXG4gICAgRjI6ICAgICAgICAgICAgICdGMicsXG4gICAgRjM6ICAgICAgICAgICAgICdGMycsXG4gICAgRjQ6ICAgICAgICAgICAgICdGNCcsXG4gICAgRjU6ICAgICAgICAgICAgICdGNScsXG4gICAgRjY6ICAgICAgICAgICAgICdGNicsXG4gICAgRjc6ICAgICAgICAgICAgICdGNycsXG4gICAgRjg6ICAgICAgICAgICAgICdGOCcsXG4gICAgRjk6ICAgICAgICAgICAgICdGOScsXG4gICAgRjEwOiAgICAgICAgICAgICdGMTAnLFxuICAgIEYxMTogICAgICAgICAgICAnRjExJyxcbiAgICBGMTI6ICAgICAgICAgICAgJ0YxMicsXG5cbiAgICAvLyBEb2N1bWVudCBrZXlzXG4gICAgUHJpbnQ6ICAgICAgICAgICdQcmludCcsXG5cbiAgICAvLyAnTm9ybWFsJyBrZXlzXG4gICAgbnVtMDogICAgICAgICAgICcwJyxcbiAgICBudW0xOiAgICAgICAgICAgJzEnLFxuICAgIG51bTI6ICAgICAgICAgICAnMicsXG4gICAgbnVtMzogICAgICAgICAgICczJyxcbiAgICBudW00OiAgICAgICAgICAgJzQnLFxuICAgIG51bTU6ICAgICAgICAgICAnNScsXG4gICAgbnVtNjogICAgICAgICAgICc2JyxcbiAgICBudW03OiAgICAgICAgICAgJzcnLFxuICAgIG51bTg6ICAgICAgICAgICAnOCcsXG4gICAgbnVtOTogICAgICAgICAgICc5JyxcbiAgICBudW1wYWQwOiAgICAgICAgJzAnLFxuICAgIG51bXBhZDE6ICAgICAgICAnMScsXG4gICAgbnVtcGFkMjogICAgICAgICcyJyxcbiAgICBudW1wYWQzOiAgICAgICAgJzMnLFxuICAgIG51bXBhZDQ6ICAgICAgICAnNCcsXG4gICAgbnVtcGFkNTogICAgICAgICc1JyxcbiAgICBudW1wYWQ2OiAgICAgICAgJzYnLFxuICAgIG51bXBhZDc6ICAgICAgICAnNycsXG4gICAgbnVtcGFkODogICAgICAgICc4JyxcbiAgICBudW1wYWQ5OiAgICAgICAgJzknLFxuICAgIGE6ICAgICAgICAgICAgICAnYScsXG4gICAgYjogICAgICAgICAgICAgICdiJyxcbiAgICBjOiAgICAgICAgICAgICAgJ2MnLFxuICAgIGQ6ICAgICAgICAgICAgICAnZCcsXG4gICAgZTogICAgICAgICAgICAgICdlJyxcbiAgICBmOiAgICAgICAgICAgICAgJ2YnLFxuICAgIGc6ICAgICAgICAgICAgICAnZycsXG4gICAgaDogICAgICAgICAgICAgICdoJyxcbiAgICBpOiAgICAgICAgICAgICAgJ2knLFxuICAgIGo6ICAgICAgICAgICAgICAnaicsXG4gICAgazogICAgICAgICAgICAgICdrJyxcbiAgICBsOiAgICAgICAgICAgICAgJ2wnLFxuICAgIG06ICAgICAgICAgICAgICAnbScsXG4gICAgbjogICAgICAgICAgICAgICduJyxcbiAgICBvOiAgICAgICAgICAgICAgJ28nLFxuICAgIHA6ICAgICAgICAgICAgICAncCcsXG4gICAgcTogICAgICAgICAgICAgICdxJyxcbiAgICByOiAgICAgICAgICAgICAgJ3InLFxuICAgIHM6ICAgICAgICAgICAgICAncycsXG4gICAgdDogICAgICAgICAgICAgICd0JyxcbiAgICB1OiAgICAgICAgICAgICAgJ3UnLFxuICAgIHY6ICAgICAgICAgICAgICAndicsXG4gICAgdzogICAgICAgICAgICAgICd3JyxcbiAgICB4OiAgICAgICAgICAgICAgJ3gnLFxuICAgIHk6ICAgICAgICAgICAgICAneScsXG4gICAgejogICAgICAgICAgICAgICd6JyxcbiAgICBNdWx0aXBseU51bXBhZDogJyonLFxuICAgIFBsdXNOdW1wYWQ6ICAgICAnKycsXG4gICAgTWludXNOdW1wYWQ6ICAgICctJyxcbiAgICBEb3ROdW1wYWQ6ICAgICAgJy4nLFxuICAgIFNsYXNoTnVtcGFkOiAgICAnLycsXG4gICAgU2VtaWNvbG9uOiAgICAgICc7JyxcbiAgICBFcXVhbDogICAgICAgICAgJz0nLFxuICAgIENvbW1hOiAgICAgICAgICAnLCcsXG4gICAgSHlwaGVuOiAgICAgICAgICctJyxcbiAgICBNaW51czogICAgICAgICAgJy0nLFxuICAgIFBsdXM6ICAgICAgICAgICAnKycsXG4gICAgRG90OiAgICAgICAgICAgICcuJyxcbiAgICBTbGFzaDogICAgICAgICAgJy8nLFxuICAgIEJhY2txdW90ZTogICAgICAnYCcsXG4gICAgTGVmdEJyYWNrZXQ6ICAgICdbJyxcbiAgICBSaWdodEJyYWNrZXQ6ICAgJ10nLFxuICAgIEJhY2tzbGFzaDogICAgICAnXFxcXCcsXG4gICAgUXVvdGU6ICAgICAgICAgIFwiJ1wiLFxufTtcblxuY29uc3QgZGVmYXVsdE1pbmltdW1WYWx1ZSAgICAgPSAnLTk5OTk5OTk5OTk5OS45OSc7XG5jb25zdCBkZWZhdWx0TWF4aW11bVZhbHVlICAgICA9ICc5OTk5OTk5OTk5OTkuOTknO1xuY29uc3QgZGVmYXVsdFJvdW5kaW5nTWV0aG9kICAgPSAnVSc7XG5jb25zdCBkZWZhdWx0TGVhZGluZ1plcm8gICAgICA9ICdkZW55JztcbmNvbnN0IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5ID0gdHJ1ZTtcblxuLyoqXG4gKiBQcmVkZWZpbmVkIG9wdGlvbnMgZm9yIHRoZSBtb3N0IGNvbW1vbiBsYW5ndWFnZXNcbiAqL1xuY29uc3QgbGFuZ3VhZ2VPcHRpb24gPSB7XG4gICAgRnJlbmNoOiB7IC8vIEZyYW7Dp2Fpc1xuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICA6ICcuJywgLy8gb3IgJ1xcdTIwMmYnXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgICAgIDogJywnLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmU6ICcuJyxcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgOiAnXFx1MjAyZuKCrCcsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ICAgIDogJ3MnLFxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgICAgICA6IGRlZmF1bHRTZWxlY3ROdW1iZXJPbmx5LFxuICAgICAgICByb3VuZGluZ01ldGhvZCAgICAgICAgICAgICA6IGRlZmF1bHRSb3VuZGluZ01ldGhvZCxcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgICAgIDogZGVmYXVsdE1pbmltdW1WYWx1ZSxcbiAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICAgICAgOiBkZWZhdWx0TWF4aW11bVZhbHVlLFxuICAgIH0sXG4gICAgTm9ydGhBbWVyaWNhbjoge1xuICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgIDogJywnLFxuICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgIDogJy4nLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbCAgICAgICAgIDogJyQnLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgIDogZGVmYXVsdFNlbGVjdE51bWJlck9ubHksXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWluaW11bVZhbHVlLFxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcbiAgICB9LFxuICAgIEJyaXRpc2g6IHtcbiAgICAgICAgZGlnaXRHcm91cFNlcGFyYXRvciAgICA6ICcsJyxcbiAgICAgICAgZGVjaW1hbENoYXJhY3RlciAgICAgICA6ICcuJyxcbiAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICA6ICfCoycsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncCcsXG4gICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcbiAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICA6IGRlZmF1bHRSb3VuZGluZ01ldGhvZCxcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcbiAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXG4gICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWF4aW11bVZhbHVlLFxuICAgIH0sXG4gICAgU3dpc3M6IHsgLy8gU3Vpc3NlXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgOiBgJ2AsXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgOiAnLicsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgOiAnXFx1MjAyZkNIRicsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiAncycsXG4gICAgICAgIHNlbGVjdE51bWJlck9ubHkgICAgICAgOiBkZWZhdWx0U2VsZWN0TnVtYmVyT25seSxcbiAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICA6IGRlZmF1bHRSb3VuZGluZ01ldGhvZCxcbiAgICAgICAgbGVhZGluZ1plcm8gICAgICAgICAgICA6IGRlZmF1bHRMZWFkaW5nWmVybyxcbiAgICAgICAgbWluaW11bVZhbHVlICAgICAgICAgICA6IGRlZmF1bHRNaW5pbXVtVmFsdWUsXG4gICAgICAgIG1heGltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWF4aW11bVZhbHVlLFxuICAgIH0sXG4gICAgSmFwYW5lc2U6IHsgLy8g5pel5pys6KqeXG4gICAgICAgIGRpZ2l0R3JvdXBTZXBhcmF0b3IgICAgOiAnLCcsXG4gICAgICAgIGRlY2ltYWxDaGFyYWN0ZXIgICAgICAgOiAnLicsXG4gICAgICAgIGN1cnJlbmN5U3ltYm9sICAgICAgICAgOiAnwqUnLFxuICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudDogJ3AnLFxuICAgICAgICBzZWxlY3ROdW1iZXJPbmx5ICAgICAgIDogZGVmYXVsdFNlbGVjdE51bWJlck9ubHksXG4gICAgICAgIHJvdW5kaW5nTWV0aG9kICAgICAgICAgOiBkZWZhdWx0Um91bmRpbmdNZXRob2QsXG4gICAgICAgIGxlYWRpbmdaZXJvICAgICAgICAgICAgOiBkZWZhdWx0TGVhZGluZ1plcm8sXG4gICAgICAgIG1pbmltdW1WYWx1ZSAgICAgICAgICAgOiBkZWZhdWx0TWluaW11bVZhbHVlLFxuICAgICAgICBtYXhpbXVtVmFsdWUgICAgICAgICAgIDogZGVmYXVsdE1heGltdW1WYWx1ZSxcbiAgICB9LFxufTtcbmxhbmd1YWdlT3B0aW9uLlNwYW5pc2ggPSBsYW5ndWFnZU9wdGlvbi5GcmVuY2g7IC8vIEVzcGHDsW9sIChpZGVtIEZyZW5jaClcbmxhbmd1YWdlT3B0aW9uLkNoaW5lc2UgPSBsYW5ndWFnZU9wdGlvbi5KYXBhbmVzZTsgLy8g5Lit5Zu96KqeIChDaGluZXNlKVxuXG4vKipcbiAqIFVNRCBzdHJ1Y3R1cmVcbiAqL1xuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICAvL1RPRE8gVGhpcyBzdXJlbHkgY2FuIGJlIGltcHJvdmVkIGJ5IGxldHRpbmcgd2VicGFjayB0YWtlIGNhcmUgb2YgZ2VuZXJhdGluZyB0aGlzIFVNRCBwYXJ0XG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgLy8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuICAgIGRlZmluZShbJ2pxdWVyeSddLCBmYWN0b3J5KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAvLyBOb2RlL0NvbW1vbkpTXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoJ2pxdWVyeScpKTtcbn0gZWxzZSB7XG4gICAgLy8gQnJvd3NlciBnbG9iYWxzXG4gICAgZmFjdG9yeSh3aW5kb3cualF1ZXJ5KTtcbn1cbn0oJCA9PiB7XG4gICAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbFxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3RcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJuIFRSVUUgaWYgdGhlIGB2YWx1ZWAgaXMgbnVsbCwgRkFMU0Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYHZhbHVlYCBpcyB1bmRlZmluZWRcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgRkFMU0Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB2b2lkKDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBgdmFsdWVgIGlzIHVuZGVmaW5lZCwgbnVsbCBvciBlbXB0eVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQoMCkgfHwgJycgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBnaXZlbiBwYXJhbWV0ZXIgaXMgYSBTdHJpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gc3RyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XG4gICAgICAgIHJldHVybiAodHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgfHwgc3RyIGluc3RhbmNlb2YgU3RyaW5nKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgYm9vbGVhblxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Jvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZih2YWx1ZSkgPT09ICdib29sZWFuJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nICd0cnVlJyBvciAnZmFsc2UnXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW55IGNhc2VzIGZvciB0aG9zZSBzdHJpbmdzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVHJ1ZU9yRmFsc2VTdHJpbmcodmFsdWUpIHtcbiAgICAgICAgY29uc3QgbG93ZXJjYXNlVmFsdWUgPSBTdHJpbmcodmFsdWUpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBsb3dlcmNhc2VWYWx1ZSA9PT0gJ3RydWUnIHx8IGxvd2VyY2FzZVZhbHVlID09PSAnZmFsc2UnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHJlZmVyZW5jZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHJlZmVyZW5jZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgcmVmZXJlbmNlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHJlZmVyZW5jZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIG9iamVjdCBpcyBlbXB0eVxuICAgICAqIGNmLiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY3OTkxNS9ob3ctZG8taS10ZXN0LWZvci1hbi1lbXB0eS1qYXZhc2NyaXB0LW9iamVjdCBhbmQgaHR0cDovL2pzcGVyZi5jb20vZW1wdHktb2JqZWN0LXRlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5T2JqKG9iaikge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIgKG9yIGEgbnVtYmVyIHdyaXR0ZW4gYXMgYSBzdHJpbmcpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIobikge1xuICAgICAgICByZXR1cm4gIWlzQXJyYXkobikgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYW4gaW50ZWdlciAoYW5kIG5vdCBhIGZsb2F0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzSW50KG4pIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBuID09PSAnbnVtYmVyJyAmJiBwYXJzZUZsb2F0KG4pID09PSBwYXJzZUludChuLCAxMCkgJiYgIWlzTmFOKG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcGFzdGVkIHRleHQgdGhhdCB3aWxsIGJlIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dm9pZHxYTUx8Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwcmVwYXJlUGFzdGVkVGV4dCh0ZXh0LCBob2xkZXIpIHtcbiAgICAgICAgcmV0dXJuIHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh0ZXh0LCBob2xkZXIuc2V0dGluZ3NDbG9uZSwgdHJ1ZSkucmVwbGFjZShob2xkZXIuc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBUUlVFIGlzIHRoZSBzdHJpbmcgYHN0cmAgY29udGFpbnMgdGhlIHN0cmluZyBgbmVlZGxlYFxuICAgICAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY29lcmNlIHRoZSBwYXJhbWV0ZXJzIHR5cGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5lZWRsZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnRhaW5zKHN0ciwgbmVlZGxlKSB7XG4gICAgICAgIGlmICghaXNTdHJpbmcoc3RyKSB8fCAhaXNTdHJpbmcobmVlZGxlKSB8fCBzdHIgPT09ICcnIHx8IG5lZWRsZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzdHIuaW5kZXhPZihuZWVkbGUpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgYG5lZWRsZWAgaXMgaW4gdGhlIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IG5lZWRsZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbkFycmF5KG5lZWRsZSwgYXJyYXkpIHtcbiAgICAgICAgaWYgKCFpc0FycmF5KGFycmF5KSB8fCBhcnJheSA9PT0gW10gfHwgaXNVbmRlZmluZWQobmVlZGxlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFycmF5LmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIHBhcmFtZXRlciBpcyBhbiBBcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBhcnJcbiAgICAgKiBAdGhyb3dzIEVycm9yXG4gICAgICogQHJldHVybnMgeyp8Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0FycmF5KGFycikge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFtdKSA9PT0gJ1tvYmplY3QgQXJyYXldJykgeyAvLyBNYWtlIHN1cmUgYW4gYXJyYXkgaGFzIGEgY2xhc3MgYXR0cmlidXRlIG9mIFtvYmplY3QgQXJyYXldXG4gICAgICAgICAgICAvLyBUZXN0IHBhc3NlZCwgbm93IGNoZWNrIGlmIGlzIGFuIEFycmF5XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpIHx8ICh0eXBlb2YgYXJyID09PSAnb2JqZWN0JyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvU3RyaW5nIG1lc3NhZ2UgY2hhbmdlZCBmb3IgT2JqZWN0IEFycmF5Jyk7IC8vIFZlcmlmeSB0aGF0IHRoZSBzdHJpbmcgcmV0dXJuZWQgYnkgYHRvU3RyaW5nYCBkb2VzIG5vdCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSAoY2YuIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzgzNjUyMTUpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIGZsb2F0IG51bWJlciwgYW5kIHRoYXQgbnVtYmVyIGhhcyBhIGRlY2ltYWwgcGFydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIC8vIGZ1bmN0aW9uIGhhc0RlY2ltYWxzKHN0cikge1xuICAgIC8vICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAvLyAgICAgcmV0dXJuICFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk7XG4gICAgLy8gfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgYSBmbG9hdCBudW1iZXIsIGFuZCB0aGF0IG51bWJlciBoYXMgYSBkZWNpbWFsIHBhcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gICAgICogQHJldHVybnMge2ludH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkZWNpbWFsUGxhY2VzKHN0cikge1xuICAgICAgICBjb25zdCBbLCBkZWNpbWFsUGFydF0gPSBzdHIuc3BsaXQoJy4nKTtcbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkZWNpbWFsUGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNpbWFsUGFydC5sZW5ndGg7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGNvZGUgZm9yIHRoZSBrZXkgdXNlZCB0byBnZW5lcmF0ZSB0aGUgZ2l2ZW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8TnVtYmVyfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleUNvZGVOdW1iZXIoZXZlbnQpIHtcbiAgICAgICAgLy8gYGV2ZW50LmtleUNvZGVgIGFuZCBgZXZlbnQud2hpY2hgIGFyZSBkZXByZWNhdGVkLCBgS2V5Ym9hcmRFdmVudC5rZXlgIChodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkpIG11c3QgYmUgdXNlZCBub3dcbiAgICAgICAgcmV0dXJuICh0eXBlb2YgZXZlbnQud2hpY2ggPT09ICd1bmRlZmluZWQnKT9ldmVudC5rZXlDb2RlOmV2ZW50LndoaWNoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2hhcmFjdGVyIGZyb20gdGhlIGV2ZW50IGtleSBjb2RlLlxuICAgICAqIEBleGFtcGxlIGNoYXJhY3Rlcig1MCkgPT4gJzInXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hhcmFjdGVyKGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQua2V5ID09PSAndW5kZWZpbmVkJyB8fCBldmVudC5rZXkgPT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlDb2RlTnVtYmVyKGV2ZW50KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQua2V5O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHZhbHVlIChhIG51bWJlciBhcyBhIHN0cmluZykgaXMgd2l0aGluIHRoZSByYW5nZSBzZXQgaW4gdGhlIHNldHRpbmdzIGBtaW5pbXVtVmFsdWVgIGFuZCBgbWF4aW11bVZhbHVlYCwgRkFMU0Ugb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHBhcnNlZE1pblZhbHVlIFBhcnNlZCB2aWEgdGhlIGBwYXJzZVN0cigpYCBmdW5jdGlvblxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZWRNYXhWYWx1ZSBQYXJzZWQgdmlhIHRoZSBgcGFyc2VTdHIoKWAgZnVuY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGVja0lmSW5SYW5nZSh2YWx1ZSwgcGFyc2VkTWluVmFsdWUsIHBhcnNlZE1heFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VTdHIodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGVzdE1pbk1heChwYXJzZWRNaW5WYWx1ZSwgcGFyc2VkVmFsdWUpID4gLTEgJiYgdGVzdE1pbk1heChwYXJzZWRNYXhWYWx1ZSwgcGFyc2VkVmFsdWUpIDwgMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGNvbnRhaW5zIGEgbmVnYXRpdmUgc2lnbiA6XG4gICAgICogLSBldmVyeXdoZXJlIGluIHRoZSBzdHJpbmcgKGJ5IGRlZmF1bHQpLCBvclxuICAgICAqIC0gb24gdGhlIGZpcnN0IGNoYXJhY3RlciBvbmx5IGlmIHRoZSBgY2hlY2tFdmVyeXdoZXJlYCBwYXJhbWV0ZXIgaXMgc2V0IHRvIGBmYWxzZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbnVtZXJpY1N0cmluZyBBIG51bWJlciByZXByZXNlbnRlZCBieSBhIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tFdmVyeXdoZXJlIElmIFRSVUUsIHRoZW4gdGhlIG5lZ2F0aXZlIHNpZ24gaXMgc2VhcmNoIGV2ZXJ5d2hlcmUgaW4gdGhlIG51bWVyaWMgc3RyaW5nICh0aGlzIGlzIG5lZWRlZCBmb3IgaW5zdGFuY2UgaWYgdGhlIHN0cmluZyBpcyAnMTIzNC41Ni0nKVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmVnYXRpdmUobnVtZXJpY1N0cmluZywgY2hlY2tFdmVyeXdoZXJlID0gdHJ1ZSkge1xuICAgICAgICAvL1RPRE8gVXNlIHRoZSBgbmVnYXRpdmVTaWduQ2hhcmFjdGVyYCBmcm9tIHRoZSBzZXR0aW5ncyBoZXJlXG4gICAgICAgIGlmIChjaGVja0V2ZXJ5d2hlcmUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250YWlucyhudW1lcmljU3RyaW5nLCAnLScpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGlzTmVnYXRpdmVTdHJpY3QobnVtZXJpY1N0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIFRSVUUgaWYgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyBhIG5lZ2F0aXZlIHNpZ24gb24gdGhlIGZpcnN0IGNoYXJhY3RlciAob24gdGhlIGZhciBsZWZ0KS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIGlzTmVnYXRpdmVTdHJpY3QoJzEyMzQuNTYnKSAgICAgPT4gZmFsc2VcbiAgICAgKiBAZXhhbXBsZSBpc05lZ2F0aXZlU3RyaWN0KCcxMjM0LjU2LScpICAgID0+IGZhbHNlXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnLTEyMzQuNTYnKSAgICA9PiB0cnVlXG4gICAgICogQGV4YW1wbGUgaXNOZWdhdGl2ZVN0cmljdCgnLTEsMjM0LjU2IOKCrCcpID0+IHRydWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW1lcmljU3RyaW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOZWdhdGl2ZVN0cmljdChudW1lcmljU3RyaW5nKSB7XG4gICAgICAgIC8vVE9ETyBVc2luZyB0aGUgYG5lZ2F0aXZlU2lnbkNoYXJhY3RlcmAgZnJvbSB0aGUgc2V0dGluZ3MgaGVyZVxuICAgICAgICByZXR1cm4gbnVtZXJpY1N0cmluZy5jaGFyQXQoMCkgPT09ICctJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpZiB0aGUgZm9ybWF0dGVkIG9yIHVuZm9ybWF0dGVkIG51bWVyaWMgc3RyaW5nIHJlcHJlc2VudCB0aGUgdmFsdWUgMCAoaWUuICcwLDAwIOKCrCcpLCBvciBpcyBlbXB0eSAoJyDigqwnKS5cbiAgICAgKiBUaGlzIHdvcmtzIHNpbmNlIHdlIHRlc3QgaWYgdGhlcmUgYXJlIGFueSBudW1iZXJzIGZyb20gMSB0byA5IGluIHRoZSBzdHJpbmcuIElmIHRoZXJlIGlzIG5vbmUsIHRoZW4gdGhlIG51bWJlciBpcyB6ZXJvIChvciB0aGUgc3RyaW5nIGlzIGVtcHR5KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBudW1lcmljU3RyaW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNaZXJvT3JIYXNOb1ZhbHVlKG51bWVyaWNTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuICEoL1sxLTldL2cpLnRlc3QobnVtZXJpY1N0cmluZyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBuZWdhdGl2ZSB2ZXJzaW9uIG9mIHRoZSB2YWx1ZSAocmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcpIGdpdmVuIGFzIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0UmF3TmVnYXRpdmVTaWduKHZhbHVlKSB7XG4gICAgICAgIGlmICghaXNOZWdhdGl2ZVN0cmljdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBgLSR7dmFsdWV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlIHRoZSBjaGFyYWN0ZXIgYXQgdGhlIHBvc2l0aW9uIGBpbmRleGAgaW4gdGhlIHN0cmluZyBgc3RyaW5nYCBieSB0aGUgY2hhcmFjdGVyKHMpIGBuZXdDaGFyYWN0ZXJgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7aW50fSBpbmRleFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdDaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2VDaGFyQXQoc3RyaW5nLCBpbmRleCwgbmV3Q2hhcmFjdGVyKSB7XG4gICAgICAgIHJldHVybiBgJHtzdHJpbmcuc3Vic3RyKDAsIGluZGV4KX0ke25ld0NoYXJhY3Rlcn0ke3N0cmluZy5zdWJzdHIoaW5kZXggKyBuZXdDaGFyYWN0ZXIubGVuZ3RoKX1gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgY2xhbXBlZCB0byB0aGUgbmVhcmVzdCBtaW5pbXVtL21heGltdW0gdmFsdWUsIGFzIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xhbXBUb1JhbmdlTGltaXRzKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICAvL1hYWCBUaGlzIGZ1bmN0aW9uIGFsd2F5cyBhc3N1bWUgYHNldHRpbmdzLm1pbmltdW1WYWx1ZWAgaXMgbG93ZXIgdGhhbiBgc2V0dGluZ3MubWF4aW11bVZhbHVlYFxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBNYXRoLm1pbihzZXR0aW5ncy5tYXhpbXVtVmFsdWUsIHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbnVtYmVyIG9yIGRvdCBjaGFyYWN0ZXJzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGNhcmV0LCBpbiBhIGZvcm1hdHRlZCBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTnVtYmVyU3RyaW5nXG4gICAgICogQHBhcmFtIHtpbnR9IGNhcmV0UG9zaXRpb24gVGhpcyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkZWNpbWFsQ2hhcmFjdGVyXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoZm9ybWF0dGVkTnVtYmVyU3RyaW5nLCBjYXJldFBvc2l0aW9uLCBkZWNpbWFsQ2hhcmFjdGVyKSB7XG4gICAgICAgIC8vIEhlcmUgd2UgY291bnQgdGhlIGRvdCBhbmQgcmVwb3J0IGl0IGFzIGEgbnVtYmVyIGNoYXJhY3RlciB0b28sIHNpbmNlIGl0IHdpbGwgJ3N0YXknIGluIHRoZSBKYXZhc2NyaXB0IG51bWJlciB3aGVuIHVuZm9ybWF0dGVkXG4gICAgICAgIGNvbnN0IG51bWJlckRvdE9yTmVnYXRpdmVTaWduID0gbmV3IFJlZ0V4cChgWzAtOSR7ZGVjaW1hbENoYXJhY3Rlcn0tXWApOyAvLyBObyBuZWVkIHRvIGVzY2FwZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaGVyZSwgc2luY2UgaXQncyBpbiBgW11gXG5cbiAgICAgICAgbGV0IG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50ID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYXJldFBvc2l0aW9uOyBpKyspIHtcbiAgICAgICAgICAgIC8vIFRlc3QgaWYgdGhlIGNoYXJhY3RlciBpcyBhIG51bWJlciwgYSBkb3Qgb3IgYW4gaHlwaGVuLiBJZiBpdCBpcywgY291bnQgaXQsIG90aGVyd2lzZSBpZ25vcmUgaXRcbiAgICAgICAgICAgIGlmIChudW1iZXJEb3RPck5lZ2F0aXZlU2lnbi50ZXN0KGZvcm1hdHRlZE51bWJlclN0cmluZ1tpXSkpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJEb3RBbmROZWdhdGl2ZVNpZ25Db3VudCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bWJlckRvdEFuZE5lZ2F0aXZlU2lnbkNvdW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdhbGsgdGhlIGBmb3JtYXR0ZWROdW1iZXJTdHJpbmdgIGZyb20gbGVmdCB0byByaWdodCwgb25lIGNoYXIgYnkgb25lLCBjb3VudGluZyB0aGUgYGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4YC5cbiAgICAgKiBJZiB0aGUgY2hhciBpcyBpbiB0aGUgYHJhd051bWJlclN0cmluZ2AgKHN0YXJ0aW5nIGF0IGluZGV4IDApLCB0aGVuIGByYXdOdW1iZXJTdHJpbmdJbmRleCsrYCwgYW5kIGNvbnRpbnVlIHVudGlsXG4gICAgICogdGhlcmUgaXMgbm8gbW9yZSBjaGFyYWN0ZXJzIGluIGByYXdOdW1iZXJTdHJpbmdgKSBvciB0aGF0IGByYXdOdW1iZXJTdHJpbmdJbmRleCA9PT0gY2FyZXRQb3NpdGlvbkluUmF3VmFsdWVgLlxuICAgICAqIFdoZW4geW91IHN0b3AsIHRoZSBgZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhgIGlzIHRoZSBwb3NpdGlvbiB3aGVyZSB0aGUgY2FyZXQgc2hvdWxkIGJlIHNldC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogMTIzNDU2N3w4OS4wMSAgIDogcG9zaXRpb24gNyAocmF3TnVtYmVyU3RyaW5nKVxuICAgICAqIDEyMy40NTYuN3w4OSwwMSA6IHBvc2l0aW9uIDkgKGZvcm1hdHRlZE51bWJlclN0cmluZylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByYXdOdW1iZXJTdHJpbmdcbiAgICAgKiBAcGFyYW0ge2ludH0gY2FyZXRQb3NpdGlvbkluUmF3VmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZm9ybWF0dGVkTnVtYmVyU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRlY2ltYWxDaGFyYWN0ZXJcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyKHJhd051bWJlclN0cmluZywgY2FyZXRQb3NpdGlvbkluUmF3VmFsdWUsIGZvcm1hdHRlZE51bWJlclN0cmluZywgZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWROdW1iZXJTdHJpbmdTaXplID0gZm9ybWF0dGVkTnVtYmVyU3RyaW5nLmxlbmd0aDtcbiAgICAgICAgY29uc3QgcmF3TnVtYmVyU3RyaW5nU2l6ZSA9IHJhd051bWJlclN0cmluZy5sZW5ndGg7XG5cbiAgICAgICAgbGV0IGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4O1xuICAgICAgICBsZXQgcmF3TnVtYmVyU3RyaW5nSW5kZXggPSAwO1xuICAgICAgICBmb3IgKGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4ID0gMDtcbiAgICAgICAgICAgICBmb3JtYXR0ZWROdW1iZXJTdHJpbmdJbmRleCA8IGZvcm1hdHRlZE51bWJlclN0cmluZ1NpemUgJiZcbiAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCA8IHJhd051bWJlclN0cmluZ1NpemUgJiZcbiAgICAgICAgICAgICByYXdOdW1iZXJTdHJpbmdJbmRleCA8IGNhcmV0UG9zaXRpb25JblJhd1ZhbHVlO1xuICAgICAgICAgICAgIGZvcm1hdHRlZE51bWJlclN0cmluZ0luZGV4KyspIHtcbiAgICAgICAgICAgIGlmIChyYXdOdW1iZXJTdHJpbmdbcmF3TnVtYmVyU3RyaW5nSW5kZXhdID09PSBmb3JtYXR0ZWROdW1iZXJTdHJpbmdbZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhdIHx8XG4gICAgICAgICAgICAgICAgKHJhd051bWJlclN0cmluZ1tyYXdOdW1iZXJTdHJpbmdJbmRleF0gPT09ICcuJyAmJiBmb3JtYXR0ZWROdW1iZXJTdHJpbmdbZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXhdID09PSBkZWNpbWFsQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIHJhd051bWJlclN0cmluZ0luZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZm9ybWF0dGVkTnVtYmVyU3RyaW5nSW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ291bnQgdGhlIG51bWJlciBvZiBvY2N1cnJlbmNlIG9mIHRoZSBnaXZlbiBjaGFyYWN0ZXIsIGluIHRoZSBnaXZlbiB0ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNoYXJhY3RlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3VudENoYXJJblRleHQoY2hhcmFjdGVyLCB0ZXh0KSB7XG4gICAgICAgIGxldCBjaGFyQ291bnRlciA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHRleHRbaV0gPT09IGNoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgIGNoYXJDb3VudGVyKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2hhckNvdW50ZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBpbmRleCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldCB0aGUgY2FyZXQgcG9zaXRpb24uXG4gICAgICogVGhpcyB0YWtlcyBpbnRvIGFjY291bnQgdGhhdCB0aGUgcG9zaXRpb24gaXMgc3RhcnRpbmcgYXQgJzAnLCBub3QgMS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW50fSBjaGFyYWN0ZXJDb3VudFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNoYXJhY3RlckNvdW50KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChjaGFyYWN0ZXJDb3VudCwgY2hhcmFjdGVyQ291bnQgLSAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIGdldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEV2ZW50VGFyZ2V0fSB0aGF0XG4gICAgICogQHJldHVybnMge3t9fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEVsZW1lbnRTZWxlY3Rpb24odGhhdCkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHt9O1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQodGhhdC5zZWxlY3Rpb25TdGFydCkpIHtcbiAgICAgICAgICAgIHRoYXQuZm9jdXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdCA9IGRvY3VtZW50LnNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcG9zaXRpb24ubGVuZ3RoID0gc2VsZWN0LnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgc2VsZWN0Lm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLXRoYXQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICAgIHBvc2l0aW9uLmVuZCA9IHNlbGVjdC50ZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgIHBvc2l0aW9uLnN0YXJ0ID0gcG9zaXRpb24uZW5kIC0gcG9zaXRpb24ubGVuZ3RoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zaXRpb24uc3RhcnQgPSB0aGF0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgcG9zaXRpb24uZW5kID0gdGhhdC5zZWxlY3Rpb25FbmQ7XG4gICAgICAgICAgICBwb3NpdGlvbi5sZW5ndGggPSBwb3NpdGlvbi5lbmQgLSBwb3NpdGlvbi5zdGFydDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHJvdXRpbmUgZm9yIHNldHRpbmcgc2VsZWN0ZWQgcmFuZ2UvY3Vyc29yIHBvc2l0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fEV2ZW50VGFyZ2V0fSB0aGF0XG4gICAgICogQHBhcmFtIHtpbnR9IHN0YXJ0XG4gICAgICogQHBhcmFtIHtpbnR8bnVsbH0gZW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0RWxlbWVudFNlbGVjdGlvbih0aGF0LCBzdGFydCwgZW5kID0gbnVsbCkge1xuICAgICAgICBpZiAoaXNVbmRlZmluZWRPck51bGxPckVtcHR5KGVuZCkpIHtcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoYXQuc2VsZWN0aW9uU3RhcnQpKSB7XG4gICAgICAgICAgICB0aGF0LmZvY3VzKCk7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHRoYXQuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgICAgICAgICByYW5nZS5jb2xsYXBzZSh0cnVlKTtcbiAgICAgICAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCk7XG4gICAgICAgICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgICAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgdGhhdC5zZWxlY3Rpb25FbmQgPSBlbmQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0aGF0IHRocm93IGVycm9yIG1lc3NhZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocm93RXJyb3IobWVzc2FnZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBkaXNwbGF5IGEgd2FybmluZyBtZXNzYWdlcywgYWNjb3JkaW5nIHRvIHRoZSBkZWJ1ZyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaG93V2FybmluZyBJZiBGQUxTRSwgdGhlbiB0aGUgd2FybmluZyBtZXNzYWdlIGlzIG5vdCBkaXNwbGF5ZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3YXJuaW5nKG1lc3NhZ2UsIHNob3dXYXJuaW5nID0gdHJ1ZSkge1xuICAgICAgICBpZiAoc2hvd1dhcm5pbmcpIHtcbiAgICAgICAgICAgIC8qIGVzbGludCBuby1jb25zb2xlOiAwICovXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGF1dG9OdW1lcmljLXNwZWNpZmljIGZ1bmN0aW9uc1xuXG4gICAgLyoqXG4gICAgICogUnVuIGFueSBjYWxsYmFja3MgZm91bmQgaW4gdGhlIHNldHRpbmdzIG9iamVjdC5cbiAgICAgKiBBbnkgcGFyYW1ldGVyIGNvdWxkIGJlIGEgY2FsbGJhY2s6XG4gICAgICogLSBhIGZ1bmN0aW9uLCB3aGljaCBpbnZva2VkIHdpdGggalF1ZXJ5IGVsZW1lbnQsIHBhcmFtZXRlcnMgYW5kIHRoaXMgcGFyYW1ldGVyIG5hbWUgYW5kIHJldHVybnMgcGFyYW1ldGVyIHZhbHVlXG4gICAgICogLSBhIG5hbWUgb2YgZnVuY3Rpb24sIGF0dGFjaGVkIHRvICQoc2VsZWN0b3IpLmF1dG9OdW1lcmljLmZ1bmN0aW9uTmFtZSgpe30gLSB3aGljaCB3YXMgY2FsbGVkIHByZXZpb3VzbHlcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gcnVuQ2FsbGJhY2tzRm91bmRJblRoZVNldHRpbmdzT2JqZWN0KCR0aGlzLCBzZXR0aW5ncykge1xuICAgICAgICAvLyBMb29wcyB0aHJvdWdoIHRoZSBzZXR0aW5ncyBvYmplY3QgKG9wdGlvbiBhcnJheSkgdG8gZmluZCB0aGUgZm9sbG93aW5nXG4gICAgICAgICQuZWFjaChzZXR0aW5ncywgKGssIHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trXSA9IHZhbCgkdGhpcywgc2V0dGluZ3MsIGspO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgJHRoaXMuYXV0b051bWVyaWNbdmFsXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8vIENhbGxzIHRoZSBhdHRhY2hlZCBmdW5jdGlvbiBmcm9tIHRoZSBodG1sNSBkYXRhIGV4YW1wbGU6IGRhdGEtYS1zaWduPVwiZnVuY3Rpb25OYW1lXCJcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trXSA9ICR0aGlzLmF1dG9OdW1lcmljW3ZhbF0oJHRoaXMsIHNldHRpbmdzLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lIHRoZSBtYXhpbXVtIGRlY2ltYWwgbGVuZ3RoIGZyb20gdGhlIG1pbmltdW1WYWx1ZSBhbmQgbWF4aW11bVZhbHVlIHNldHRpbmdzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWluaW11bVZhbHVlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1heGltdW1WYWx1ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4aW11bVZNaW5BbmRWTWF4RGVjaW1hbExlbmd0aChtaW5pbXVtVmFsdWUsIG1heGltdW1WYWx1ZSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoZGVjaW1hbFBsYWNlcyhtaW5pbXVtVmFsdWUpLCBkZWNpbWFsUGxhY2VzKG1heGltdW1WYWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0cmlwIGFsbCB1bndhbnRlZCBub24tbnVtYmVyIGNoYXJhY3RlcnMuXG4gICAgICogVGhpcyBrZWVwcyB0aGUgbnVtYmVycywgdGhlIG5lZ2F0aXZlIHNpZ24gYXMgd2VsbCBhcyB0aGUgY3VzdG9tIGRlY2ltYWwgY2hhcmFjdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGxlZnRPckFsbFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMocywgc2V0dGluZ3MsIGxlZnRPckFsbCkge1xuICAgICAgICAvL1RPRE8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgMTAgdGltZXMgKHNpYyEpIG9uIGVhY2gga2V5IGlucHV0LCBjb3VsZG4ndCB3ZSBsb3dlciB0aGF0IG51bWJlcj8gY2YuIGlzc3VlICMzMjVcbiAgICAgICAgLy9UT0RPIFJlZmFjdG9yIHRoaXMgd2l0aCBgY29udmVydFRvTnVtZXJpY1N0cmluZygpYCBpZiBwb3NzaWJsZT9cbiAgICAgICAgaWYgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICE9PSAnJykge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGN1cnJlbmN5IHNpZ25cbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wsICcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3Muc3VmZml4VGV4dCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN1ZmZpeFxuICAgICAgICAgICAgd2hpbGUgKGNvbnRhaW5zKHMsIHNldHRpbmdzLnN1ZmZpeFRleHQpKSB7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5zdWZmaXhUZXh0LCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaXJzdCByZXBsYWNlIGFueXRoaW5nIGJlZm9yZSBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwRmlyc3RBdXRvU3RyaXAsICckMSQyJyk7XG5cbiAgICAgICAgaWYgKChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnIHx8XG4gICAgICAgICAgICAoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCAhPT0gJ3AnKSkgJiZcbiAgICAgICAgICAgIGlzTmVnYXRpdmUocykgJiZcbiAgICAgICAgICAgIHMgIT09ICcnKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZW4gcmVwbGFjZSBhbnl0aGluZyBhZnRlciBkaWdpdHNcbiAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCwgJyQxJyk7XG5cbiAgICAgICAgLy8gVGhlbiByZW1vdmUgYW55IHVuaW50ZXJlc3RpbmcgY2hhcmFjdGVyc1xuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmFsbG93ZWRBdXRvU3RyaXAsICcnKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUsIHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IG9ubHkgbnVtYmVyIHN0cmluZ1xuICAgICAgICBjb25zdCBtID0gcy5tYXRjaChzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXApO1xuICAgICAgICBzID0gbSA/IFttWzFdLCBtWzJdLCBtWzNdXS5qb2luKCcnKSA6ICcnO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JyB8fCBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICBsZXQgblNpZ24gPSAnJztcbiAgICAgICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gcy5zcGxpdChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgICAgIGxldCBtb2RpZmllZEludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQ7XG4gICAgICAgICAgICBpZiAoY29udGFpbnMobW9kaWZpZWRJbnRlZ2VyUGFydCwgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgIG5TaWduID0gc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIG1vZGlmaWVkSW50ZWdlclBhcnQgPSBtb2RpZmllZEludGVnZXJQYXJ0LnJlcGxhY2Uoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyLCAnJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludFBvcyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkXG4gICAgICAgICAgICBpZiAoblNpZ24gIT09ICcnICYmIG1vZGlmaWVkSW50ZWdlclBhcnQubGVuZ3RoID4gc2V0dGluZ3MubUludE5lZyAmJiBtb2RpZmllZEludGVnZXJQYXJ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgbW9kaWZpZWRJbnRlZ2VyUGFydCA9IG1vZGlmaWVkSW50ZWdlclBhcnQuc2xpY2UoMSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHMgPSBgJHtuU2lnbn0ke21vZGlmaWVkSW50ZWdlclBhcnR9JHtpc1VuZGVmaW5lZChkZWNpbWFsUGFydCk/Jyc6c2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciArIGRlY2ltYWxQYXJ0fWA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGxlZnRPckFsbCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2RlbnknKSB8fFxuICAgICAgICAgICAgKCFzZXR0aW5ncy5oYXNGb2N1cyAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JykpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3Muc3RyaXBSZWcsICckMSQyJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG9yIHJlbW92ZXMgYnJhY2tldHMgb24gbmVnYXRpdmUgdmFsdWVzLCBkZXBlbmRpbmcgb24gdGhlIGZvY3VzIHN0YXRlLlxuICAgICAqIFRoZSBmb2N1cyBzdGF0ZSBpcyAnc3RvcmVkJyBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0IHVuZGVyIHRoZSBgc2V0dGluZ3MuaGFzRm9jdXNgIGF0dHJpYnV0ZS5cbiAgICAgKiAvL1RPRE8gVXNlIGFub3RoZXIgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2YgaW50ZXJuYWwgZGF0YSB0aGF0IGFyZSBub3Qgc2V0dGluZ3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmICgoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ2wnKSB8fFxuICAgICAgICAgICAgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycgJiYgc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdwJykpIHtcbiAgICAgICAgICAgIC8vVE9ETyBTcGxpdCB0aGUgZmlyc3QgYW5kIGxhc3QgYnJhY2tldCBvbmx5IG9uY2UgZHVyaW5nIHRoZSBzZXR0aW5ncyBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgY29uc3QgW2ZpcnN0QnJhY2tldCwgbGFzdEJyYWNrZXRdID0gc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIuc3BsaXQoJywnKTtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuaGFzRm9jdXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYnJhY2tldHNcbiAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciwgJycpO1xuICAgICAgICAgICAgICAgIHMgPSBmaXJzdEJyYWNrZXQgKyBzICsgbGFzdEJyYWNrZXQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmhhc0ZvY3VzICYmIHMuY2hhckF0KDApID09PSBmaXJzdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgYnJhY2tldHNcbiAgICAgICAgICAgICAgICAvL1RPRE8gUXVpZCBpZiB0aGUgbmVnYXRpdmUgc2lnbiBpcyBub3Qgb24gdGhlIGxlZnQsIHNob3VsZG4ndCB3ZSByZXBsYWNlIHRoZSAnLScgc2lnbiBhdCB0aGUgcmlnaHQgcGxhY2U/XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShmaXJzdEJyYWNrZXQsIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgcyA9IHMucmVwbGFjZShsYXN0QnJhY2tldCwgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGEgbnVtYmVyIGFzIGEgbnVtZXJpYyBzdHJpbmcgdGhhdCBjYW4gYmUgdHlwZWNhc3QgdG8gYSBOdW1iZXIgdGhhdCBKYXZhc2NyaXB0IHdpbGwgdW5kZXJzdGFuZC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gcmV0dXJuIHRoZSBnaXZlbiBzdHJpbmcgYnkgc3RyaXBwaW5nIHRoZSBjdXJyZW5jeSBzaWduIChjdXJyZW5jeVN5bWJvbCksIHRoZSBncm91cGluZyBzZXBhcmF0b3JzIChkaWdpdGFsR3JvdXBTcGFjaW5nKSBhbmQgYnkgcmVwbGFjaW5nIHRoZSBkZWNpbWFsIGNoYXJhY3RlciAoZGVjaW1hbENoYXJhY3RlcikgYnkgYSBkb3QuXG4gICAgICogTGFzdGx5LCBpdCBhbHNvIHB1dCB0aGUgbmVnYXRpdmUgc2lnbiBiYWNrIHRvIGl0cyBub3JtYWwgcG9zaXRpb24gaWYgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfHZvaWR8WE1MfCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY29udmVydFRvTnVtZXJpY1N0cmluZyhzLCBzZXR0aW5ncykge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGN1cnJlbmN5IHN5bWJvbFxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLCAnJyk7XG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBncm91cGluZyBzZXBhcmF0b3JzICh0aG91c2FuZHMgc2VwYXJhdG9ycyB1c3VhbGx5KVxuICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRpZ2l0R3JvdXBTZXBhcmF0b3IsICcnKTtcblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBieSBhIGRvdFxuICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciAhPT0gJy4nKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ZlIHRoZSB0cmFpbGluZyBuZWdhdGl2ZSBzaWduIHRvIHRoZSByaWdodCBwb3NpdGlvbiwgaWYgYW55XG4gICAgICAgIGlmIChpc05lZ2F0aXZlKHMpICYmIHMubGFzdEluZGV4T2YoJy0nKSA9PT0gcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgcyA9ICctJyArIHM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0IGFueSBhcmFiaWMgbnVtYmVycyB0byBsYXRpbiBvbmVzXG4gICAgICAgIGNvbnN0IHRlbXAgPSBhcmFiaWNUb0xhdGluTnVtYmVycyhzLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBpZiAoIWlzTmFOKHRlbXApKSB7XG4gICAgICAgICAgICBzID0gdGVtcC50b1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIElTTyBudW1lcmljIHN0cmluZyB0byB0aGUgbG9jYWxlIGRlY2ltYWwgYW5kIG1pbnVzIHNpZ24gcGxhY2VtZW50LlxuICAgICAqIFNlZSB0aGUgXCJvdXRwdXRGb3JtYXRcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9Mb2NhbGUodmFsdWUsIGxvY2FsZSkge1xuICAgICAgICBpZiAoaXNOdWxsKGxvY2FsZSkgfHwgbG9jYWxlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgc3dpdGNoIChsb2NhbGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJy4tJzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpc05lZ2F0aXZlKHZhbHVlKSA/IHZhbHVlLnJlcGxhY2UoJy0nLCAnJykgKyAnLScgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJywnOlxuICAgICAgICAgICAgY2FzZSAnLSwnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLC0nOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLnJlcGxhY2UoJy4nLCAnLCcpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGlzTmVnYXRpdmUocmVzdWx0KSA/IHJlc3VsdC5yZXBsYWNlKCctJywgJycpICsgJy0nIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgY2FzZVxuICAgICAgICAgICAgY2FzZSAnLic6XG4gICAgICAgICAgICBjYXNlICctLic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZ2l2ZW4gb3V0cHV0Rm9ybWF0IFske2xvY2FsZX1dIG9wdGlvbiBpcyBub3QgcmVjb2duaXplZC5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBuZWdhdGl2ZSBzaWduIGFuZCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgb2YgdGhlIGdpdmVuIHN0cmluZyB2YWx1ZSB0byBhbiBoeXBoZW4gKC0pIGFuZCBhIGRvdCAoLikgaW4gb3JkZXIgdG8gbWFrZSB0aGF0IHZhbHVlICd0eXBlY2FzdGFibGUnIHRvIGEgcmVhbCBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2Uoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlciwgJy4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnLScgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIsICctJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzLm1hdGNoKC9cXGQvKSkge1xuICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgdmFsdWUgcmV0dXJuZWQgYnkgYGdldGAgaXMgbm90IGZvcm1hdHRlZCB3aXRoIGRlY2ltYWxzXG4gICAgICAgICAgICBzICs9ICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgbmVnYXRpdmUgc2lnbiBhbmQgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIHRvIHVzZSB0aG9zZSBkZWZpbmVkIGluIHRoZSBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUocywgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJy0nICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy0nLCBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICE9PSAnLicpIHtcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoJy4nLCBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByaXZhdGUgZnVuY3Rpb24gdG8gY2hlY2sgZm9yIGVtcHR5IHZhbHVlXG4gICAgICogLy9UT0RPIE1vZGlmeSB0aGlzIGZ1bmN0aW9uIHNvIHRoYXQgaXQgcmV0dXJuIGVpdGhlciBUUlVFIG9yIEZBTFNFIGlmIHRoZSB2YWx1ZSBpcyBlbXB0eS4gVGhlbiBjcmVhdGUgYW5vdGhlciBmdW5jdGlvbiB0byByZXR1cm4gdGhlIGlucHV0IHZhbHVlIGlmIGl0J3Mgbm90IGVtcHR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNpZ25PbkVtcHR5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY2hlY2tFbXB0eShpbnB1dFZhbHVlLCBzZXR0aW5ncywgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgaWYgKGlucHV0VmFsdWUgPT09ICcnIHx8IGlucHV0VmFsdWUgPT09IHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2Fsd2F5cycgfHwgc2lnbk9uRW1wdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpID8gaW5wdXRWYWx1ZSArIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgc2V0dGluZ3Muc3VmZml4VGV4dCA6IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZSArIHNldHRpbmdzLnN1ZmZpeFRleHQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW9kaWZ5IHRoZSBpbnB1dCB2YWx1ZSBieSBhZGRpbmcgdGhlIGdyb3VwIHNlcGFyYXRvcnMsIGFzIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0VmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRHcm91cFNlcGFyYXRvcnMoaW5wdXRWYWx1ZSwgc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKHNldHRpbmdzLnN0cmlwKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKGlucHV0VmFsdWUsIHNldHRpbmdzLCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvL1RPRE8gVGhpcyBmdW5jdGlvbiBgYWRkR3JvdXBTZXBhcmF0b3JzKClgIGFkZCBncm91cCBzZXBhcmF0b3JzLiBBZGRpbmcgdGhlIG5lZ2F0aXZlIHNpZ24gYXMgd2VsbCBpcyBvdXQgb2YgaXRzIHNjb3BlLiBNb3ZlIHRoYXQgdG8gYW5vdGhlciBmdW5jdGlvbi5cbiAgICAgICAgaWYgKHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgJiYgIWlzTmVnYXRpdmUoaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSAnLScgKyBpbnB1dFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZW1wdHkgPSBjaGVja0VtcHR5KGlucHV0VmFsdWUsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgY29uc3QgaXNWYWx1ZU5lZ2F0aXZlID0gaXNOZWdhdGl2ZShpbnB1dFZhbHVlKTtcbiAgICAgICAgY29uc3QgaXNaZXJvID0gaXNaZXJvT3JIYXNOb1ZhbHVlKGlucHV0VmFsdWUpO1xuICAgICAgICBpZiAoaXNWYWx1ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW5wdXRWYWx1ZS5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwoZW1wdHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1wdHk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy5kaWdpdGFsR3JvdXBTcGFjaW5nID0gc2V0dGluZ3MuZGlnaXRhbEdyb3VwU3BhY2luZy50b1N0cmluZygpO1xuICAgICAgICBsZXQgZGlnaXRhbEdyb3VwO1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmRpZ2l0YWxHcm91cFNwYWNpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgJzInOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkKShcXGR7Mn0/KSspJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcycyc6XG4gICAgICAgICAgICAgICAgZGlnaXRhbEdyb3VwID0gLyhcXGQpKCg/OlxcZHsyfSl7MCwyfVxcZHszfSg/Oig/OlxcZHsyfSl7Mn1cXGR7M30pKj8pJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICc0JzpcbiAgICAgICAgICAgICAgICBkaWdpdGFsR3JvdXAgPSAvKFxcZCkoKFxcZHs0fT8pKykkLztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIGRpZ2l0YWxHcm91cCA9IC8oXFxkKSgoXFxkezN9PykrKSQvO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3BsaXRzIHRoZSBzdHJpbmcgYXQgdGhlIGRlY2ltYWwgc3RyaW5nXG4gICAgICAgIGxldCBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgJiYgaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBbaW50ZWdlclBhcnQsIGRlY2ltYWxQYXJ0XSA9IGlucHV0VmFsdWUuc3BsaXQoc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnJykge1xuICAgICAgICAgICAgLy8gUmUtaW5zZXJ0cyB0aGUgdGhvdXNhbmQgc2VwYXJhdG9yIHZpYSBhIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAgICAgICAgd2hpbGUgKGRpZ2l0YWxHcm91cC50ZXN0KGludGVnZXJQYXJ0KSkge1xuICAgICAgICAgICAgICAgIGludGVnZXJQYXJ0ID0gaW50ZWdlclBhcnQucmVwbGFjZShkaWdpdGFsR3JvdXAsIGAkMSR7c2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvcn0kMmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSAhPT0gMCAmJiAhaXNVbmRlZmluZWQoZGVjaW1hbFBhcnQpKSB7XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQubGVuZ3RoID4gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgZGVjaW1hbFBhcnQgPSBkZWNpbWFsUGFydC5zdWJzdHJpbmcoMCwgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSm9pbnMgdGhlIHdob2xlIG51bWJlciB3aXRoIHRoZSBkZWNpbWFsIHZhbHVlXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQgKyBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICsgZGVjaW1hbFBhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaWYgaXQncyBhbiBpbnRlZ2VyXG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gaW50ZWdlclBhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7aW5wdXRWYWx1ZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfSR7aW5wdXRWYWx1ZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm8pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7aW5wdXRWYWx1ZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7c2V0dGluZ3MucG9zaXRpdmVTaWduQ2hhcmFjdGVyfSR7aW5wdXRWYWx1ZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfSR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWx1ZU5lZ2F0aXZlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSBgJHtpbnB1dFZhbHVlfSR7c2V0dGluZ3MuY3VycmVuY3lTeW1ib2x9JHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFZhbHVlID0gYCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfSR7aW5wdXRWYWx1ZX0ke3NldHRpbmdzLmN1cnJlbmN5U3ltYm9sfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzZXR0aW5ncy5zaG93UG9zaXRpdmVTaWduICYmICFpc1plcm8pIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH0ke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXJ9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGAke3NldHRpbmdzLnBvc2l0aXZlU2lnbkNoYXJhY3Rlcn0ke2lucHV0VmFsdWV9JHtzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbH1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUgKyBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZXMgdGhlIG5lZ2F0aXZlIHNpZ24gYW5kIHBsYWNlcyBicmFja2V0c1xuICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgKHNldHRpbmdzLnJhd1ZhbHVlIDwgMCB8fCBpc05lZ2F0aXZlU3RyaWN0KGlucHV0VmFsdWUpKSkge1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IHRvZ2dsZU5lZ2F0aXZlQnJhY2tldChpbnB1dFZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5wdXRWYWx1ZSArIHNldHRpbmdzLnN1ZmZpeFRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGUgbm90IG5lZWRlZCB6ZXJvc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvdW5kZWRJbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHtpbnR9IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZVxuICAgICAqIEByZXR1cm5zIHt2b2lkfFhNTHxzdHJpbmd8Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cnVuY2F0ZVplcm9zKHJvdW5kZWRJbnB1dFZhbHVlLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHtcbiAgICAgICAgbGV0IHJlZ2V4O1xuICAgICAgICBzd2l0Y2ggKHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnRzIHBhZGRpbmcgLSByZW1vdmVzIHRyYWlsaW5nIHplcm9zIHVudGlsIHRoZSBmaXJzdCBzaWduaWZpY2FudCBkaWdpdCBpcyBlbmNvdW50ZXJlZFxuICAgICAgICAgICAgICAgIHJlZ2V4ID0gLyhcXC4oPzpcXGQqWzEtOV0pPykwKiQvO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIC8vIEFsbG93cyBwYWRkaW5nIHdoZW4gZGVjaW1hbFBsYWNlc092ZXJyaWRlIGVxdWFscyBvbmUgLSBsZWF2ZXMgb25lIHplcm8gdHJhaWxpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgcmVnZXggPSAvKFxcLlxcZCg/OlxcZCpbMS05XSk/KTAqJC87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmVzIGFjY2VzcyB6ZXJvcyB0byB0aGUgZGVjaW1hbFBsYWNlc092ZXJyaWRlIGxlbmd0aCB3aGVuIGFsbG93RGVjaW1hbFBhZGRpbmcgaXMgc2V0IHRvIHRydWVcbiAgICAgICAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoYChcXFxcLlxcXFxkeyR7dGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlfX0oPzpcXFxcZCpbMS05XSk/KTAqYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZGVjaW1hbCBwbGFjZXMsIHdlIGRvbid0IG5lZWQgYSBkZWNpbWFsIHBvaW50IGF0IHRoZSBlbmRcbiAgICAgICAgcm91bmRlZElucHV0VmFsdWUgPSByb3VuZGVkSW5wdXRWYWx1ZS5yZXBsYWNlKHJlZ2V4LCAnJDEnKTtcbiAgICAgICAgaWYgKHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9PT0gMCkge1xuICAgICAgICAgICAgcm91bmRlZElucHV0VmFsdWUgPSByb3VuZGVkSW5wdXRWYWx1ZS5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnB1dFZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJvdW5kIHRoZSBpbnB1dCB2YWx1ZSB1c2luZyB0aGUgcm91bmRpbmcgbWV0aG9kIGRlZmluZWQgaW4gdGhlIHNldHRpbmdzLlxuICAgICAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBtdWx0aXBsZSByb3VuZGluZyBtZXRob2RzLiBTZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIG1vcmUgZGV0YWlscyBhYm91dCB0aG9zZS5cbiAgICAgKlxuICAgICAqIE5vdGUgOiBUaGlzIGlzIGhhbmRsZWQgYXMgdGV4dCBzaW5jZSBKYXZhU2NyaXB0IG1hdGggZnVuY3Rpb24gY2FuIHJldHVybiBpbmFjY3VyYXRlIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcm91bmRWYWx1ZShpbnB1dFZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICBpbnB1dFZhbHVlID0gKGlucHV0VmFsdWUgPT09ICcnKSA/ICcwJyA6IGlucHV0VmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnTjA1JyB8fCBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ0NIRicgfHwgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdVMDUnIHx8IHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnRDA1Jykge1xuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ04wNSc6XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSAoTWF0aC5yb3VuZChpbnB1dFZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1UwNSc6XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSAoTWF0aC5jZWlsKGlucHV0VmFsdWUgKiAyMCkgLyAyMCkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgICAgICAgICAgIGlucHV0VmFsdWUgPSAoTWF0aC5mbG9vcihpbnB1dFZhbHVlICogMjApIC8gMjApLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zKGlucHV0VmFsdWUsICcuJykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnB1dFZhbHVlICsgJy4wMCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlucHV0VmFsdWUubGVuZ3RoIC0gaW5wdXRWYWx1ZS5pbmRleE9mKCcuJykgPCAzKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZSArICcwJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgaXZSb3VuZGVkID0gJyc7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IG5TaWduID0gJyc7XG4gICAgICAgIGxldCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGU7XG5cbiAgICAgICAgLy8gc2V0cyB0aGUgdHJ1bmNhdGUgemVybyBtZXRob2RcbiAgICAgICAgaWYgKHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmcpIHtcbiAgICAgICAgICAgIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGlucHV0VmFsdWUgKGlucHV0IFZhbHVlKSBpcyBhIG5lZ2F0aXZlIHZhbHVlXG4gICAgICAgIGlmIChpc05lZ2F0aXZlU3RyaWN0KGlucHV0VmFsdWUpKSB7XG4gICAgICAgICAgICBuU2lnbiA9ICctJztcblxuICAgICAgICAgICAgLy8gUmVtb3ZlcyB0aGUgbmVnYXRpdmUgc2lnbiB0aGF0IHdpbGwgYmUgYWRkZWQgYmFjayBsYXRlciBpZiByZXF1aXJlZFxuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IGlucHV0VmFsdWUucmVwbGFjZSgnLScsICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFwcGVuZCBhIHplcm8gaWYgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBub3QgYSBkaWdpdCAodGhlbiBpdCBpcyBsaWtlbHkgdG8gYmUgYSBkb3QpXG4gICAgICAgIGlmICghaW5wdXRWYWx1ZS5tYXRjaCgvXlxcZC8pKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gJzAnICsgaW5wdXRWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZXMgaWYgdGhlIHZhbHVlIGlzIGVxdWFsIHRvIHplcm8uIElmIGl0IGlzLCByZW1vdmUgdGhlIG5lZ2F0aXZlIHNpZ25cbiAgICAgICAgaWYgKE51bWJlcihpbnB1dFZhbHVlKSA9PT0gMCkge1xuICAgICAgICAgICAgblNpZ24gPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaW1zIGxlYWRpbmcgemVybydzIGFzIG5lZWRlZFxuICAgICAgICBpZiAoKE51bWJlcihpbnB1dFZhbHVlKSA+IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykgfHwgKGlucHV0VmFsdWUubGVuZ3RoID4gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyA9PT0gJ2FsbG93JykpIHtcbiAgICAgICAgICAgIGlucHV0VmFsdWUgPSBpbnB1dFZhbHVlLnJlcGxhY2UoL14wKihcXGQpLywgJyQxJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkUG9zID0gaW5wdXRWYWx1ZS5sYXN0SW5kZXhPZignLicpO1xuICAgICAgICBjb25zdCBpbnB1dFZhbHVlSGFzQURvdCA9IGRQb3MgPT09IC0xO1xuXG4gICAgICAgIC8vIFZpcnR1YWwgZGVjaW1hbCBwb3NpdGlvblxuICAgICAgICBjb25zdCB2ZFBvcyA9IGlucHV0VmFsdWVIYXNBRG90ID8gaW5wdXRWYWx1ZS5sZW5ndGggLSAxIDogZFBvcztcblxuICAgICAgICAvLyBDaGVja3MgZGVjaW1hbCBwbGFjZXMgdG8gZGV0ZXJtaW5lIGlmIHJvdW5kaW5nIGlzIHJlcXVpcmVkIDpcbiAgICAgICAgLy8gQ2hlY2sgaWYgbm8gcm91bmRpbmcgaXMgcmVxdWlyZWRcbiAgICAgICAgbGV0IGNEZWMgPSAoaW5wdXRWYWx1ZS5sZW5ndGggLSAxKSAtIHZkUG9zO1xuXG4gICAgICAgIGlmIChjRGVjIDw9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBwYWQgd2l0aCB6ZXJvc1xuICAgICAgICAgICAgaXZSb3VuZGVkID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgICAgIGlmIChjRGVjIDwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWVIYXNBRG90KSB7XG4gICAgICAgICAgICAgICAgICAgIGl2Um91bmRlZCArPSBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCB6ZXJvcyA9ICcwMDAwMDAnO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjRGVjIDwgdGVtcG9yYXJ5RGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHplcm9zID0gemVyb3Muc3Vic3RyaW5nKDAsIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSAtIGNEZWMpO1xuICAgICAgICAgICAgICAgICAgICBpdlJvdW5kZWQgKz0gemVyb3M7XG4gICAgICAgICAgICAgICAgICAgIGNEZWMgKz0gemVyb3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY0RlYyA+IHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IHRydW5jYXRlWmVyb3MoaXZSb3VuZGVkLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjRGVjID09PSAwICYmIHRlbXBvcmFyeURlY2ltYWxQbGFjZXNPdmVycmlkZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGl2Um91bmRlZCA9IGl2Um91bmRlZC5yZXBsYWNlKC9cXC4kLywgJycpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKE51bWJlcihpdlJvdW5kZWQpID09PSAwKSA/IGl2Um91bmRlZCA6IG5TaWduICsgaXZSb3VuZGVkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUm91bmRlZCBsZW5ndGggb2YgdGhlIHN0cmluZyBhZnRlciByb3VuZGluZ1xuICAgICAgICBsZXQgckxlbmd0aDtcbiAgICAgICAgaWYgKGlucHV0VmFsdWVIYXNBRG90KSB7XG4gICAgICAgICAgICByTGVuZ3RoID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJMZW5ndGggPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgKyBkUG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdFJvdW5kID0gTnVtYmVyKGlucHV0VmFsdWUuY2hhckF0KHJMZW5ndGggKyAxKSk7XG4gICAgICAgIGNvbnN0IG9kZCA9IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSA9PT0gJy4nKSA/IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoIC0gMSkgJSAyKSA6IChpbnB1dFZhbHVlLmNoYXJBdChyTGVuZ3RoKSAlIDIpO1xuICAgICAgICBsZXQgaXZBcnJheSA9IGlucHV0VmFsdWUuc3Vic3RyaW5nKDAsIHJMZW5ndGggKyAxKS5zcGxpdCgnJyk7XG5cbiAgICAgICAgaWYgKCh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnUycpICAgICAgICAgICAgICAgICAgfHwgLy8gUm91bmQgaGFsZiB1cCBzeW1tZXRyaWNcbiAgICAgICAgICAgICh0Um91bmQgPiA0ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiB1cCBhc3ltbWV0cmljIHBvc2l0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdBJyAmJiBuU2lnbiA9PT0gJy0nKSB8fCAvLyBSb3VuZCBoYWxmIHVwIGFzeW1tZXRyaWMgbmVnYXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNSAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ3MnKSAgICAgICAgICAgICAgICAgIHx8IC8vIFJvdW5kIGhhbGYgZG93biBzeW1tZXRyaWNcbiAgICAgICAgICAgICh0Um91bmQgPiA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnYScgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgaGFsZiBkb3duIGFzeW1tZXRyaWMgcG9zaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAodFJvdW5kID4gNCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ2EnICYmIG5TaWduID09PSAnLScpIHx8IC8vIFJvdW5kIGhhbGYgZG93biBhc3ltbWV0cmljIG5lZ2F0aXZlIHZhbHVlc1xuICAgICAgICAgICAgKHRSb3VuZCA+IDUgJiYgc2V0dGluZ3Mucm91bmRpbmdNZXRob2QgPT09ICdCJykgICAgICAgICAgICAgICAgICB8fCAvLyBSb3VuZCBoYWxmIGV2ZW4gXCJCYW5rZXIncyBSb3VuZGluZ1wiXG4gICAgICAgICAgICAodFJvdW5kID09PSA1ICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQicgJiYgb2RkID09PSAxKSAgIHx8IC8vIFJvdW5kIGhhbGYgZXZlbiBcIkJhbmtlcidzIFJvdW5kaW5nXCJcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnQycgJiYgblNpZ24gPT09ICcnKSAgfHwgLy8gUm91bmQgdG8gY2VpbGluZyB0b3dhcmQgcG9zaXRpdmUgaW5maW5pdGVcbiAgICAgICAgICAgICh0Um91bmQgPiAwICYmIHNldHRpbmdzLnJvdW5kaW5nTWV0aG9kID09PSAnRicgJiYgblNpZ24gPT09ICctJykgfHwgLy8gUm91bmQgdG8gZmxvb3IgdG93YXJkIG5lZ2F0aXZlIGluZmluaXRlXG4gICAgICAgICAgICAodFJvdW5kID4gMCAmJiBzZXR0aW5ncy5yb3VuZGluZ01ldGhvZCA9PT0gJ1UnKSkgeyAgICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIGF3YXkgZnJvbSB6ZXJvXG4gICAgICAgICAgICAvLyBSb3VuZCB1cCB0aGUgbGFzdCBkaWdpdCBpZiByZXF1aXJlZCwgYW5kIGNvbnRpbnVlIHVudGlsIG5vIG1vcmUgOSdzIGFyZSBmb3VuZFxuICAgICAgICAgICAgZm9yIChpID0gKGl2QXJyYXkubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl2QXJyYXlbaV0gIT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBpdkFycmF5W2ldID0gK2l2QXJyYXlbaV0gKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXZBcnJheVtpXSA8IDEwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXZBcnJheVtpXSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlY29uc3RydWN0IHRoZSBzdHJpbmcsIGNvbnZlcnRpbmcgYW55IDEwJ3MgdG8gMCdzXG4gICAgICAgIGl2QXJyYXkgPSBpdkFycmF5LnNsaWNlKDAsIHJMZW5ndGggKyAxKTtcblxuICAgICAgICAvLyBSZXR1cm4gdGhlIHJvdW5kZWQgdmFsdWVcbiAgICAgICAgaXZSb3VuZGVkID0gdHJ1bmNhdGVaZXJvcyhpdkFycmF5LmpvaW4oJycpLCB0ZW1wb3JhcnlEZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuXG4gICAgICAgIHJldHVybiAoTnVtYmVyKGl2Um91bmRlZCkgPT09IDApID8gaXZSb3VuZGVkIDogblNpZ24gKyBpdlJvdW5kZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIHRoZSBkZWNpbWFsIHBhcnQgb2YgYSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQYXN0ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRydW5jYXRlRGVjaW1hbChzLCBzZXR0aW5ncywgaXNQYXN0ZSkge1xuICAgICAgICBzID0gKGlzUGFzdGUpID8gcm91bmRWYWx1ZShzLCBzZXR0aW5ncykgOiBzO1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyICYmIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkge1xuICAgICAgICAgICAgY29uc3QgW2ludGVnZXJQYXJ0LCBkZWNpbWFsUGFydF0gPSBzLnNwbGl0KHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpO1xuXG4gICAgICAgICAgICAvLyB0cnVuY2F0ZSBkZWNpbWFsIHBhcnQgdG8gc2F0aXNmeWluZyBsZW5ndGggc2luY2Ugd2Ugd291bGQgcm91bmQgaXQgYW55d2F5XG4gICAgICAgICAgICBpZiAoZGVjaW1hbFBhcnQgJiYgZGVjaW1hbFBhcnQubGVuZ3RoID4gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWREZWNpbWFsUGFydCA9IGRlY2ltYWxQYXJ0LnN1YnN0cmluZygwLCBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgICAgICBzID0gYCR7aW50ZWdlclBhcnR9JHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7bW9kaWZpZWREZWNpbWFsUGFydH1gO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMgPSBpbnRlZ2VyUGFydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB0byBwYXJzZSBtaW5pbXVtVmFsdWUsIG1heGltdW1WYWx1ZSAmIHRoZSBpbnB1dCB2YWx1ZSB0byBwcmVwYXJlIGZvciB0ZXN0aW5nIHRvIGRldGVybWluZSBpZiB0aGUgdmFsdWUgZmFsbHMgd2l0aGluIHRoZSBtaW4gLyBtYXggcmFuZ2UuXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCBleGFtcGxlOiBtaW5pbXVtVmFsdWU6IFwiOTk5OTk5OTk5OTk5OTk5Ljk5XCIgcmV0dXJucyB0aGUgZm9sbG93aW5nIFwie3M6IC0xLCBlOiAxMiwgYzogQXJyYXlbMTVdfVwiLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBhZGFwdGVkIGZyb20gQmlnLmpzIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZy5qcy8uIE1hbnkgdGhhbmtzIHRvIE1pa2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG4gQSBudW1lcmljIHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHt7fX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJzZVN0cihuKSB7XG4gICAgICAgIGNvbnN0IHggPSB7fTsgLy8gQSBCaWcgbnVtYmVyIGluc3RhbmNlLlxuICAgICAgICBsZXQgZTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBuTDtcbiAgICAgICAgbGV0IGo7XG5cbiAgICAgICAgLy8gTWludXMgemVybz9cbiAgICAgICAgaWYgKG4gPT09IDAgJiYgMSAvIG4gPCAwKSB7XG4gICAgICAgICAgICBuID0gJy0wJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERldGVybWluZSBzaWduLiAxIHBvc2l0aXZlLCAtMSBuZWdhdGl2ZVxuICAgICAgICBuID0gbi50b1N0cmluZygpO1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZVN0cmljdChuKSkge1xuICAgICAgICAgICAgbiA9IG4uc2xpY2UoMSk7XG4gICAgICAgICAgICB4LnMgPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHgucyA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xuICAgICAgICBlID0gbi5pbmRleE9mKCcuJyk7XG4gICAgICAgIGlmIChlID4gLTEpIHtcbiAgICAgICAgICAgIG4gPSBuLnJlcGxhY2UoJy4nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBsZW5ndGggb2Ygc3RyaW5nIGlmIG5vIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgIGlmIChlIDwgMCkge1xuICAgICAgICAgICAgLy8gSW50ZWdlclxuICAgICAgICAgICAgZSA9IG4ubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3NcbiAgICAgICAgaSA9IChuLnNlYXJjaCgvWzEtOV0vaSkgPT09IC0xKSA/IG4ubGVuZ3RoIDogbi5zZWFyY2goL1sxLTldL2kpO1xuICAgICAgICBuTCA9IG4ubGVuZ3RoO1xuICAgICAgICBpZiAoaSA9PT0gbkwpIHtcbiAgICAgICAgICAgIC8vIFplcm9cbiAgICAgICAgICAgIHguZSA9IDA7XG4gICAgICAgICAgICB4LmMgPSBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3NcbiAgICAgICAgICAgIGZvciAoaiA9IG5MIC0gMTsgbi5jaGFyQXQoaikgPT09ICcwJzsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgbkwgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5MIC09IDE7XG5cbiAgICAgICAgICAgIC8vIERlY2ltYWwgbG9jYXRpb25cbiAgICAgICAgICAgIHguZSA9IGUgLSBpIC0gMTtcbiAgICAgICAgICAgIHguYyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBhcnJheSBvZiBkaWdpdHMgd2l0aG91dCBsZWFkaW5nL3RyYWlsaW5nIHplcm9zXG4gICAgICAgICAgICBmb3IgKGUgPSAwOyBpIDw9IG5MOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICB4LmNbZV0gPSArbi5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgZSArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdG8gdGVzdCBpZiB0aGUgaW5wdXQgdmFsdWUgZmFsbHMgd2l0aCB0aGUgTWluIC8gTWF4IHNldHRpbmdzLlxuICAgICAqIFRoaXMgdXNlcyB0aGUgcGFyc2VkIHN0cmluZ3MgZm9yIHRoZSBhYm92ZSBwYXJzZVN0ciBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgYWRhcHRlZCBmcm9tIEJpZy5qcyBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWcuanMvLiBNYW55IHRoYW5rcyB0byBNaWtlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHkgQmlnIG51bWJlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB4IEJpZyBudW1iZXIgaW5zdGFuY2VcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0ZXN0TWluTWF4KHksIHgpIHtcbiAgICAgICAgY29uc3QgeGMgPSB4LmM7XG4gICAgICAgIGNvbnN0IHljID0geS5jO1xuICAgICAgICBsZXQgaSA9IHgucztcbiAgICAgICAgbGV0IGogPSB5LnM7XG4gICAgICAgIGxldCBrID0geC5lO1xuICAgICAgICBsZXQgbCA9IHkuZTtcblxuICAgICAgICAvLyBFaXRoZXIgemVybz9cbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBpZiAoIXhjWzBdKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gIXljWzBdPzA6LWo7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xuICAgICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeE5lZyA9IGkgPCAwO1xuXG4gICAgICAgIC8vIENvbXBhcmUgZXhwb25lbnRzXG4gICAgICAgIGlmIChrICE9PSBsKSB7XG4gICAgICAgICAgICByZXR1cm4gKGsgPiBsIF4geE5lZyk/MTotMTtcbiAgICAgICAgfVxuICAgICAgICBpID0gLTE7XG4gICAgICAgIGsgPSB4Yy5sZW5ndGg7XG4gICAgICAgIGwgPSB5Yy5sZW5ndGg7XG4gICAgICAgIGogPSAoayA8IGwpID8gayA6IGw7XG5cbiAgICAgICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdFxuICAgICAgICBmb3IgKGkgKz0gMTsgaSA8IGo7IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHhjW2ldICE9PSB5Y1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoeGNbaV0gPiB5Y1tpXSBeIHhOZWcpPzE6LTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wYXJlIGxlbmd0aHNcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgaWYgKGsgPT09IGwpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSAoayA+IGwgXiB4TmVnKT8xOi0xO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IHRoZSBudW1iZXIgc2F0aXNmeSB0aGUgZm9ybWF0IGNvbmRpdGlvbnNcbiAgICAgKiBhbmQgbGF5cyBiZXR3ZWVuIHNldHRpbmdzLm1pbmltdW1WYWx1ZSBhbmQgc2V0dGluZ3MubWF4aW11bVZhbHVlXG4gICAgICogYW5kIHRoZSBzdHJpbmcgbGVuZ3RoIGRvZXMgbm90IGV4Y2VlZCB0aGUgZGlnaXRzIGluIHNldHRpbmdzLm1pbmltdW1WYWx1ZSBhbmQgc2V0dGluZ3MubWF4aW11bVZhbHVlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHMsIHNldHRpbmdzKSB7XG4gICAgICAgIHMgPSBzLnRvU3RyaW5nKCk7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJywnLCAnLicpO1xuICAgICAgICBjb25zdCBtaW5QYXJzZSA9IHBhcnNlU3RyKHNldHRpbmdzLm1pbmltdW1WYWx1ZSk7XG4gICAgICAgIGNvbnN0IG1heFBhcnNlID0gcGFyc2VTdHIoc2V0dGluZ3MubWF4aW11bVZhbHVlKTtcbiAgICAgICAgY29uc3QgdmFsUGFyc2UgPSBwYXJzZVN0cihzKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLm92ZXJyaWRlTWluTWF4TGltaXRzKSB7XG4gICAgICAgICAgICBjYXNlICdmbG9vcic6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3Rlc3RNaW5NYXgobWluUGFyc2UsIHZhbFBhcnNlKSA+IC0xLCB0cnVlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NlaWxpbmcnOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFt0cnVlLCB0ZXN0TWluTWF4KG1heFBhcnNlLCB2YWxQYXJzZSkgPCAxXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gW3RydWUsIHRydWVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBbdGVzdE1pbk1heChtaW5QYXJzZSwgdmFsUGFyc2UpID4gLTEsIHRlc3RNaW5NYXgobWF4UGFyc2UsIHZhbFBhcnNlKSA8IDFdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGFua3MgdG8gQW50aG9ueSAmIEV2YW4gQ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeXxIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRDdXJyZW50RWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIElmIHRoZSBwYXJhbWV0ZXIgaXMgYSBzdHJpbmcgKGFuZCB0aGVyZWZvcmUgaXMgYSBDU1Mgc2VsZWN0b3IpLCB0aGVuIHdlIG5lZWQgdG8gbW9kaWZ5IHRoaXMgc3RyaW5nIGluIG9yZGVyXG4gICAgICAgICAqIGZvciBqUXVlcnkgdG8gYmUgYWJsZSB0byBwYXJzZSB0aGUgc2VsZWN0b3IgY29ycmVjdGx5LlxuICAgICAgICAgKiBjZi4gaHR0cDovL2xlYXJuLmpxdWVyeS5jb20vdXNpbmctanF1ZXJ5LWNvcmUvZmFxL2hvdy1kby1pLXNlbGVjdC1hbi1lbGVtZW50LWJ5LWFuLWlkLXRoYXQtaGFzLWNoYXJhY3RlcnMtdXNlZC1pbi1jc3Mtbm90YXRpb24vXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNTdHJpbmcoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGJsb2NrIGlzIGFwcGFyZW50bHkgbmV2ZXIgZW50ZXJlZC4gV2Ugc2hvdWxkIHJlbW92ZSBpdCBhZnRlciBtYWtpbmcgc3VyZSB0aGF0J3MgMTAwJSB0aGUgY2FzZVxuICAgICAgICAgICAgZWxlbWVudCA9IGAjJHtlbGVtZW50LnJlcGxhY2UoLyg6fFxcLnxcXFt8XXwsfD0pL2csICdcXFxcJDEnKX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICQoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBhdHRhY2ggdGhlIGF1dG9OdW1lcmljIGZpZWxkIHByb3BlcnRpZXMgdG8gdGhlIERPTSBlbGVtZW50IHZpYSBhbiBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFufSB1cGRhdGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBdXRvTnVtZXJpY0hvbGRlcigkdGhpcywgc2V0dGluZ3MsIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIGxldCBkYXRhID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICBkYXRhID0ge307XG4gICAgICAgICAgICAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycsIGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGhvbGRlciA9IGRhdGEuaG9sZGVyO1xuICAgICAgICBpZiAodXBkYXRlIHx8IChpc1VuZGVmaW5lZChob2xkZXIpICYmIHNldHRpbmdzKSkge1xuICAgICAgICAgICAgaG9sZGVyID0gbmV3IEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLmdldCgwKSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgZGF0YS5ob2xkZXIgPSBob2xkZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaG9sZGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzICYgbm9TZXBhcmF0b3JPbkZvY3VzIG9wdGlvbnMgYXJlIGJlaW5nIHVzZWQuXG4gICAgICogVGhvc2Ugb3JpZ2luYWwgc2V0dGluZ3MgYXJlIHVzZWQgZXhjbHVzaXZlbHkgaW4gdGhlIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtlZXBBbk9yaWdpbmFsU2V0dGluZ3NDb3B5KHNldHRpbmdzKSB7XG4gICAgICAgIC8vVE9ETyBSZW5hbWUgdGhlIG9sZCBvcHRpb24gbmFtZXMgdG8gdGhlIG5ldyBvbmVzXG4gICAgICAgIHNldHRpbmdzLm9EZWMgICAgID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICBzZXR0aW5ncy5vUGFkICAgICA9IHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmc7XG4gICAgICAgIHNldHRpbmdzLm9CcmFja2V0ID0gc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXI7XG4gICAgICAgIHNldHRpbmdzLm9TZXAgICAgID0gc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvcjtcbiAgICAgICAgc2V0dGluZ3Mub1NpZ24gICAgPSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbDtcbiAgICAgICAgc2V0dGluZ3Mub1N1ZmZpeCAgPSBzZXR0aW5ncy5zdWZmaXhUZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c2AgJiBgbm9TZXBhcmF0b3JPbkZvY3VzYCBvcHRpb25zIGFyZSBiZWluZyB1c2VkLlxuICAgICAqIFRoaXMgaXMgdGFrZW4gZnJvbSBRdWlya3Ntb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWFkQ29va2llKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZUVRID0gbmFtZSArICc9JztcbiAgICAgICAgY29uc3QgY2EgPSBkb2N1bWVudC5jb29raWUuc3BsaXQoJzsnKTtcbiAgICAgICAgbGV0IGMgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgYyA9IGNhW2ldO1xuICAgICAgICAgICAgd2hpbGUgKGMuY2hhckF0KDApID09PSAnICcpIHtcbiAgICAgICAgICAgICAgICBjID0gYy5zdWJzdHJpbmcoMSwgYy5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGMuaW5kZXhPZihuYW1lRVEpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuc3Vic3RyaW5nKG5hbWVFUS5sZW5ndGgsIGMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRlc3QgaWYgc2Vzc2lvblN0b3JhZ2UgaXMgc3VwcG9ydGVkLlxuICAgICAqIFRoaXMgaXMgdGFrZW4gZnJvbSBNb2Rlcm5penIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdG9yYWdlVGVzdCgpIHtcbiAgICAgICAgY29uc3QgbW9kID0gJ21vZGVybml6cic7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKG1vZCwgbW9kKTtcbiAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0obW9kKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9wZXJseSBmb3JtYXRzIHRoZSBzdHJpbmcgdG8gYSBudW1lcmljIHdoZW4gbGVhZGluZ1plcm8gZG9lcyBub3QgJ2tlZXAnLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbGVhbkxlYWRpbmdUcmFpbGluZ1plcm9zKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICAvLyBSZXR1cm4gdGhlIGVtcHR5IHN0cmluZyBpcyB0aGUgdmFsdWUgaXMgYWxyZWFkeSBlbXB0eS4gVGhpcyBwcmV2ZW50IGNvbnZlcnRpbmcgdGhhdCB2YWx1ZSB0byAnMCcuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJldHVybiAnMCcgaWYgdGhlIHZhbHVlIGlzIHplcm9cbiAgICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IDAgJiYgc2V0dGluZ3MubGVhZGluZ1plcm8gIT09ICdrZWVwJykge1xuICAgICAgICAgICAgcmV0dXJuICcwJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICAvLyBUcmltIGxlYWRpbmcgemVybydzIC0gbGVhdmVzIG9uZSB6ZXJvIHRvIHRoZSBsZWZ0IG9mIHRoZSBkZWNpbWFsIHBvaW50XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL14oLSk/MCsoPz1cXGQpL2csJyQxJyk7XG5cbiAgICAgICAgICAgIC8vVE9ETyByZW1vdmUgdGhpcyBmcm9tIHRoYXQgZnVuY3Rpb24gYW5kIHVzZSBgdHJpbVBhZGRlZFplcm9zRnJvbURlY2ltYWxQbGFjZXMoKWAgaW5zdGVhZC4gQWxzbyBjcmVhdGUgYSBuZXcgYHRyYWlsaW5nWmVyb2Agb3B0aW9uLlxuICAgICAgICAgICAgaWYgKGNvbnRhaW5zKHZhbHVlLCAnLicpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJpbXMgdHJhaWxpbmcgemVyb3MgYWZ0ZXIgdGhlIGRlY2ltYWwgcG9pbnRcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoLyhcXC5bMC05XSo/KTArJC8sICckMScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0cmlwcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwuJC8sICcnKTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgZGVjaW1hbCBwYXJ0IG9mIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG51bWVyaWNTdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcyhudW1lcmljU3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IFtpbnRlZ2VyUGFydCwgZGVjaW1hbFBhcnRdID0gbnVtZXJpY1N0cmluZy5zcGxpdCgnLicpO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWRPck51bGxPckVtcHR5KGRlY2ltYWxQYXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVnZXJQYXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdHJpbW1lZERlY2ltYWxQYXJ0ID0gZGVjaW1hbFBhcnQucmVwbGFjZSgvMCskL2csICcnKTtcblxuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAodHJpbW1lZERlY2ltYWxQYXJ0ID09PSAnJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gaW50ZWdlclBhcnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQgPSBgJHtpbnRlZ2VyUGFydH0uJHt0cmltbWVkRGVjaW1hbFBhcnR9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciByZW1vdmVzIHNlc3Npb25TdG9yYWdlIG9yIGNvb2tpZSBkZXBlbmRpbmcgb24gd2hhdCB0aGUgYnJvd3NlciBpcyBzdXBwb3J0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fEV2ZW50VGFyZ2V0fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFjdGlvblxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoZWxlbWVudCwgc2V0dGluZ3MsIGFjdGlvbikge1xuICAgICAgICBpZiAoc2V0dGluZ3Muc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkTmFtZSA9IChlbGVtZW50Lm5hbWUgIT09ICcnICYmICFpc1VuZGVmaW5lZChlbGVtZW50Lm5hbWUpKSA/YEFVVE9fJHtkZWNvZGVVUklDb21wb25lbnQoZWxlbWVudC5uYW1lKX1gIDpgQVVUT18ke2VsZW1lbnQuaWR9YDtcbiAgICAgICAgICAgIGxldCBkYXRlO1xuICAgICAgICAgICAgbGV0IGV4cGlyZXM7XG5cbiAgICAgICAgICAgIC8vIFNldHMgY29va2llIGZvciBicm93c2VyIHRoYXQgZG8gbm90IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UgSUUgNiAmIElFIDdcbiAgICAgICAgICAgIGlmIChzdG9yYWdlVGVzdCgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5jb29raWUgPSBgJHtzdG9yZWROYW1lfT0ke3NldHRpbmdzLnJhd1ZhbHVlfTsgZXhwaXJlcz0gOyBwYXRoPS9gO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZGF0ZS5nZXRUaW1lKCkgKyAoLTEgKiAyNCAqIDYwICogNjAgKiAxMDAwKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBpcmVzID0gJzsgZXhwaXJlcz0nICsgZGF0ZS50b1VUQ1N0cmluZygpOyAvLyBOb3RlIDogYHRvR01UU3RyaW5nKClgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgKGNmLiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlL3RvR01UU3RyaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuY29va2llID0gYCR7c3RvcmVkTmFtZX09JycgOyR7ZXhwaXJlc307IHBhdGg9L2A7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnZ2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkQ29va2llKHN0b3JlZE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oc3RvcmVkTmFtZSwgc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dpcGUnOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbShzdG9yZWROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdnZXQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oc3RvcmVkTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSG9sZGVyIG9iamVjdCBmb3IgZmllbGQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNsYXNzIEF1dG9OdW1lcmljSG9sZGVyIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENsYXNzIGNvbnN0cnVjdG9yXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHRoYXQgLSBBIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBET00gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0cnVjdG9yKHRoYXQsIHNldHRpbmdzKSB7XG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgICAgICB0aGlzLnRoYXQgPSB0aGF0O1xuICAgICAgICAgICAgdGhpcy4kdGhhdCA9ICQodGhhdCk7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0Nsb25lID0gc2V0dGluZ3M7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhhdC52YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGUgdGhlIHZhbHVlIGFuZCB0aGUgc2VsZWN0aW9uIHZhbHVlcyBpbnNpZGUgdGhlIEF1dG9OdW1lcmljSG9sZGVyIG9iamVjdC5cbiAgICAgICAgICogVGhpcyBrZWVwcyB0cmFja3Mgb2YgdGhlIGlucHV0IHZhbHVlLCBhcyB3ZWxsIGFzIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICogVGhpcyBhbHNvIHJlc2V0cyB0aGUgJ3Byb2Nlc3NlZCcgYW5kICdmb3JtYXR0ZWQnIHN0YXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIDogVGhvc2UgdHdvIGNhbiBjaGFuZ2UgYmV0d2VlbiB0aGUga2V5ZG93biwga2V5cHJlc3MgYW5kIGtleXVwIGV2ZW50cywgdGhhdCdzIHdoeVxuICAgICAgICAgKiAgICAgICAgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb24gZWFjaCBldmVudCBoYW5kbGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX3VwZGF0ZUF1dG9OdW1lcmljSG9sZGVyUHJvcGVydGllcygpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnRoYXQudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IGdldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0KTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUga2V5Y29kZSBvZiB0aGUga2V5IHRoYXQgdHJpZ2dlcmVkIHRoZSBnaXZlbiBldmVudC5cbiAgICAgICAgICogTm90ZSA6IGUud2hpY2ggaXMgc29tZXRpbWVzIGRpZmZlcmVudCB0aGFuIGUua2V5Q29kZSBkdXJpbmcgdGhlIGtleXByZXNzIGV2ZW50LCB3aGVuIGVudGVyaW5nIGEgcHJpbnRhYmxlIGNoYXJhY3RlciBrZXkgKGllLiAndCcpLiBgZS53aGljaGAgZXF1YWxzIDAgZm9yIG5vbi1wcmludGFibGUgY2hhcmFjdGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogLy9UT0RPIFN3aXRjaCB0byB0aGUgbm9uLWRlcHJlY2F0ZWQgZS5rZXkgYXR0cmlidXRlLCBpbnN0ZWFkIG9mIGluY29uc2lzdGFudCBlLndoaWNoIGFuZCBlLmtleUNvZGUuXG4gICAgICAgICAqIGUua2V5IGRlc2NyaWJlIHRoZSBrZXkgbmFtZSB1c2VkIHRvIHRyaWdnZXIgdGhlIGV2ZW50LlxuICAgICAgICAgKiBlLmtleUNvZGUgYmVpbmcgZGVwcmVjYXRlZCA6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50L2tleUNvZGVcbiAgICAgICAgICogSG93IGUua2V5IHdvcmtzIDogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQva2V5XG4gICAgICAgICAqIFRoZSBrZXkgbGlzdCBpcyBkZXNjcmliZWQgaGVyZVxuICAgICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkvS2V5X1ZhbHVlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfdXBkYXRlQXV0b051bWVyaWNIb2xkZXJFdmVudEtleWNvZGUoZSkge1xuICAgICAgICAgICAgLy8gTm90ZTogdGhlIGtleXByZXNzIGV2ZW50IG92ZXJ3cml0ZXMgbWVhbmluZ2Z1bCB2YWx1ZSBvZiBlLmtleUNvZGUsIGhlbmNlIHdlIGRvIG5vdCB1cGRhdGUgdGhhdCB2YWx1ZSBvbiAna2V5cHJlc3MnXG4gICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9IGtleUNvZGVOdW1iZXIoZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSB0ZXh0IHNlbGVjdGlvbiBpbnNpZGUgdGhlIGlucHV0IHdpdGggdGhlIGdpdmVuIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7aW50fSBzdGFydFxuICAgICAgICAgKiBAcGFyYW0ge2ludH0gZW5kXG4gICAgICAgICAqIEBwYXJhbSB7dW5kZWZpbmVkfGJvb2xlYW59IHNldFJlYWxcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9zZXRTZWxlY3Rpb24oc3RhcnQsIGVuZCwgc2V0UmVhbCkge1xuICAgICAgICAgICAgLy9UT0RPIE1vZGlmeSBzZXRSZWFsIHRvIGJlIG1vcmUgZXhwbGljaXQgKGFuZCBhIGJvb2xlYW4pXG4gICAgICAgICAgICBzdGFydCA9IE1hdGgubWF4KHN0YXJ0LCAwKTtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKGVuZCwgdGhpcy50aGF0LnZhbHVlLmxlbmd0aCk7IC8vVE9ETyBSZXBsYWNlIGB0aGlzLnRoYXQudmFsdWUubGVuZ3RoYCB3aXRoIGB0aGlzLnZhbHVlLmxlbmd0aGBcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBsZW5ndGg6IGVuZCAtIHN0YXJ0LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHNldFJlYWwpIHx8IHNldFJlYWwpIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKHRoaXMudGhhdCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHRoZSBjYXJldCBwb3NpdGlvbiBpbnNpZGUgdGhlIGlucHV0IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtpbnR9IHBvc1xuICAgICAgICAgKiBAcGFyYW0ge3VuZGVmaW5lZHxib29sZWFufSBzZXRSZWFsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0Q2FyZXRQb3NpdGlvbihwb3MsIHNldFJlYWwpIHtcbiAgICAgICAgICAgIC8vVE9ETyBNb2RpZnkgc2V0UmVhbCB0byBiZSBtb3JlIGV4cGxpY2l0IChhbmQgYSBib29sZWFuKVxuICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHBvcywgcG9zLCBzZXRSZWFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm4gYW4gYXJyYXkgY29udGFpbmluZyB0aGUgc3RyaW5nIHBhcnRzIGxvY2F0ZWQgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbi5cbiAgICAgICAgICogVGhvc2UgcGFydHMgYXJlIGxlZnQgJ3VudG91Y2hlZCcsIGllLiBmb3JtYXR0ZWQgYnkgYXV0b051bWVyaWMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtbc3RyaW5nLCBzdHJpbmddfSBUaGUgcGFydHMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIHRoZSBjYXJldCBvciBzZWxlY3Rpb25cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9nZXRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IHZhbHVlLnN1YnN0cmluZygwLCB0aGlzLnNlbGVjdGlvbi5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHZhbHVlLnN1YnN0cmluZyh0aGlzLnNlbGVjdGlvbi5lbmQsIHZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybiBhbiBhcnJheSBjb250YWluaW5nIHRoZSBzdHJpbmcgcGFydHMgbG9jYXRlZCBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgc2lkZSBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uLlxuICAgICAgICAgKiBUaG9zZSBwYXJ0cyBhcmUgdW5mb3JtYXR0ZWQgKHN0cmlwcGVkKSBvZiBhbnkgbm9uLW51bWJlcnMgY2hhcmFjdGVycy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge1tzdHJpbmcsIHN0cmluZ119IFRoZSBwYXJ0cyBvbiB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvbiwgdW5mb3JtYXR0ZWQuXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcbiAgICAgICAgICAgIGxldCBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIHJpZ2h0ID09PSAnJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgY2hhbmdpbmcgdGhlIHNpZ24gYW5kIGxlZnQgaXMgZXF1YWwgdG8gdGhlIG51bWJlciB6ZXJvIC0gcHJldmVudHMgc3RyaXBwaW5nIHRoZSBsZWFkaW5nIHplcm9zXG4gICAgICAgICAgICBsZXQgc3RyaXBaZXJvcyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuSHlwaGVuICYmIE51bWJlcihsZWZ0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cmlwWmVyb3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlZnQgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdCwgdGhpcy5zZXR0aW5nc0Nsb25lLCBzdHJpcFplcm9zKTtcbiAgICAgICAgICAgIHJpZ2h0ID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHJpZ2h0LCB0aGlzLnNldHRpbmdzQ2xvbmUsIGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUudHJhaWxpbmdOZWdhdGl2ZSAmJiAhaXNOZWdhdGl2ZShsZWZ0KSkge1xuICAgICAgICAgICAgICAgIGxlZnQgPSAnLScgKyBsZWZ0O1xuICAgICAgICAgICAgICAgIHJpZ2h0ID0gKHJpZ2h0ID09PSAnLScpID8gJycgOiByaWdodDtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU3RyaXAgcGFydHMgZnJvbSBleGNlc3MgY2hhcmFjdGVycyBhbmQgbGVhZGluZyB6ZXJvcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxlZnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHJpZ2h0XG4gICAgICAgICAqIEByZXR1cm5zIHtbKiwqXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9ub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCkge1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3NDbG9uZSA9IHRoaXMuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICAgICAgLy8gaWYgY2hhbmdpbmcgdGhlIHNpZ24gYW5kIGxlZnQgaXMgZXF1YWwgdG8gdGhlIG51bWJlciB6ZXJvIC0gcHJldmVudHMgc3RyaXBwaW5nIHRoZSBsZWFkaW5nIHplcm9zXG4gICAgICAgICAgICBsZXQgc3RyaXBaZXJvcyA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuSHlwaGVuICYmIE51bWJlcihsZWZ0KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0cmlwWmVyb3MgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxlZnQgPSBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdCwgc2V0dGluZ3NDbG9uZSwgc3RyaXBaZXJvcyk7XG5cbiAgICAgICAgICAgIC8vIElmIHJpZ2h0IGlzIG5vdCBlbXB0eSBhbmQgZmlyc3QgY2hhcmFjdGVyIGlzIG5vdCBkZWNpbWFsQ2hhcmFjdGVyXG4gICAgICAgICAgICByaWdodCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhyaWdodCwgc2V0dGluZ3NDbG9uZSwgZmFsc2UpO1xuXG4gICAgICAgICAgICAvLyBQcmV2ZW50cyBtdWx0aXBsZSBsZWFkaW5nIHplcm9zIGZyb20gYmVpbmcgZW50ZXJlZFxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubGVhZGluZ1plcm8gPT09ICdkZW55JyAmJlxuICAgICAgICAgICAgICAgICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5udW0wIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bXBhZDApICYmXG4gICAgICAgICAgICAgICAgTnVtYmVyKGxlZnQpID09PSAwICYmXG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zKGxlZnQsIHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikgICYmIHJpZ2h0ICE9PSAnJykge1xuICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlICYmICFpc05lZ2F0aXZlKGxlZnQpKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9ICctJyArIGxlZnQ7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS50cmFpbGluZ05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluc2VydCB6ZXJvIGlmIGhhcyBsZWFkaW5nIGRvdFxuICAgICAgICAgICAgdGhpcy5uZXdWYWx1ZSA9IGxlZnQgKyByaWdodDtcbiAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtID0gdGhpcy5uZXdWYWx1ZS5tYXRjaChuZXcgUmVnRXhwKGBeJHtzZXR0aW5nc0Nsb25lLmFOZWdSZWdBdXRvU3RyaXB9XFxcXCR7c2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyfWApKTtcbiAgICAgICAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKG1bMV0sIG1bMV0gKyAnMCcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5ld1ZhbHVlID0gbGVmdCArIHJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0IHBhcnQgb2YgbnVtYmVyIHRvIHZhbHVlIHdoaWxlIGtlZXBpbmcgdGhlIGN1cnNvciBwb3NpdGlvbi4gLy9UT0RPIFdoYXQgYWJvdXQgdGhlIGN1cnNvciBzZWxlY3Rpb24/XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZWZ0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByaWdodFxuICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUGFzdGVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCwgaXNQYXN0ZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLl9ub3JtYWxpemVQYXJ0cyhsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih0aGlzLm5ld1ZhbHVlLCBzZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgIGxldCBwb3NpdGlvbiA9IHBhcnRzWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSBwYXJ0cy5qb2luKCcnKTtcblxuICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3VmFsdWUgPSB0cnVuY2F0ZURlY2ltYWwodGhpcy5uZXdWYWx1ZSwgc2V0dGluZ3NDbG9uZSwgaXNQYXN0ZSk7XG4gICAgICAgICAgICAgICAgLy9UT0RPIENoZWNrIGlmIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgaGFyZC1jb2RlZCAnLCcgd2l0aCBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFZhbHVlID0gKGNvbnRhaW5zKHRoaXMubmV3VmFsdWUsICcsJykpID8gdGhpcy5uZXdWYWx1ZS5yZXBsYWNlKCcsJywgJy4nKSA6IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RWYWx1ZSA9PT0gJycgfHwgdGVzdFZhbHVlID09PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID0gKHNldHRpbmdzQ2xvbmUuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnemVybycpID8gJzAnIDogJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5yYXdWYWx1ZSA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModGVzdFZhbHVlLCBzZXR0aW5nc0Nsb25lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPiB0aGlzLm5ld1ZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMubmV3VmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3aGVuIHRoZSB1c2VyIGVudGVyIGEgJzAnIG9uIHRoZSBmYXIgbGVmdCB3aXRoIGEgbGVhZGluZyB6ZXJvIG9wdGlvbiBzZXQgdG8gJ2RlbnknLCB0aGF0IHRoZSBjYXJldCBkb2VzIG5vdCBtb3ZlcyBzaW5jZSB0aGUgaW5wdXQgaXMgZHJvcHBlZCAoZml4IGlzc3VlICMyODMpXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAxICYmIHBhcnRzWzBdID09PSAnMCcgJiYgc2V0dGluZ3NDbG9uZS5sZWFkaW5nWmVybyA9PT0gJ2RlbnknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGVudGVyIGAwYCwgdGhlbiB0aGUgY2FyZXQgaXMgcHV0IG9uIHRoZSByaWdodCBzaWRlIG9mIGl0IChGaXggaXNzdWUgIzI5OSlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnRzWzFdID09PSAnJyB8fCBwYXJ0c1swXSA9PT0gJzAnICYmIHBhcnRzWzFdICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMubmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihwb3NpdGlvbiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbWluVGVzdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuJHRoYXQudHJpZ2dlcignYXV0b051bWVyaWM6bWluRXhjZWVkZWQnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiR0aGF0LnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1heEV4Y2VlZGVkJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gZm9yIGBfZXhwYW5kU2VsZWN0aW9uT25TaWduKClgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn0gU2lnbiBwb3NpdGlvbiBvZiBhIGZvcm1hdHRlZCB2YWx1ZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2dldFNpZ25Qb3NpdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbCA9IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2w7XG4gICAgICAgICAgICBjb25zdCB0aGF0ID0gdGhpcy50aGF0O1xuXG4gICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2wpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbExlbiA9IGN1cnJlbmN5U3ltYm9sLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc05lZyA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICYmIHRoYXQudmFsdWUgJiYgdGhhdC52YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzTmVnID8gWzEsIGN1cnJlbmN5U3ltYm9sTGVuICsgMV0gOiBbMCwgY3VycmVuY3lTeW1ib2xMZW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJldHVybiBbdmFsdWVMZW4gLSBjdXJyZW5jeVN5bWJvbExlbiwgdmFsdWVMZW5dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gWzEwMDAsIC0xXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeHBhbmRzIHNlbGVjdGlvbiB0byBjb3ZlciB3aG9sZSBzaWduXG4gICAgICAgICAqIFByZXZlbnRzIHBhcnRpYWwgZGVsZXRpb24vY29weWluZy9vdmVyd3JpdGluZyBvZiBhIHNpZ25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHt1bmRlZmluZWR8Ym9vbGVhbn0gc2V0UmVhbFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2V4cGFuZFNlbGVjdGlvbk9uU2lnbihzZXRSZWFsKSB7XG4gICAgICAgICAgICAvL1RPRE8gTW9kaWZ5IHNldFJlYWwgdG8gYmUgbW9yZSBleHBsaWNpdCAoYW5kIGEgYm9vbGVhbiBvbmx5KVxuICAgICAgICAgICAgLy9UT0RPIFVzZSBhcnJheSBkZXN0cnVjdHVyaW5nIGhlcmUgdG8gc2V0IHNpZ25Qb3NpdGlvbiB0byBtb3JlIGV4cGxpY2l0IHZhcmlhYmxlc1xuICAgICAgICAgICAgY29uc3Qgc2lnblBvc2l0aW9uID0gdGhpcy5fZ2V0U2lnblBvc2l0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcblxuICAgICAgICAgICAgLy8gSWYgc2VsZWN0aW9uIGNhdGNoZXMgc29tZXRoaW5nIGV4Y2VwdCBzaWduIGFuZCBjYXRjaGVzIG9ubHkgc3BhY2UgZnJvbSBzaWduXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uLnN0YXJ0IDwgc2lnblBvc2l0aW9uWzFdICYmIHNlbGVjdGlvbi5lbmQgPiBzaWduUG9zaXRpb25bMF0pIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVuIHNlbGVjdCB3aXRob3V0IGVtcHR5IHNwYWNlXG4gICAgICAgICAgICAgICAgaWYgKChzZWxlY3Rpb24uc3RhcnQgPCBzaWduUG9zaXRpb25bMF0gfHwgc2VsZWN0aW9uLmVuZCA+IHNpZ25Qb3NpdGlvblsxXSkgJiYgdGhpcy52YWx1ZS5zdWJzdHJpbmcoTWF0aC5tYXgoc2VsZWN0aW9uLnN0YXJ0LCBzaWduUG9zaXRpb25bMF0pLCBNYXRoLm1pbihzZWxlY3Rpb24uZW5kLCBzaWduUG9zaXRpb25bMV0pKS5tYXRjaCgvXlxccyokLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5zdGFydCA8IHNpZ25Qb3NpdGlvblswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0U2VsZWN0aW9uKHNlbGVjdGlvbi5zdGFydCwgc2lnblBvc2l0aW9uWzBdLCBzZXRSZWFsKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihzaWduUG9zaXRpb25bMV0sIHNlbGVjdGlvbi5lbmQsIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSBzZWxlY3Qgd2l0aCB3aG9sZSBzaWduXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFNlbGVjdGlvbihNYXRoLm1pbihzZWxlY3Rpb24uc3RhcnQsIHNpZ25Qb3NpdGlvblswXSksIE1hdGgubWF4KHNlbGVjdGlvbi5lbmQsIHNpZ25Qb3NpdGlvblsxXSksIHNldFJlYWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcnkgdG8gc3RyaXAgcGFzdGVkIHZhbHVlIHRvIGRpZ2l0c1xuICAgICAgICAgKi9cbiAgICAgICAgX2NoZWNrUGFzdGUoKSB7XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFBhcnRzID0gdGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgW2xlZnQsIHJpZ2h0XSA9IHRoaXMuX2dldExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgICAgIC8vIFRyeSB0byBzdHJpcCB0aGUgcGFzdGVkIHZhbHVlIGZpcnN0XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgbW9kaWZpZWRMZWZ0UGFydCA9IGxlZnQuc3Vic3RyKDAsIG9sZFBhcnRzWzBdLmxlbmd0aCkgKyBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnMobGVmdC5zdWJzdHIob2xkUGFydHNbMF0ubGVuZ3RoKSwgdGhpcy5zZXR0aW5nc0Nsb25lLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3NldFZhbHVlUGFydHMobW9kaWZpZWRMZWZ0UGFydCwgcmlnaHQsIHRydWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSBvbGRQYXJ0cy5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihvbGRQYXJ0c1swXS5sZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvY2VzcyBwYXN0aW5nLCBjdXJzb3IgbW92aW5nIGFuZCBza2lwcGluZyBvZiBub3QgaW50ZXJlc3Rpbmcga2V5cy5cbiAgICAgICAgICogSWYgdGhpcyBmdW5jdGlvbiByZXR1cm5zIFRSVUUsIHRoZW4gZnVydGhlciBwcm9jZXNzaW5nIGlzIG5vdCBwZXJmb3JtZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfc2tpcEFsd2F5cyhlKSB7XG4gICAgICAgICAgICAvLyBDYXRjaCB0aGUgY3RybCB1cCBvbiBjdHJsLXZcbiAgICAgICAgICAgIGlmICgoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmIGUudHlwZSA9PT0gJ2tleXVwJyAmJiAhaXNVbmRlZmluZWQodGhpcy52YWx1ZVBhcnRzQmVmb3JlUGFzdGUpKSB8fCAoZS5zaGlmdEtleSAmJiB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPIE1vdmUgdGhpcyB0ZXN0IGluc2lkZSB0aGUgYG9uS2V5dXBgIGhhbmRsZXJcbiAgICAgICAgICAgICAgICB0aGlzLl9jaGVja1Bhc3RlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTa2lwIGFsbCBmdW5jdGlvbiBrZXlzIChGMS1GMTIpLCBXaW5kb3dzIGtleXMsIHRhYiBhbmQgb3RoZXIgc3BlY2lhbCBrZXlzXG4gICAgICAgICAgICBpZiAoKHRoaXMuZXZlbnRLZXlDb2RlID49IGtleUNvZGUuRjEgJiYgdGhpcy5ldmVudEtleUNvZGUgPD0ga2V5Q29kZS5GMTIpIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXlDb2RlID49IGtleUNvZGUuV2luZG93cyAmJiB0aGlzLmV2ZW50S2V5Q29kZSA8PSBrZXlDb2RlLlJpZ2h0Q2xpY2spIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuZXZlbnRLZXlDb2RlID49IGtleUNvZGUuVGFiICYmIHRoaXMuZXZlbnRLZXlDb2RlIDwga2V5Q29kZS5TcGFjZSkgfHxcbiAgICAgICAgICAgICAgICAvLyBgZS53aGljaGAgaXMgc29tZXRpbWVzIGRpZmZlcmVudCB0aGFuIGB0aGlzLmV2ZW50S2V5Q29kZWAgZHVyaW5nIHRoZSBrZXlwcmVzcyBldmVudCB3aGVuIGVudGVyaW5nIGEgcHJpbnRhYmxlIGNoYXJhY3RlciBrZXkgKGllLiAndCcpLiBBbHNvLCBgZS53aGljaGAgZXF1YWxzIDAgZm9yIG5vbi1wcmludGFibGUgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAodGhpcy5ldmVudEtleUNvZGUgPCBrZXlDb2RlLkJhY2tzcGFjZSAmJlxuICAgICAgICAgICAgICAgIChlLndoaWNoID09PSAwIHx8IGUud2hpY2ggPT09IHRoaXMuZXZlbnRLZXlDb2RlKSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5OdW1Mb2NrIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuU2Nyb2xsTG9jayB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkluc2VydCB8fFxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkNvbW1hbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYSBcIlNlbGVjdCBhbGxcIiBrZXlib2FyZCBzaG9ydGN1dCBpcyBkZXRlY3RlZCAoY3RybCArIGEpXG4gICAgICAgICAgICBpZiAoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmIHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLmEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5zZWxlY3ROdW1iZXJPbmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBwcmV2ZW50RGVmYXVsdCgpYCBpcyB1c2VkIGhlcmUgdG8gcHJldmVudCB0aGUgYnJvd3NlciB0byBmaXJzdCBzZWxlY3QgYWxsIHRoZSBpbnB1dCB0ZXh0IChpbmNsdWRpbmcgdGhlIGN1cnJlbmN5IHNpZ24pLCBvdGhlcndpc2Ugd2Ugd291bGQgc2VlIHRoYXQgd2hvbGUgc2VsZWN0aW9uIGZpcnN0IGluIGEgZmxhc2gsIHRoZW4gdGhlIHNlbGVjdGlvbiB3aXRoIG9ubHkgdGhlIG51bWJlciBwYXJ0IHdpdGhvdXQgdGhlIGN1cnJlbmN5IHNpZ24uXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVMZW4gPSB0aGlzLnRoYXQudmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW5jeVN5bWJvbExlbiA9IHRoaXMuc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdMZW4gPSAoIWlzTmVnYXRpdmUodGhpcy50aGF0LnZhbHVlKSk/MDoxO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWZmaXhUZXh0TGVuID0gdGhpcy5zZXR0aW5ncy5zdWZmaXhUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPSB0aGlzLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9IHRoaXMuc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHN0YXJ0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAobmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdsJyAmJiBuZWdMZW4gPT09IDEgJiYgY3VycmVuY3lTeW1ib2xMZW4gPiAwKT9jdXJyZW5jeVN5bWJvbExlbiArIDE6Y3VycmVuY3lTeW1ib2xMZW47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBsZXQgZW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSBzdWZmaXhUZXh0TGVuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmQgPSB2YWx1ZUxlbiAtIChzdWZmaXhUZXh0TGVuICsgY3VycmVuY3lTeW1ib2xMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gKGN1cnJlbmN5U3ltYm9sTGVuID4gMCk/dmFsdWVMZW4gLSAoY3VycmVuY3lTeW1ib2xMZW4gKyBuZWdMZW4gKyBzdWZmaXhUZXh0TGVuKTp2YWx1ZUxlbiAtIChjdXJyZW5jeVN5bWJvbExlbiArIHN1ZmZpeFRleHRMZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kID0gdmFsdWVMZW4gLSAoY3VycmVuY3lTeW1ib2xMZW4gKyBzdWZmaXhUZXh0TGVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24odGhpcy50aGF0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgYSBcIkNvcHlcIiwgXCJQYXN0ZVwiIG9yIFwiQ3V0XCIga2V5Ym9hcmQgc2hvcnRjdXQgaXMgZGV0ZWN0ZWQgKHJlc3BlY3RpdmVseSAnY3RybCArIGMnLCAnY3RybCArIHYnIG9yICdjdHJsICsgeCcpXG4gICAgICAgICAgICBpZiAoKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpICYmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5jIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLnYgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUueCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kU2VsZWN0aW9uT25TaWduKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHByZXZlbnQgd3JvbmcgcGFzdGVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUudiB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5JbnNlcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVQYXJ0c0JlZm9yZVBhc3RlID0gdGhpcy5fZ2V0TGVmdEFuZFJpZ2h0UGFydEFyb3VuZFRoZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tQYXN0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudHlwZSA9PT0gJ2tleWRvd24nIHx8IGUudHlwZSA9PT0gJ2tleXByZXNzJyB8fCB0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5jO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBKdW1wIG92ZXIgdGhvdXNhbmQgc2VwYXJhdG9yXG4gICAgICAgICAgICAvL1RPRE8gTW92ZSB0aGlzIHRlc3QgaW5zaWRlIHRoZSBgb25LZXlkb3duYCBoYW5kbGVyXG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuTGVmdEFycm93IHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLlJpZ2h0QXJyb3cpIHtcbiAgICAgICAgICAgICAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkxlZnRBcnJvdyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudGhhdC52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAyKSA9PT0gdGhpcy5zZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhhdC52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgLSAyKSA9PT0gdGhpcy5zZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuUmlnaHRBcnJvdyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMudGhhdC52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgKyAxKSA9PT0gdGhpcy5zZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhhdC52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQgKyAxKSA9PT0gdGhpcy5zZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXJldFBvc2l0aW9uKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50S2V5Q29kZSA+PSBrZXlDb2RlLlBhZ2VEb3duICYmIHRoaXMuZXZlbnRLZXlDb2RlIDw9IGtleUNvZGUuRG93bkFycm93O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2Nlc3MgZGVsZXRpb24gb2YgY2hhcmFjdGVycyB3aGVuIHRoZSBtaW51cyBzaWduIGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbnVtZXJpYyBjaGFyYWN0ZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGVmdCBUaGUgcGFydCBvbiB0aGUgbGVmdCBvZiB0aGUgY2FyZXQgb3Igc2VsZWN0aW9uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSByaWdodCBUaGUgcGFydCBvbiB0aGUgcmlnaHQgb2YgdGhlIGNhcmV0IG9yIHNlbGVjdGlvblxuICAgICAgICAgKiBAcmV0dXJucyB7W3N0cmluZywgc3RyaW5nXX1cbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduKFtsZWZ0LCByaWdodF0pIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3AnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCA9ICh0aGlzLnNlbGVjdGlvbi5zdGFydCA+PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0KSAmJiBzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQgIT09ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudmFsdWUuY2hhckF0KHRoaXMuc2VsZWN0aW9uLnN0YXJ0IC0gMSkgPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0IDw9IHRoaXMudmFsdWUubGVuZ3RoIC0gc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLnN1ZmZpeFRleHQpICYmIHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCAhPT0gJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpICsgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmVnYXRpdmUobGVmdCkgJiYgdGhpcy52YWx1ZS5jaGFyQXQodGhpcy5zZWxlY3Rpb24uc3RhcnQpID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9UT0RPIE1lcmdlIHRoZSB0d28gZm9sbG93aW5nICdpZicgYmxvY2tzIGludG8gb25lIGBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7YCBhbmQgYSBzd2l0Y2ggb24gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudFxuICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikgKyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCkgJiYgY29udGFpbnModGhpcy52YWx1ZSwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJy0nICYmICgodGhpcy5zZWxlY3Rpb24uc3RhcnQgPD0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkgfHwgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnRbMF0gPT09ICctJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID09PSB0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICYmIGNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgPT09ICdyJykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPj0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSArIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLkJhY2tzcGFjZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3Rpb24uc3RhcnQgPT09ICh0aGlzLnZhbHVlLmluZGV4T2Yoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpICsgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxlZnQgIT09ICctJyAmJiB0aGlzLnNlbGVjdGlvbi5zdGFydCA8PSAodGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSAtIHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGVmdCAhPT0gJycgJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDAsIGxlZnQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLmNhcmV0Rml4ID0gKHRoaXMuc2VsZWN0aW9uLnN0YXJ0ID49IHRoaXMudmFsdWUuaW5kZXhPZihzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICE9PSAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNlbGVjdGlvbi5zdGFydCA9PT0gdGhpcy52YWx1ZS5pbmRleE9mKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIFtsZWZ0LCByaWdodF07XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvY2VzcyB0aGUgZGVsZXRpb24gb2YgY2hhcmFjdGVycy5cbiAgICAgICAgICovXG4gICAgICAgIF9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICBsZXQgbGVmdDtcbiAgICAgICAgICAgIGxldCByaWdodDtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnNlbGVjdGlvbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIHJpZ2h0ID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoKChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcgfHwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3InKSkpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzTmVnYXRpdmUodGhpcy52YWx1ZSkpIHsgLy9UT0RPIENoYW5nZSBgdGhpcy52YWx1ZWAgdG8gYHRoaXMudGhhdC52YWx1ZWA/XG4gICAgICAgICAgICAgICAgICAgIFtsZWZ0LCByaWdodF0gPSB0aGlzLl9wcm9jZXNzQ2hhcmFjdGVyRGVsZXRpb25JZlRyYWlsaW5nTmVnYXRpdmVTaWduKFtsZWZ0LCByaWdodF0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygwLCBsZWZ0Lmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHJpbmcoMSwgcmlnaHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXhwYW5kU2VsZWN0aW9uT25TaWduKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBbbGVmdCwgcmlnaHRdID0gdGhpcy5fZ2V0VW5mb3JtYXR0ZWRMZWZ0QW5kUmlnaHRQYXJ0QXJvdW5kVGhlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NldFZhbHVlUGFydHMobGVmdCwgcmlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb24gZGVjaWRlcyBpZiB0aGUga2V5IHByZXNzZWQgc2hvdWxkIGJlIGRyb3BwZWQgb3IgYWNjZXB0ZWQsIGFuZCBtb2RpZnkgdGhlIHZhbHVlICdvbi10aGUtZmx5JyBhY2NvcmRpbmdseS5cbiAgICAgICAgICogUmV0dXJucyBUUlVFIGlmIHRoZSBrZXljb2RlIGlzIGFsbG93ZWQuXG4gICAgICAgICAqIFRoaXMgZnVuY3Rpb25zIGFsc28gbW9kaWZ5IHRoZSB2YWx1ZSBvbi10aGUtZmx5LiAvL0ZJWE1FIFRoaXMgc2hvdWxkIHVzZSBhbm90aGVyIGZ1bmN0aW9uIGluIG9yZGVyIHRvIHNlcGFyYXRlIHRoZSB0ZXN0IGFuZCB0aGUgbW9kaWZpY2F0aW9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgICAqL1xuICAgICAgICBfcHJvY2Vzc0NoYXJhY3Rlckluc2VydGlvbihlKSB7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5nc0Nsb25lID0gdGhpcy5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIFJldHJpZXZlIHRoZSByZWFsIGNoYXJhY3RlciB0aGF0IGhhcyBiZWVuIGVudGVyZWQgKGllLiAnYScgaW5zdGVhZCBvZiB0aGUga2V5IGNvZGUpXG4gICAgICAgICAgICBjb25zdCBldmVudENoYXJhY3RlciA9IGNoYXJhY3RlcihlKTtcblxuICAgICAgICAgICAgLy8gU3RhcnQgcnVsZXMgd2hlbiB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIga2V5IGlzIHByZXNzZWQgYWx3YXlzIHVzZSBudW1lcmljIHBhZCBkb3QgdG8gaW5zZXJ0IGRlY2ltYWwgc2VwYXJhdG9yXG4gICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgbm8gZGVjaW1hbCBwYXJ0IGFsbG93ZWRcbiAgICAgICAgICAgIGlmIChldmVudENoYXJhY3RlciA9PT0gc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyIHx8XG4gICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlICYmIGV2ZW50Q2hhcmFjdGVyID09PSBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSkgfHxcbiAgICAgICAgICAgICAgICAoKGV2ZW50Q2hhcmFjdGVyID09PSAnLicgfHwgZXZlbnRDaGFyYWN0ZXIgPT09ICcsJykgJiYgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuRG90TnVtcGFkKSkge1xuICAgICAgICAgICAgICAgIGlmICghc2V0dGluZ3NDbG9uZS5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgfHwgIXNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgYmVmb3JlIG5lZ2F0aXZlU2lnbkNoYXJhY3RlciBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgJiYgY29udGFpbnMocmlnaHQsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEbyBub3QgYWxsb3cgZGVjaW1hbCBjaGFyYWN0ZXIgaWYgb3RoZXIgZGVjaW1hbCBjaGFyYWN0ZXIgcHJlc2VudFxuICAgICAgICAgICAgICAgIGlmIChjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyaWdodC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuZGVjaW1hbENoYXJhY3RlcikgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSByaWdodC5zdWJzdHIoMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgc2V0dGluZ3NDbG9uZS5kZWNpbWFsQ2hhcmFjdGVyLCByaWdodCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUHJldmVudCBtaW51cyBpZiBub3QgYWxsb3dlZFxuICAgICAgICAgICAgaWYgKChldmVudENoYXJhY3RlciA9PT0gJy0nIHx8IGV2ZW50Q2hhcmFjdGVyID09PSAnKycpICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzQ2xvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ2FyZXQgaXMgYWx3YXlzIGFmdGVyIG1pbnVzXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcgJiYgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9PT0gJ3MnKSB8fCAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnICYmIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gcmlnaHQuc3Vic3RyaW5nKDEsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBDaGFuZ2UgbnVtYmVyIHNpZ24sIHJlbW92ZSBwYXJ0IGlmIHNob3VsZFxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOZWdhdGl2ZVN0cmljdChsZWZ0KSB8fCBjb250YWlucyhsZWZ0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnN1YnN0cmluZygxLCBsZWZ0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gKGV2ZW50Q2hhcmFjdGVyID09PSAnLScpID8gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBsZWZ0IDogbGVmdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0ID09PSAnJyAmJiBjb250YWlucyhyaWdodCwgc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlIG51bWJlciBzaWduLCByZW1vdmUgcGFydCBpZiBzaG91bGRcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlZnQuY2hhckF0KDApID09PSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGxlZnQuc3Vic3RyaW5nKDEsIGxlZnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgPSAoZXZlbnRDaGFyYWN0ZXIgPT09ICctJykgPyBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGxlZnQgOiBsZWZ0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0LCByaWdodCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgdHJpZXMgdG8gaW5zZXJ0IGRpZ2l0IGJlZm9yZSBtaW51cyBzaWduXG4gICAgICAgICAgICBjb25zdCBldmVudE51bWJlciA9IE51bWJlcihldmVudENoYXJhY3Rlcik7XG4gICAgICAgICAgICBpZiAoZXZlbnROdW1iZXIgPj0gMCAmJiBldmVudE51bWJlciA8PSA5KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyICYmIGxlZnQgPT09ICcnICYmIGNvbnRhaW5zKHJpZ2h0LCBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyO1xuICAgICAgICAgICAgICAgICAgICByaWdodCA9IHJpZ2h0LnN1YnN0cmluZygxLCByaWdodC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5nc0Nsb25lLm1heGltdW1WYWx1ZSA8PSAwICYmIHNldHRpbmdzQ2xvbmUubWluaW11bVZhbHVlIDwgc2V0dGluZ3NDbG9uZS5tYXhpbXVtVmFsdWUgJiYgIWNvbnRhaW5zKHRoaXMudmFsdWUsIHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSAmJiBldmVudENoYXJhY3RlciAhPT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciArIGxlZnQ7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0VmFsdWVQYXJ0cyhsZWZ0ICsgZXZlbnRDaGFyYWN0ZXIsIHJpZ2h0KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBQcmV2ZW50IGFueSBvdGhlciBjaGFyYWN0ZXJcbiAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRm9ybWF0dGluZyBvZiBqdXN0IHByb2Nlc3NlZCB2YWx1ZSB3aGlsZSBrZWVwaW5nIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgX2Zvcm1hdFZhbHVlKGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzQ2xvbmUgPSB0aGlzLnNldHRpbmdzQ2xvbmU7XG4gICAgICAgICAgICBjb25zdCBsZWZ0TGVuZ3RoID0gdGhpcy52YWx1ZTtcbiAgICAgICAgICAgIGxldCBbbGVmdF0gPSB0aGlzLl9nZXRVbmZvcm1hdHRlZExlZnRBbmRSaWdodFBhcnRBcm91bmRUaGVTZWxlY3Rpb24oKTtcblxuICAgICAgICAgICAgLy8gTm8gZ3JvdXBpbmcgc2VwYXJhdG9yIGFuZCBubyBjdXJyZW5jeSBzaWduXG4gICAgICAgICAgICBpZiAoKHNldHRpbmdzQ2xvbmUuZGlnaXRHcm91cFNlcGFyYXRvciAgPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmRpZ2l0R3JvdXBTZXBhcmF0b3IgIT09ICcnICAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5kaWdpdEdyb3VwU2VwYXJhdG9yKSkpICYmXG4gICAgICAgICAgICAgICAgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wgPT09ICcnIHx8IChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sICE9PSAnJyAmJiAhY29udGFpbnMobGVmdExlbmd0aCwgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCkpKSkge1xuICAgICAgICAgICAgICAgIGxldCBbc3ViUGFydHNdID0gbGVmdExlbmd0aC5zcGxpdChzZXR0aW5nc0Nsb25lLmRlY2ltYWxDaGFyYWN0ZXIpO1xuICAgICAgICAgICAgICAgIGxldCBuU2lnbiA9ICcnO1xuICAgICAgICAgICAgICAgIGlmIChpc05lZ2F0aXZlKHN1YlBhcnRzKSkge1xuICAgICAgICAgICAgICAgICAgICBuU2lnbiA9ICctJztcbiAgICAgICAgICAgICAgICAgICAgc3ViUGFydHMgPSBzdWJQYXJ0cy5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBwb3NpdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICcnICYmIHN1YlBhcnRzLmxlbmd0aCA+IHNldHRpbmdzQ2xvbmUubUludFBvcyAmJiBsZWZ0LmNoYXJBdCgwKSA9PT0gJzAnKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBsZWZ0LnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgemVybyBvbiBuZWdhdGl2ZSB2YWx1ZSBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoblNpZ24gPT09ICctJyAmJiBzdWJQYXJ0cy5sZW5ndGggPiBzZXR0aW5nc0Nsb25lLm1JbnROZWcgJiYgbGVmdC5jaGFyQXQoMCkgPT09ICcwJykge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gbGVmdC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZWZ0ID0gblNpZ24gKyBsZWZ0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGFkZEdyb3VwU2VwYXJhdG9ycyh0aGlzLnZhbHVlLCB0aGlzLnNldHRpbmdzQ2xvbmUpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlcGFyZSByZWdleHAgd2hpY2ggc2VhcmNoZXMgZm9yIGN1cnNvciBwb3NpdGlvbiBmcm9tIHVuZm9ybWF0dGVkIGxlZnQgcGFydFxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRBciA9IGxlZnQuc3BsaXQoJycpO1xuXG4gICAgICAgICAgICAgICAgLy8gRml4ZXMgY2FyZXQgcG9zaXRpb24gd2l0aCB0cmFpbGluZyBtaW51cyBzaWduXG4gICAgICAgICAgICAgICAgaWYgKChzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycgfHwgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ICE9PSAncCcpKSAmJlxuICAgICAgICAgICAgICAgICAgICBsZWZ0QXJbMF0gPT09ICctJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdEFyLnNoaWZ0KCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgdGhpcy5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuRGVsZXRlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3NDbG9uZS5jYXJldEZpeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdwJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaCgnLScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJyAmJiBzZXR0aW5nc0Nsb25lLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduUGFydHMgPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLnNwbGl0KCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlc2NhcGVDaHIgPSBbJ1xcXFwnLCAnXicsICckJywgJy4nLCAnfCcsICc/JywgJyonLCAnKycsICcoJywgJyknLCAnWyddO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRQYXJ0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQuZWFjaChzaWduUGFydHMsIChpLCBtaW5pUGFydHMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaVBhcnRzID0gc2lnblBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbkFycmF5KG1pbmlQYXJ0cywgZXNjYXBlQ2hyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJ1xcXFwnICsgbWluaVBhcnRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVzY2FwZWRQYXJ0cy5wdXNoKG1pbmlQYXJ0cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXNjYXBlZFBhcnRzLnB1c2goJy0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQdXNoaW5nIHRoZSBlc2NhcGVkIHNpZ25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXIucHVzaChlc2NhcGVkUGFydHMuam9pbignJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzQ2xvbmUuY2FyZXRGaXggPSBlLnR5cGUgPT09ICdrZXlkb3duJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVmdEFyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGVmdEFyW2ldLm1hdGNoKCdcXFxcZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0QXJbaV0gPSAnXFxcXCcgKyBsZWZ0QXJbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0UmVnID0gbmV3IFJlZ0V4cCgnXi4qPycgKyBsZWZ0QXIuam9pbignLio/JykpO1xuXG4gICAgICAgICAgICAgICAgLy8gU2VhcmNoIGN1cnNvciBwb3NpdGlvbiBpbiBmb3JtYXR0ZWQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdMZWZ0ID0gdmFsdWUubWF0Y2gobGVmdFJlZyk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld0xlZnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBuZXdMZWZ0WzBdLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcG9zaXRpdmUgc2lnbiBpcyBzaG93biwgY2FsY3VsYXRlIHRoZSBjYXJldCBwb3NpdGlvbiBhY2NvcmRpbmdseVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5zaG93UG9zaXRpdmVTaWduKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgbmV3TGVmdC5pbnB1dC5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUucG9zaXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSAobmV3TGVmdC5pbnB1dC5pbmRleE9mKHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wpID09PSAxKSA/IHNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2wubGVuZ3RoICsgMSA6IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCAmJiBuZXdMZWZ0LmlucHV0LmNoYXJBdChzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCkgPT09IHNldHRpbmdzQ2xvbmUucG9zaXRpdmVTaWduQ2hhcmFjdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhcmUganVzdCBiZWZvcmUgdGhlIHNpZ24gd2hpY2ggaXMgaW4gcHJlZml4IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKHBvc2l0aW9uID09PSAwICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gc2V0dGluZ3NDbG9uZS5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHx8IChwb3NpdGlvbiA9PT0gMSAmJiB2YWx1ZS5jaGFyQXQoMCkgPT09IHNldHRpbmdzQ2xvbmUubmVnYXRpdmVTaWduQ2hhcmFjdGVyKSkgJiYgc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGNhcmV0IGFmdGVyIHByZWZpeCBzaWduXG4gICAgICAgICAgICAgICAgICAgICAgICAvL1RPRE8gU2hvdWxkIHRoZSB0ZXN0IGJlICdpc05lZ2F0aXZlJyBpbnN0ZWFkIG9mICdpc05lZ2F0aXZlU3RyaWN0JyBpbiBvcmRlciB0byBzZWFyY2ggZm9yICctJyBldmVyeXdoZXJlIGluIHRoZSBzdHJpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGggKyAoaXNOZWdhdGl2ZVN0cmljdCh2YWx1ZSkgPyAxIDogMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAmJiBzZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sUGxhY2VtZW50ID09PSAncycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGNvdWxkIG5vdCBmaW5kIGEgcGxhY2UgZm9yIGN1cnNvciBhbmQgaGF2ZSBhIHNpZ24gYXMgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXggY3VycmVuY3kgc2lnblxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gLT0gc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZCBub3QgZmluZCBhIHBsYWNlIGZvciBjdXJzb3IgYW5kIGhhdmUgYSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBsYWNlIGNhcmV0IGJlZm9yZSBzdWZmaXhcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIC09IHNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE9ubHkgdXBkYXRlIHRoZSB2YWx1ZSBpZiBpdCBoYXMgY2hhbmdlZC4gVGhpcyBwcmV2ZW50cyBtb2RpZnlpbmcgdGhlIHNlbGVjdGlvbiwgaWYgYW55LlxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLnRoYXQudmFsdWUgfHxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9PT0gdGhpcy50aGF0LnZhbHVlICYmICh0aGlzLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5udW0wIHx8IHRoaXMuZXZlbnRLZXlDb2RlID09PSBrZXlDb2RlLm51bXBhZDApKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aGF0LnZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0Q2FyZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZm9ybWF0dGVkID0gdHJ1ZTsgLy9UT0RPIFJlbmFtZSBgdGhpcy5mb3JtYXR0ZWRgIHRvIGB0aGlzLl9mb3JtYXRFeGVjdXRlZGAsIHNpbmNlIGl0J3MgcG9zc2libGUgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGZvcm1hdCBhbnl0aGluZyAoaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIGtleWNvZGUgaXMgZHJvcHBlZCBmb3IgaW5zdGFuY2UpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGZhY3RvcmlzZSB0aGUgYGdldFN0cmluZygpYCBhbmQgYGdldEFycmF5KClgIGZ1bmN0aW9ucyBzaW5jZSB0aGV5IHNoYXJlIHF1aXRlIGEgbG90IG9mIGNvZGUuXG4gICAgICpcbiAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxuICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEl0IHRoZW4gbG9vcHMgdGhyb3VnaCB0aGUgc3RyaW5nIGFuZCB1bi1mb3JtYXRzIHRoZSBpbnB1dHMgd2l0aCBhdXRvTnVtZXJpYy5cbiAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiwgb3IgZXZlbiBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIG1vcmUgZGV0YWlsc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBnZXRBcnJheUJlaGF2aW9yIC0gSWYgc2V0IHRvIFRSVUUsIHRoZW4gdGhpcyBmdW5jdGlvbiBiZWhhdmUgbGlrZSBgZ2V0QXJyYXkoKWAsIG90aGVyd2lzZSBpZiBzZXQgdG8gRkFMU0UsIGl0IGJlaGF2ZSBsaWtlIGBnZXRTdHJpbmcoKWBcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0aGF0IC0gQSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIF9nZXRTdHJpbmdPckFycmF5KGdldEFycmF5QmVoYXZpb3IgPSB0cnVlLCB0aGF0KSB7XG4gICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhhdCk7XG4gICAgICAgIGNvbnN0IGZvcm1JbmRleCA9ICQoJ2Zvcm0nKS5pbmRleCgkdGhpcyk7XG4gICAgICAgIGNvbnN0IGFsbEZvcm1FbGVtZW50cyA9ICQoYGZvcm06ZXEoJHtmb3JtSW5kZXh9KWApWzBdO1xuICAgICAgICBjb25zdCBhaUluZGV4ID0gW107XG5cbiAgICAgICAgLy8gYWxsIGlucHV0IGluZGV4XG4gICAgICAgIGNvbnN0IHNjSW5kZXggPSBbXTtcblxuICAgICAgICAvLyBzdWNjZXNzZnVsIGNvbnRyb2wgaW5kZXhcbiAgICAgICAgY29uc3QgclN1Ym1pdHRlclR5cGVzID0gL14oPzpzdWJtaXR8YnV0dG9ufGltYWdlfHJlc2V0fGZpbGUpJC9pO1xuXG4gICAgICAgIC8vIGZyb20galF1ZXJ5IHNlcmlhbGl6ZSBtZXRob2RcbiAgICAgICAgY29uc3QgclN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG4gICAgICAgIC8vIGZyb20galF1ZXJ5IHNlcmlhbGl6ZSBtZXRob2RcbiAgICAgICAgY29uc3QgckNoZWNrYWJsZVR5cGUgPSAvXig/OmNoZWNrYm94fHJhZGlvKSQvaTtcbiAgICAgICAgY29uc3Qgck5vbkF1dG9OdW1lcmljVHlwZXMgPSAvXig/OmJ1dHRvbnxjaGVja2JveHxjb2xvcnxkYXRlfGRhdGV0aW1lfGRhdGV0aW1lLWxvY2FsfGVtYWlsfGZpbGV8aW1hZ2V8bW9udGh8bnVtYmVyfHBhc3N3b3JkfHJhZGlvfHJhbmdlfHJlc2V0fHNlYXJjaHxzdWJtaXR8dGltZXx1cmx8d2VlaykvaTtcblxuICAgICAgICBsZXQgY291bnQgPSAwO1xuXG4gICAgICAgIC8vIGluZGV4IG9mIHN1Y2Nlc3NmdWwgZWxlbWVudHNcbiAgICAgICAgJC5lYWNoKGFsbEZvcm1FbGVtZW50cywgKGksIGZpZWxkKSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSAhPT0gJycgJiYgclN1Ym1pdHRhYmxlLnRlc3QoZmllbGQubG9jYWxOYW1lKSAmJiAhclN1Ym1pdHRlclR5cGVzLnRlc3QoZmllbGQudHlwZSkgJiYgIWZpZWxkLmRpc2FibGVkICYmIChmaWVsZC5jaGVja2VkIHx8ICFyQ2hlY2thYmxlVHlwZS50ZXN0KGZpZWxkLnR5cGUpKSkge1xuICAgICAgICAgICAgICAgIHNjSW5kZXgucHVzaChjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NJbmRleC5wdXNoKC0xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaW5kZXggb2YgYWxsIGlucHV0cyB0YWdzIGV4Y2VwdCBjaGVja2JveFxuICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICQuZWFjaChhbGxGb3JtRWxlbWVudHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiAoZmllbGQudHlwZSA9PT0gJycgfHwgZmllbGQudHlwZSA9PT0gJ3RleHQnIHx8IGZpZWxkLnR5cGUgPT09ICdoaWRkZW4nIHx8IGZpZWxkLnR5cGUgPT09ICd0ZWwnKSkge1xuICAgICAgICAgICAgICAgIGFpSW5kZXgucHVzaChjb3VudCk7XG4gICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWlJbmRleC5wdXNoKC0xKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIHJOb25BdXRvTnVtZXJpY1R5cGVzLnRlc3QoZmllbGQudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChnZXRBcnJheUJlaGF2aW9yKSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplQXJyYXkoKTtcblxuICAgICAgICAgICAgJC5lYWNoKGZvcm1GaWVsZHMsIChpLCBmaWVsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjRWxlbWVudCA9IHNjSW5kZXguaW5kZXhPZihpKTtcblxuICAgICAgICAgICAgICAgIGlmIChzY0VsZW1lbnQgPiAtMSAmJiBhaUluZGV4W3NjRWxlbWVudF0gPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXN0SW5wdXQgPSAkKGBmb3JtOmVxKCR7Zm9ybUluZGV4fSkgaW5wdXQ6ZXEoJHthaUluZGV4W3NjRWxlbWVudF19KWApO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRlc3RJbnB1dC5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC52YWx1ZSA9IHRlc3RJbnB1dC5hdXRvTnVtZXJpYygnZ2V0TG9jYWxpemVkJykudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gZm9ybUZpZWxkcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGdldFN0cmluZygpIGJlaGF2aW9yXG4gICAgICAgICAgICBjb25zdCBmb3JtRmllbGRzID0gJHRoaXMuc2VyaWFsaXplKCk7XG4gICAgICAgICAgICBjb25zdCBmb3JtUGFydHMgPSBmb3JtRmllbGRzLnNwbGl0KCcmJyk7XG5cbiAgICAgICAgICAgICQuZWFjaChmb3JtUGFydHMsIGkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtpbnB1dE5hbWUsIGlucHV0VmFsdWVdID0gZm9ybVBhcnRzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NFbGVtZW50ID0gc2NJbmRleC5pbmRleE9mKGkpO1xuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgZWxlbWVudCBpcyBhIHZhbGlkIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoc2NFbGVtZW50ID4gLTEgJiYgYWlJbmRleFtzY0VsZW1lbnRdID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVzdElucHV0ID0gJChgZm9ybTplcSgke2Zvcm1JbmRleH0pIGlucHV0OmVxKCR7YWlJbmRleFtzY0VsZW1lbnRdfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0ZXN0SW5wdXQuZGF0YSgnYXV0b051bWVyaWMnKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0VmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RpZmllZElucHV0VmFsdWUgPSB0ZXN0SW5wdXQuYXV0b051bWVyaWMoJ2dldExvY2FsaXplZCcpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybVBhcnRzW2ldID0gYCR7aW5wdXROYW1lfT0ke21vZGlmaWVkSW5wdXRWYWx1ZX1gO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBmb3JtUGFydHMuam9pbignJicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlciBmb3IgJ2ZvY3VzaW4nIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpIHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSBob2xkZXIuc2V0dGluZ3NDbG9uZTtcblxuICAgICAgICBpZiAoZS50eXBlID09PSAnZm9jdXNpbicgfHwgZS50eXBlID09PSAnbW91c2VlbnRlcicgJiYgISR0aGlzLmlzKCc6Zm9jdXMnKSAmJiBzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICE9PSBudWxsICYmIHNldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3RlciAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy52YWwodG9nZ2xlTmVnYXRpdmVCcmFja2V0KGUudGFyZ2V0LnZhbHVlLCBzZXR0aW5ncykpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjbGVhbiB0aGUgdmFsdWUgdG8gY29tcGFyZSB0byByYXdWYWx1ZVxuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyhlLnRhcmdldC52YWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgcmVzdWx0ID0gY29udmVydFRvTnVtZXJpY1N0cmluZyhyZXN1bHQsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3MocmVzdWx0LCBzZXR0aW5ncyk7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICctJyArIHJlc3VsdDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzO1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvcikge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IHNldHRpbmdzLm9EZWM7XG4gICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHNldHRpbmdzLnJhd1ZhbHVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2V0dGluZ3Mubm9TZXBhcmF0b3JPbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciA9ICcnO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sID0gJyc7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Muc3VmZml4VGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBzZXR0aW5ncy5yYXdWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlc3VsdCAhPT0gc2V0dGluZ3MucmF3VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSW4gb3JkZXIgdG8gc2VuZCBhICduYXRpdmUnIGNoYW5nZSBldmVudCB3aGVuIGJsdXJyaW5nIHRoZSBpbnB1dCwgd2UgbmVlZCB0byBmaXJzdCBzdG9yZSB0aGUgaW5pdGlhbCBpbnB1dCB2YWx1ZSBvbiBmb2N1cy5cbiAgICAgICAgICAgIGhvbGRlci52YWx1ZU9uRm9jdXMgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGhvbGRlci5sYXN0VmFsID0gaG9sZGVyLnZhbHVlT25Gb2N1cztcbiAgICAgICAgICAgIGNvbnN0IG9uRW1wdHkgPSBjaGVja0VtcHR5KGhvbGRlci52YWx1ZU9uRm9jdXMsIHNldHRpbmdzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICgob25FbXB0eSAhPT0gbnVsbCAmJiBvbkVtcHR5ICE9PSAnJykgJiYgc2V0dGluZ3MuZW1wdHlJbnB1dEJlaGF2aW9yID09PSAnZm9jdXMnKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMudmFsKG9uRW1wdHkpO1xuICAgICAgICAgICAgICAgIGlmIChvbkVtcHR5ID09PSBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbCAmJiBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlkb3duJyBldmVudHMuXG4gICAgICogVGhlIHVzZXIganVzdCBzdGFydGVkIHB1c2hpbmcgYW55IGtleSwgaGVuY2Ugb25lIGV2ZW50IGlzIHNlbnQuXG4gICAgICpcbiAgICAgKiBOb3RlIDpcbiAgICAgKiBCeSBkZWZhdWx0IGEgJ25vcm1hbCcgaW5wdXQgb3V0cHV0IHRob3NlIGV2ZW50cyBpbiB0aGUgcmlnaHQgb3JkZXIgd2hlbiBpbnB1dHRpbmcgYSBjaGFyYWN0ZXIga2V5IChpZS4gJ2EnKSA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBrZXlwcmVzc1xuICAgICAqIC0gaW5wdXRcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiAuLi53aGVuIGlucHV0dGluZyBhIG1vZGlmaWVyIGtleSAoaWUuICdjdHJsJykgOlxuICAgICAqIC0ga2V5ZG93blxuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIElmICdkZWxldGUnIG9yICdiYWNrc3BhY2UnIGlzIGVudGVyZWQsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGlucHV0XG4gICAgICogLSBrZXl1cFxuICAgICAqXG4gICAgICogSWYgJ2VudGVyJyBpcyBlbnRlcmVkIGFuZCB0aGUgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLCB0aGUgZm9sbG93aW5nIGV2ZW50cyBhcmUgc2VudCA6XG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBrZXlwcmVzc1xuICAgICAqIC0ga2V5dXBcbiAgICAgKlxuICAgICAqIElmICdlbnRlcicgaXMgZW50ZXJlZCBhbmQgdGhlIHZhbHVlIGhhcyBiZWVuIGNoYW5nZWQsIHRoZSBmb2xsb3dpbmcgZXZlbnRzIGFyZSBzZW50IDpcbiAgICAgKiAtIGtleWRvd25cbiAgICAgKiAtIGtleXByZXNzXG4gICAgICogLSBjaGFuZ2VcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBXaGVuIGEgcGFzdGUgaXMgZG9uZSwgdGhlIGZvbGxvd2luZyBldmVudHMgYXJlIHNlbnQgOlxuICAgICAqIC0gaW5wdXQgKGlmIHBhc3RlIGlzIGRvbmUgd2l0aCB0aGUgbW91c2UpXG4gICAgICpcbiAgICAgKiAtIGtleWRvd24gKGlmIHBhc3RlIGlzIGRvbmUgd2l0aCBjdHJsK3YpXG4gICAgICogLSBrZXlkb3duXG4gICAgICogLSBpbnB1dFxuICAgICAqIC0ga2V5dXBcbiAgICAgKiAtIGtleXVwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25LZXlkb3duKGhvbGRlciwgZSkge1xuICAgICAgICAvL1RPRE8gQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXRyaWV2ZSB0aGUgZWxlbWVudCB2YWx1ZSAoZWl0aGVyIGJ5IHVzaW5nIGBlLnRhcmdldC52YWx1ZWAgd2hlbiB0aGUgZWxlbWVudCBpcyBhbiA8aW5wdXQ+LCBvciBieSB1c2luZyBgZWxlbWVudC50ZXh0Q29udGVudGAgd2hlbiB0aGUgZWxlbWVudCBhcyBpdHMgYGNvbnRlbnRlZGl0YWJsZWAgc2V0IHRvIHRydWUpXG4gICAgICAgIGhvbGRlci5fdXBkYXRlQXV0b051bWVyaWNIb2xkZXJFdmVudEtleWNvZGUoZSk7XG4gICAgICAgIGhvbGRlci5pbml0aWFsVmFsdWVPbktleWRvd24gPSBlLnRhcmdldC52YWx1ZTsgLy8gVGhpcyBpcyBuZWVkZWQgaW4gYG9uS2V5dXAoKWAgdG8gY2hlY2sgaWYgdGhlIHZhbHVlIGFzIGNoYW5nZWQgZHVyaW5nIHRoZSBrZXkgcHJlc3NcblxuICAgICAgICBpZiAoaG9sZGVyLnRoYXQucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIGhvbGRlci5wcm9jZXNzZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgXCJlbnRlclwiIGtleSB0aHJvd3MgYSBgY2hhbmdlYCBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGBmb2N1c2AgZXZlbnRcbiAgICAgICAgaWYgKGhvbGRlci5ldmVudEtleUNvZGUgPT09IGtleUNvZGUuRW50ZXIgJiYgaG9sZGVyLnZhbHVlT25Gb2N1cyAhPT0gZS50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgIHRyaWdnZXJFdmVudCgnY2hhbmdlJywgZS50YXJnZXQpO1xuICAgICAgICAgICAgaG9sZGVyLnZhbHVlT25Gb2N1cyA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaG9sZGVyLl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlclByb3BlcnRpZXMoZSk7XG5cbiAgICAgICAgaWYgKGhvbGRlci5fc2tpcEFsd2F5cyhlKSkge1xuICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBrZXkgaXMgYSBkZWxldGUvYmFja3NwYWNlIGtleVxuICAgICAgICBpZiAoaG9sZGVyLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5CYWNrc3BhY2UgfHwgaG9sZGVyLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5EZWxldGUpIHtcbiAgICAgICAgICAgIGhvbGRlci5fcHJvY2Vzc0NoYXJhY3RlckRlbGV0aW9uKCk7IC8vIEJlY2F1c2UgYmFja3NwYWNlIGFuZCBkZWxldGUgb25seSB0cmlnZ2VycyBrZXlkb3duIGFuZCBrZXl1cCBldmVudHMsIG5vdCBrZXlwcmVzc1xuICAgICAgICAgICAgaG9sZGVyLnByb2Nlc3NlZCA9IHRydWU7XG4gICAgICAgICAgICBob2xkZXIuX2Zvcm1hdFZhbHVlKGUpO1xuXG4gICAgICAgICAgICAvLyBJZiBhbmQgb25seSBpZiB0aGUgcmVzdWx0aW5nIHZhbHVlIGhhcyBjaGFuZ2VkIGFmdGVyIHRoYXQgYmFja3NwYWNlL2RlbGV0ZSwgdGhlbiB3ZSBoYXZlIHRvIHNlbmQgYW4gJ2lucHV0JyBldmVudCBsaWtlIGJyb3dzZXJzIG5vcm1hbGx5IGRvLlxuICAgICAgICAgICAgaWYgKChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLmxhc3RWYWwpICYmIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBpbnB1dCBldmVudCB3aGVuIGEgY2hhcmFjdGVyIGRlbGV0aW9uIGlzIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdpbnB1dCcsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIGRlbGV0ZSBhIHNlY29uZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBob2xkZXIuZm9ybWF0dGVkID0gZmFsc2U7IC8vVE9ETyBJcyB0aGlzIGxpbmUgbmVlZGVkP1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdrZXlwcmVzcycgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGlzIHN0aWxsIHByZXNzaW5nIHRoZSBrZXksIHdoaWNoIHdpbGwgb3V0cHV0IGEgY2hhcmFjdGVyIChpZS4gJzInKSBjb250aW51b3VzbHkgdW50aWwgaXQgcmVsZWFzZXMgdGhlIGtleS5cbiAgICAgKiBOb3RlOiAna2V5cHJlc3MnIGV2ZW50cyBhcmUgbm90IHNlbnQgZm9yIGRlbGV0ZSBrZXlzIGxpa2UgQmFja3NwYWNlL0RlbGV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbktleXByZXNzKGhvbGRlciwgZSkge1xuICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgcmVhbCBjaGFyYWN0ZXIgdGhhdCBoYXMgYmVlbiBlbnRlcmVkIChpZS4gJ2EnIGluc3RlYWQgb2YgdGhlIGtleSBjb2RlKVxuICAgICAgICBjb25zdCBldmVudENoYXJhY3RlciA9IGNoYXJhY3RlcihlKTtcblxuICAgICAgICAvLyBGaXJlZm94IGdlbmVyYXRlIGEgJ2tleXByZXNzJyBldmVudCAoZS5rZXlDb2RlID09PSAwKSBmb3IgdGhlIGtleXMgdGhhdCBkbyBub3QgcHJpbnQgYSBjaGFyYWN0ZXIgKGllLiAnSW5zZXJ0JywgJ0RlbGV0ZScsICdGbicga2V5cywgJ1BhZ2VVcCcsICdQYWdlRG93bicgZXRjLikuICdTaGlmdCcgb24gdGhlIG90aGVyIGhhbmQgZG9lcyBub3QgZ2VuZXJhdGUgYSBrZXlwcmVzcyBldmVudC5cbiAgICAgICAgaWYgKGV2ZW50Q2hhcmFjdGVyID09PSBrZXlOYW1lLkluc2VydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gaG9sZGVyLnByb2Nlc3NlZDtcbiAgICAgICAgaG9sZGVyLl91cGRhdGVBdXRvTnVtZXJpY0hvbGRlclByb3BlcnRpZXMoZSk7XG5cbiAgICAgICAgaWYgKGhvbGRlci5fc2tpcEFsd2F5cyhlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHByb2Nlc3NlZCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQgPSBob2xkZXIuX3Byb2Nlc3NDaGFyYWN0ZXJJbnNlcnRpb24oZSk7XG4gICAgICAgIGlmIChpc0NoYXJhY3Rlckluc2VydGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgIGhvbGRlci5fZm9ybWF0VmFsdWUoZSk7XG4gICAgICAgICAgICBpZiAoKGUudGFyZ2V0LnZhbHVlICE9PSBob2xkZXIubGFzdFZhbCkgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUudGhyb3dJbnB1dCkge1xuICAgICAgICAgICAgICAgIC8vIFRocm93cyBpbnB1dCBldmVudCBvbiBhZGRpbmcgYSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2lucHV0JywgZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gLi4uYW5kIGltbWVkaWF0ZWx5IHByZXZlbnQgdGhlIGJyb3dzZXIgdG8gYWRkIGEgc2Vjb25kIGNoYXJhY3RlclxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKChldmVudENoYXJhY3RlciA9PT0gaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgfHwgZXZlbnRDaGFyYWN0ZXIgPT09IGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpICYmXG4gICAgICAgICAgICAgICAgICAgIChnZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0KS5zdGFydCA9PT0gZ2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCkuZW5kKSAmJlxuICAgICAgICAgICAgICAgICAgICBnZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0KS5zdGFydCA9PT0gZS50YXJnZXQudmFsdWUuaW5kZXhPZihob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0KS5zdGFydCArIDE7XG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIHBvc2l0aW9uLCBwb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaG9sZGVyLmxhc3RWYWwgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgICAgIGhvbGRlci5zZXR0aW5nc0Nsb25lLnRocm93SW5wdXQgPSB0cnVlO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgaG9sZGVyLmZvcm1hdHRlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdrZXl1cCcgZXZlbnRzLlxuICAgICAqIFRoZSB1c2VyIGp1c3QgcmVsZWFzZWQgYW55IGtleSwgaGVuY2Ugb25lIGV2ZW50IGlzIHNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25LZXl1cChob2xkZXIsIHNldHRpbmdzLCBlKSB7XG4gICAgICAgIGhvbGRlci5fdXBkYXRlQXV0b051bWVyaWNIb2xkZXJQcm9wZXJ0aWVzKGUpO1xuXG4gICAgICAgIGNvbnN0IHNraXAgPSBob2xkZXIuX3NraXBBbHdheXMoZSk7XG4gICAgICAgIGRlbGV0ZSBob2xkZXIudmFsdWVQYXJ0c0JlZm9yZVBhc3RlO1xuICAgICAgICBpZiAoc2tpcCB8fCBlLnRhcmdldC52YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFkZGVkIHRvIHByb3Blcmx5IHBsYWNlIHRoZSBjYXJldCB3aGVuIG9ubHkgdGhlIGN1cnJlbmN5IHNpZ24gaXMgcHJlc2VudFxuICAgICAgICBpZiAoZS50YXJnZXQudmFsdWUgPT09IGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sKSB7XG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzQ2xvbmUuY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQgPT09ICdzJykge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIDApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbC5sZW5ndGgsIGhvbGRlci5zZXR0aW5nc0Nsb25lLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaG9sZGVyLmV2ZW50S2V5Q29kZSA9PT0ga2V5Q29kZS5UYWIpIHtcbiAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIDAsIGUudGFyZ2V0LnZhbHVlLmxlbmd0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKGUudGFyZ2V0LnZhbHVlID09PSBob2xkZXIuc2V0dGluZ3NDbG9uZS5zdWZmaXhUZXh0KSB8fFxuICAgICAgICAgICAgKGhvbGRlci5zZXR0aW5nc0Nsb25lLnJhd1ZhbHVlID09PSAnJyAmJiBob2xkZXIuc2V0dGluZ3NDbG9uZS5jdXJyZW5jeVN5bWJvbCAhPT0gJycgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuc3VmZml4VGV4dCAhPT0gJycpKSB7XG4gICAgICAgICAgICBzZXRFbGVtZW50U2VsZWN0aW9uKGUudGFyZ2V0LCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNhdmVzIHRoZSBleHRlbmRlZCBkZWNpbWFsIHRvIHByZXNlcnZlIHRoZSBkYXRhIHdoZW4gbmF2aWdhdGluZyBhd2F5IGZyb20gdGhlIHBhZ2VcbiAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5nc0Nsb25lLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwgJiYgaG9sZGVyLnNldHRpbmdzQ2xvbmUuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkge1xuICAgICAgICAgICAgc2F2ZVZhbHVlVG9QZXJzaXN0ZW50U3RvcmFnZShlLnRhcmdldCwgc2V0dGluZ3MsICdzZXQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaG9sZGVyLmZvcm1hdHRlZCkge1xuICAgICAgICAgICAgaG9sZGVyLl9mb3JtYXRWYWx1ZShlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSBpbnB1dCB2YWx1ZSBoYXMgY2hhbmdlZCBkdXJpbmcgdGhlIGtleSBwcmVzcyBldmVudCBjaGFpbiwgYW4gZXZlbnQgaXMgc2VudCB0byBhbGVydCB0aGF0IGEgZm9ybWF0dGluZyBoYXMgYmVlbiBkb25lIChjZi4gSXNzdWUgIzE4NylcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlICE9PSBob2xkZXIuaW5pdGlhbFZhbHVlT25LZXlkb3duKSB7XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2F1dG9OdW1lcmljOmZvcm1hdHRlZCcsIGUudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXIgZm9yICdmb2N1c291dCcgZXZlbnRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtBdXRvTnVtZXJpY0hvbGRlcn0gaG9sZGVyXG4gICAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uRm9jdXNPdXRBbmRNb3VzZUxlYXZlKCR0aGlzLCBob2xkZXIsIGUpIHtcbiAgICAgICAgaWYgKCEkdGhpcy5pcygnOmZvY3VzJykpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qgb3JpZ1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuICAgICAgICAgICAgc2V0dGluZ3MuaGFzRm9jdXMgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKGUudGFyZ2V0LCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mubm9TZXBhcmF0b3JPbkZvY3VzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuZGlnaXRHcm91cFNlcGFyYXRvciA9IHNldHRpbmdzLm9TZXA7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wgPSBzZXR0aW5ncy5vU2lnbjtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5zdWZmaXhUZXh0ID0gc2V0dGluZ3Mub1N1ZmZpeDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5vRGVjO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLmFsbG93RGVjaW1hbFBhZGRpbmcgPSBzZXR0aW5ncy5vUGFkO1xuICAgICAgICAgICAgICAgIHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyID0gc2V0dGluZ3Mub0JyYWNrZXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbHVlID0gc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzKHZhbHVlLCBzZXR0aW5ncywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSAmJiAhaXNOZWdhdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MudHJhaWxpbmdOZWdhdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrRW1wdHkodmFsdWUsIHNldHRpbmdzLCBmYWxzZSkgPT09IG51bGwgJiYgbWluVGVzdCAmJiBtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gY2xlYW5MZWFkaW5nVHJhaWxpbmdaZXJvcyh2YWx1ZSwgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgLyBzZXR0aW5ncy5zY2FsZURpdmlzb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSAoc2V0dGluZ3Muc2NhbGVEaXZpc29yICYmIHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykgPyArc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzIDogc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHJvdW5kVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb2RpZnlOZWdhdGl2ZVNpZ25BbmREZWNpbWFsQ2hhcmFjdGVyRm9yRm9ybWF0dGVkVmFsdWUodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLnRyaWdnZXIoJ2F1dG9OdW1lcmljOm1pbkV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXhUZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBzZXR0aW5ncy5yYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5lbXB0eUlucHV0QmVoYXZpb3IgPT09ICd6ZXJvJykge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcwJztcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKCcwJywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLnJhd1ZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsZXQgZ3JvdXBlZFZhbHVlID0gY2hlY2tFbXB0eSh2YWx1ZSwgc2V0dGluZ3MsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChncm91cGVkVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBncm91cGVkVmFsdWUgPSBhZGRHcm91cFNlcGFyYXRvcnModmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdyb3VwZWRWYWx1ZSAhPT0gb3JpZ1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZ3JvdXBlZFZhbHVlID0gKHNldHRpbmdzLnNjYWxlU3ltYm9sKSA/IGdyb3VwZWRWYWx1ZSArIHNldHRpbmdzLnNjYWxlU3ltYm9sIDogZ3JvdXBlZFZhbHVlO1xuICAgICAgICAgICAgICAgICR0aGlzLnZhbChncm91cGVkVmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZ3JvdXBlZFZhbHVlICE9PSBob2xkZXIudmFsdWVPbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgJHRoaXMuY2hhbmdlKCk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGhvbGRlci52YWx1ZU9uRm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAncGFzdGUnIGV2ZW50c1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblBhc3RlKCR0aGlzLCBob2xkZXIsIGUpIHtcbiAgICAgICAgLy9UT0RPIFVzaW5nIGN0cmwreiBhZnRlciBhIHBhc3RlIHNob3VsZCBjYW5jZWwgaXQgLT4gSG93IHdvdWxkIHRoYXQgYWZmZWN0IG90aGVyIGZyYW1ld29ya3MvY29tcG9uZW50IGJ1aWx0IHdpdGggdGhhdCBmZWF0dXJlIGluIG1pbmQgdGhvdWdoP1xuICAgICAgICAvL0ZJWE1FIFdoZW4gcGFzdGluZyAnMDAwJyBvbiBhIHRob3VzYW5kIGdyb3VwIHNlbGVjdGlvbiwgdGhlIHdob2xlIHNlbGVjdGlvbiBnZXRzIGRlbGV0ZWQsIGFuZCBvbmx5IG9uZSAnMCcgaXMgcGFzdGVkIChjZi4gaXNzdWUgIzMwMilcbiAgICAgICAgLy8gVGhlIGV2ZW50IGlzIHByZXZlbnRlZCBieSBkZWZhdWx0LCBzaW5jZSBvdGhlcndpc2UgdGhlIHVzZXIgd291bGQgYmUgYWJsZSB0byBwYXN0ZSBpbnZhbGlkIGNoYXJhY3RlcnMgaW50byB0aGUgaW5wdXRcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGxldCByYXdQYXN0ZWRUZXh0ID0gZS5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKTtcblxuICAgICAgICAvLyAwLiBTcGVjaWFsIGNhc2UgaWYgdGhlIHVzZXIgaGFzIHNlbGVjdGVkIGFsbCB0aGUgaW5wdXQgdGV4dCBiZWZvcmUgcGFzdGluZ1xuICAgICAgICBjb25zdCBpbml0aWFsRm9ybWF0dGVkVmFsdWUgPSBlLnRhcmdldC52YWx1ZTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU3RhcnQgPSBlLnRhcmdldC5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25FbmQgPSBlLnRhcmdldC5zZWxlY3Rpb25FbmQgfHwgMDtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uU2l6ZSA9IHNlbGVjdGlvbkVuZCAtIHNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBsZXQgaXNBbGxJbnB1dFRleHRTZWxlY3RlZCA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb25TaXplID09PSBpbml0aWFsRm9ybWF0dGVkVmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpc0FsbElucHV0VGV4dFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDEuIENoZWNrIGlmIHRoZSBwYXN0ZSBoYXMgYSBuZWdhdGl2ZSBzaWduIChvbmx5IGlmIGl0J3MgdGhlIGZpcnN0IGNoYXJhY3RlciksIGFuZCBzdG9yZSB0aGF0IGluZm9ybWF0aW9uIGZvciBsYXRlciB1c2VcbiAgICAgICAgY29uc3QgaXNQYXN0ZU5lZ2F0aXZlID0gaXNOZWdhdGl2ZVN0cmljdChyYXdQYXN0ZWRUZXh0KTtcbiAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgLy8gMWEuIFJlbW92ZSB0aGUgbmVnYXRpdmUgc2lnbiBmcm9tIHRoZSBwYXN0ZWQgdGV4dFxuICAgICAgICAgICAgcmF3UGFzdGVkVGV4dCA9IHJhd1Bhc3RlZFRleHQuc2xpY2UoMSwgcmF3UGFzdGVkVGV4dC5sZW5ndGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gMi4gU3RyaXAgYWxsIHRob3VzYW5kIHNlcGFyYXRvcnMsIGJyYWNrZXRzIGFuZCBjdXJyZW5jeSBzaWduLCBhbmQgY29udmVydCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgdG8gYSBkb3RcbiAgICAgICAgY29uc3QgdW50cmFuc2xhdGVkUGFzdGVkVGV4dCA9IHByZXBhcmVQYXN0ZWRUZXh0KHJhd1Bhc3RlZFRleHQsIGhvbGRlcik7XG5cbiAgICAgICAgbGV0IHBhc3RlZFRleHQ7XG4gICAgICAgIGlmICh1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0ID09PSAnLicpIHtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZSA6IElmIHRoZSB1c2VyIHRyaWVzIHRvIHBhc3RlIGEgc2luZ2xlIGRlY2ltYWwgY2hhcmFjdGVyICh0aGF0IGhhcyBiZWVuIHRyYW5zbGF0ZWQgdG8gJy4nIGFscmVhZHkpXG4gICAgICAgICAgICBwYXN0ZWRUZXh0ID0gJy4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTm9ybWFsIGNhc2VcbiAgICAgICAgICAgIC8vIEFsbG93IHBhc3RpbmcgYXJhYmljIG51bWJlcnNcbiAgICAgICAgICAgIHBhc3RlZFRleHQgPSBhcmFiaWNUb0xhdGluTnVtYmVycyh1bnRyYW5zbGF0ZWRQYXN0ZWRUZXh0LCBmYWxzZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDMuIFRlc3QgaWYgdGhlIHBhc3RlIGlzIHZhbGlkIChvbmx5IGhhcyBudW1iZXJzIGFuZCBldmVudHVhbGx5IGEgZGVjaW1hbCBjaGFyYWN0ZXIpLiBJZiBpdCdzIG5vdCB2YWxpZCwgc3RvcCBoZXJlLlxuICAgICAgICBpZiAocGFzdGVkVGV4dCAhPT0gJy4nICYmICghaXNOdW1iZXIocGFzdGVkVGV4dCkgfHwgcGFzdGVkVGV4dCA9PT0gJycpKSB7XG4gICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICAgICAgLy9UT0RPIFNob3VsZCB3ZSBzZW5kIGEgd2FybmluZyBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yP1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIGlzIG5vdCBhIHZhbGlkIHBhc3RlIGNvbnRlbnQuYCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDQuIENhbGN1bGF0ZSB0aGUgcGFzdGUgcmVzdWx0XG4gICAgICAgIGxldCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZztcbiAgICAgICAgbGV0IGluaXRpYWxVbmZvcm1hdHRlZE51bWJlcjtcbiAgICAgICAgaWYgKGUudGFyZ2V0LnZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgLy8gYXV0b051bWVyaWMgJ2dldCcgcmV0dXJucyAnMC4wMCcgaWYgdGhlIGlucHV0IGlzIGVtcHR5LCBoZW5jZSB3ZSBuZWVkIHRvIHN0b3JlIHRoZSAncmVhbCcgZW1wdHkgaW5pdGlhbCB2YWx1ZSB3aGVuIG5lZWRlZFxuICAgICAgICAgICAgLy9GSVhNRSBUaGlzIGhhcyBiZWVuIGZpeGVkIGluIGEgcHJldmlvdXMgY29tbWl0LCBnZXQgc2hvdWxkIHJldHVybiAnJyBvbiBhbiBlbXB0eSBpbnB1dC4gUmVtb3ZlIHRoaXMgdW5uZWVkZWQgJ2lmJ1xuICAgICAgICAgICAgaW5pdGlhbFVuZm9ybWF0dGVkTnVtYmVyID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXIgPSAkdGhpcy5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUgPSBpc05lZ2F0aXZlU3RyaWN0KGluaXRpYWxVbmZvcm1hdHRlZE51bWJlcik7XG4gICAgICAgIGxldCBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlO1xuICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgIC8vIElmIHRoZSBwYXN0ZWQgY29udGVudCBpcyBuZWdhdGl2ZSwgdGhlbiB0aGUgcmVzdWx0IHdpbGwgYmUgbmVnYXRpdmUgdG9vXG4gICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmUgJiYgIWlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgIGluaXRpYWxVbmZvcm1hdHRlZE51bWJlciA9IGAtJHtpbml0aWFsVW5mb3JtYXR0ZWROdW1iZXJ9YDtcbiAgICAgICAgICAgIGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUgPSB0cnVlO1xuICAgICAgICAgICAgaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgbGVmdFBhcnRDb250YWluZWRBRG90ID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAvKiA0YS4gVHJ1bmNhdGUgcGFzdGUgYmVoYXZpb3I6XG4gICAgICAgICAgICAgKiBJbnNlcnQgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIG9uIHRoZSByaWdodCBoYW5kIHNpZGUgb2YgdGhlIGNhcmV0IGZyb20gdGhlIHBhc3RlZCB0ZXh0IGNvbnRlbnQsIHVudGlsIHRoZSBpbnB1dCByZWFjaCBpdHMgcmFuZ2UgbGltaXQuXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSBpcyBtb3JlIGNoYXJhY3RlcnMgaW4gdGhlIGNsaXBib2FyZCBvbmNlIGEgbGltaXQgaXMgcmVhY2hlZCwgZHJvcCB0aGUgZXh0cmFuZW91cyBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICogT3RoZXJ3aXNlIHBhc3RlIGFsbCB0aGUgbnVtYmVycyBpbiB0aGUgY2xpcGJvYXJkLlxuICAgICAgICAgICAgICogV2hpbGUgZG9pbmcgc28sIHdlIGNoZWNrIGlmIHRoZSByZXN1bHQgaXMgd2l0aGluIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcyBhbGxvd2VkLCBhbmQgc3RvcCBhcyBzb29uIGFzIHdlIGVuY291bnRlciBvbmUgb2YgdGhvc2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogNGIuIFJlcGxhY2UgcGFzdGUgYmVoYXZpb3I6XG4gICAgICAgICAgICAgKiBJZGVtIHRoYW4gdGhlICd0cnVuY2F0ZScgcGFzdGUgYmVoYXZpb3IsIGV4Y2VwdCB0aGF0IHdoZW4gYSByYW5nZSBsaW1pdCBpcyBoaXQsIHdlIHRyeSB0byByZXBsYWNlIHRoZSBzdWJzZXF1ZW50IGluaXRpYWwgbnVtYmVycyB3aXRoIHRoZSBwYXN0ZWQgb25lcywgdW50aWwgd2UgaGl0IHRoZSByYW5nZSBsaW1pdCBhIHNlY29uZCAoYW5kIGxhc3QpIHRpbWUsIG9yIHdlIHJ1biBvdXQgb2YgbnVtYmVycyB0byBwYXN0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvKiBlc2xpbnQgbm8tY2FzZS1kZWNsYXJhdGlvbnM6IDAgKi9cbiAgICAgICAgICAgIGNhc2UgJ3RydW5jYXRlJzpcbiAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRGb3JtYXR0ZWRQYXJ0ID0gaW5pdGlhbEZvcm1hdHRlZFZhbHVlLnNsaWNlKDAsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByaWdodEZvcm1hdHRlZFBhcnQgPSBpbml0aWFsRm9ybWF0dGVkVmFsdWUuc2xpY2Uoc2VsZWN0aW9uRW5kLCBpbml0aWFsRm9ybWF0dGVkVmFsdWUubGVuZ3RoKTtcblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGEuIElmIHRoZXJlIGlzIGEgc2VsZWN0aW9uLCByZW1vdmUgdGhlIHNlbGVjdGVkIHBhcnQsIGFuZCByZXR1cm4gdGhlIGxlZnQgYW5kIHJpZ2h0IHBhcnRcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcHJlcGFyZVBhc3RlZFRleHQobGVmdEZvcm1hdHRlZFBhcnQgKyByaWdodEZvcm1hdHRlZFBhcnQsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYi4gRWxzZSBpZiB0aGlzIGlzIG9ubHkgb25lIGNhcmV0IChhbmQgdGhlcmVmb3JlIG5vIHNlbGVjdGlvbiksIHRoZW4gcmV0dXJuIHRoZSBsZWZ0IGFuZCByaWdodCBwYXJ0XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHByZXBhcmVQYXN0ZWRUZXh0KGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgaG9sZGVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFjayB0aGUgbmVnYXRpdmUgc2lnbiBpZiBuZWVkZWRcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsVmFsdWVOZWdhdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBzZXRSYXdOZWdhdGl2ZVNpZ24ocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBCdWlsZCB0aGUgdW5mb3JtYXR0ZWQgcmVzdWx0IHN0cmluZ1xuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xuICAgICAgICAgICAgICAgIGlmIChpc1Bhc3RlTmVnYXRpdmVBbmRJbml0aWFsVmFsdWVJc1Bvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbml0aWFsIHBhc3RlIGlzIG5lZ2F0aXZlIGFuZCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyBub3QsIHRoZW4gSSBtdXN0IG9mZnNldCB0aGUgY2FyZXQgcG9zaXRpb24gYnkgb25lIHBsYWNlIHRvIHRoZSByaWdodCB0byB0YWtlIHRoZSBhZGRpdGlvbmFsIGh5cGhlbiBpbnRvIGFjY291bnRcbiAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcrKztcbiAgICAgICAgICAgICAgICAgICAgLy9UT0RPIFF1aWQgaWYgdGhlIG5lZ2F0aXZlIHNpZ24gaXMgbm90IG9uIHRoZSBsZWZ0IChuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBhbmQgY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQpP1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGxldCBsZWZ0UGFydCA9IHJlc3VsdC5zbGljZSgwLCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyk7XG4gICAgICAgICAgICAgICAgbGV0IHJpZ2h0UGFydCA9IHJlc3VsdC5zbGljZShjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZywgcmVzdWx0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhc3RlZFRleHQgPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdFBhcnQsICcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIEkgcmVtb3ZlIGEgZG90IGhlcmUsIHRoZW4gSSBuZWVkIHRvIHVwZGF0ZSB0aGUgY2FyZXQgcG9zaXRpb24gKGRlY3JlbWVudCBpdCBieSAxKSB3aGVuIHBvc2l0aW9uaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUbyBkbyBzbywgd2Uga2VlcCB0aGF0IGluZm8gaW4gb3JkZXIgdG8gbW9kaWZ5IHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnRDb250YWluZWRBRG90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gbGVmdFBhcnQucmVwbGFjZSgnLicsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByaWdodFBhcnQgPSByaWdodFBhcnQucmVwbGFjZSgnLicsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gLS0gSGVyZSwgd2UgYXJlIGdvb2QgdG8gZ28gdG8gY29udGludWUgb24gdGhlIHNhbWUgYmFzaXNcblxuICAgICAgICAgICAgICAgIC8vIGMuIEFkZCBudW1iZXJzIG9uZSBieSBvbmUgYXQgdGhlIGNhcmV0IHBvc2l0aW9uLCB3aGlsZSB0ZXN0aW5nIGlmIHRoZSByZXN1bHQgaXMgdmFsaWQgYW5kIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWVcbiAgICAgICAgICAgICAgICAvLyAgICBDb250aW51ZSB1bnRpbCB5b3UgZWl0aGVyIHJ1biBvdXQgb2YgbnVtYmVycyB0byBwYXN0ZSwgb3IgdGhhdCB5b3UgZ2V0IG91dCBvZiB0aGUgcmFuZ2UgbGltaXRzXG4gICAgICAgICAgICAgICAgY29uc3QgbWluUGFyc2UgPSBwYXJzZVN0cihob2xkZXIuc2V0dGluZ3MubWluaW11bVZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhQYXJzZSA9IHBhcnNlU3RyKGhvbGRlci5zZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICAgICAgICAgIGxldCBsYXN0R29vZEtub3duUmVzdWx0ID0gcmVzdWx0OyAvLyBUaGlzIGlzIHNldCBhcyB0aGUgZGVmYXVsdCwgaW4gY2FzZSB3ZSBkbyBub3QgYWRkIGV2ZW4gb25lIG51bWJlclxuICAgICAgICAgICAgICAgIGxldCBwYXN0ZWRUZXh0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGxldCBtb2RpZmllZExlZnRQYXJ0ID0gbGVmdFBhcnQ7XG5cbiAgICAgICAgICAgICAgICB3aGlsZSAocGFzdGVkVGV4dEluZGV4IDwgcGFzdGVkVGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW9kaWZ5IHRoZSByZXN1bHQgd2l0aCBhbm90aGVyIHBhc3RlZCBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgbW9kaWZpZWRMZWZ0UGFydCArPSBwYXN0ZWRUZXh0W3Bhc3RlZFRleHRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1vZGlmaWVkTGVmdFBhcnQgKyByaWdodFBhcnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJhbmdlIGxpbWl0c1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNoZWNrSWZJblJhbmdlKHJlc3VsdCwgbWluUGFyc2UsIG1heFBhcnNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cywgc3RvcCB0aGUgbG9vcCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgdGhlIGxhc3QgZ29vZCBrbm93biByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgbGFzdEdvb2RLbm93blJlc3VsdCA9IHJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxvY2FsIHZhcmlhYmxlcyBmb3IgdGhlIG5leHQgbG9vcFxuICAgICAgICAgICAgICAgICAgICBwYXN0ZWRUZXh0SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGxhc3QgY2FyZXQgcG9zaXRpb24gd2hlcmUgdG8gaW5zZXJ0IGEgbmV3IG51bWJlclxuICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nICs9IHBhc3RlZFRleHRJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vWFhYIEhlcmUgd2UgaGF2ZSB0aGUgcmVzdWx0IGZvciB0aGUgYHRydW5jYXRlYCBvcHRpb25cbiAgICAgICAgICAgICAgICBpZiAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlID09PSAndHJ1bmNhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBJZiB0aGUgdXNlciBhcyBkZWZpbmVkIGEgdHJ1bmNhdGUgY2FsbGJhY2sgYW5kIHRoZXJlIGFyZSBzdGlsbCBzb21lIG51bWJlcnMgKHRoYXQgd2lsbCBiZSBkcm9wcGVkKSwgdGhlbiBjYWxsIHRoaXMgY2FsbGJhY2sgd2l0aCB0aGUgaW5pdGlhbCBwYXN0ZSBhcyB3ZWxsIGFzIHRoZSByZW1haW5pbmcgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBsYXN0R29vZEtub3duUmVzdWx0O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChsZWZ0UGFydENvbnRhaW5lZEFEb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgZG90IGhhcyBiZWVuIHJlbW92ZWQgZm9yIHRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCwgd2UgZGVjcmVtZW50IHRoZSBjYXJldCBpbmRleCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmctLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9YWFggLi4uZWxzZSB3ZSBuZWVkIHRvIGNvbnRpbnVlIG1vZGlmeWluZyB0aGUgcmVzdWx0IGZvciB0aGUgJ3JlcGxhY2UnIG9wdGlvblxuXG4gICAgICAgICAgICAgICAgLy8gZC4gVW50aWwgdGhlcmUgYXJlIG51bWJlcnMgdG8gcGFzdGUsIHJlcGxhY2UgdGhlIGluaXRpYWwgbnVtYmVycyBvbmUgYnkgb25lLCBhbmQgc3RpbGwgZG8gdGhlIHJhbmdlIHRlc3QuXG4gICAgICAgICAgICAgICAgLy8gICAgU3RvcCB3aGVuIHlvdSBoYXZlIG5vIG1vcmUgbnVtYmVycyB0byBwYXN0ZSwgb3IgaWYgeW91IGFyZSBvdXQgb2YgdGhlIHJhbmdlIGxpbWl0cy5cbiAgICAgICAgICAgICAgICAvLyAgICBJZiB5b3UgZG8gZ2V0IHRvIHRoZSByYW5nZSBsaW1pdHMsIHVzZSB0aGUgcHJldmlvdXMga25vd24gZ29vZCB2YWx1ZSB3aXRoaW4gdGhvc2UgbGltaXRzLlxuICAgICAgICAgICAgICAgIC8vICAgIE5vdGU6IFRoZSBudW1iZXJzIGFyZSByZXBsYWNlZCBvbmUgYnkgb25lLCBpbiB0aGUgaW50ZWdlciB0aGVuIGRlY2ltYWwgcGFydCwgd2hpbGUgaWdub3JpbmcgdGhlIGRlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgLy9UT0RPIFdoYXQgc2hvdWxkIGhhcHBlbiBpZiB0aGUgdXNlciB0cnkgdG8gcGFzdGUgYSBkZWNpbWFsIG51bWJlcj8gU2hvdWxkIHdlIG92ZXJyaWRlIHRoZSBjdXJyZW50IGluaXRpYWwgZGVjaW1hbCBjaGFyYWN0ZXIgaW4gZmF2b3Igb2YgdGhpcyBuZXcgb25lPyBJZiB3ZSBkbywgdGhlbiB3ZSBoYXZlIHRvIHJlY2FsY3VsYXRlIHRoZSB2TWluL3ZNYXggZnJvbSB0aGUgc3RhcnQgaW4gb3JkZXIgdG8gdGFrZSBpbnRvIGFjY291bnQgdGhpcyBuZXcgZGVjaW1hbCBjaGFyYWN0ZXIgcG9zaXRpb24uLlxuICAgICAgICAgICAgICAgIGxldCBsYXN0R29vZEtub3duUmVzdWx0SW5kZXggPSBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZztcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0R29vZEtub3duUmVzdWx0U2l6ZSA9IGxhc3RHb29kS25vd25SZXN1bHQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhc3RlZFRleHRJbmRleCA8IHBhc3RlZFRleHQubGVuZ3RoICYmIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCA8IGxhc3RHb29kS25vd25SZXN1bHRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0R29vZEtub3duUmVzdWx0W2xhc3RHb29kS25vd25SZXN1bHRJbmRleF0gPT09ICcuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2Ugc2tpcCB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgJ3JlcGxhY2VtZW50Jy4gVGhhdCB3YXksIHdlIGRvIG5vdCBjaGFuZ2UgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIHBvc2l0aW9uIHJlZ2FyZGluZyB0aGUgcmVtYWluaW5nIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R29vZEtub3duUmVzdWx0SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyByZXBsYWNlIG9uZSBjaGFyYWN0ZXIgYXQgYSB0aW1lXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlcGxhY2VDaGFyQXQobGFzdEdvb2RLbm93blJlc3VsdCwgbGFzdEdvb2RLbm93blJlc3VsdEluZGV4LCBwYXN0ZWRUZXh0W3Bhc3RlZFRleHRJbmRleF0pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByYW5nZSBsaW1pdHNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja0lmSW5SYW5nZShyZXN1bHQsIG1pblBhcnNlLCBtYXhQYXJzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSByYW5nZSBsaW1pdHMsIHN0b3AgdGhlIGxvb3AgaGVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBTYXZlIHRoZSBsYXN0IGdvb2Qga25vd24gcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHQgPSByZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBsb2NhbCB2YXJpYWJsZXMgZm9yIHRoZSBuZXh0IGxvb3BcbiAgICAgICAgICAgICAgICAgICAgcGFzdGVkVGV4dEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RHb29kS25vd25SZXN1bHRJbmRleCsrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdCBjYXJldCBwb3NpdGlvbiB3aGVyZSB0byBpbnNlcnQgYSBuZXcgbnVtYmVyXG4gICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBsYXN0R29vZEtub3duUmVzdWx0SW5kZXg7XG5cbiAgICAgICAgICAgICAgICBpZiAobGVmdFBhcnRDb250YWluZWRBRG90KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgZG90IGhhcyBiZWVuIHJlbW92ZWQgZm9yIHRoZSBwYXJ0IG9uIHRoZSBsZWZ0IG9mIHRoZSBjYXJldCwgd2UgZGVjcmVtZW50IHRoZSBjYXJldCBpbmRleCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZy0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGxhc3RHb29kS25vd25SZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8qIDRjLiBOb3JtYWwgcGFzdGUgYmVoYXZpb3I6XG4gICAgICAgICAgICAgKiBJbnNlcnQgdGhlIHBhc3RlZCBudW1iZXIgaW5zaWRlIHRoZSBjdXJyZW50IHVuZm9ybWF0dGVkIHRleHQsIGF0IHRoZSByaWdodCBjYXJldCBwb3NpdGlvbiBvciBzZWxlY3Rpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgIGNhc2UgJ2NsYW1wJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gMS4gR2VuZXJhdGUgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdFxuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRGb3JtYXR0ZWRQYXJ0MiA9IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5zbGljZSgwLCBzZWxlY3Rpb25TdGFydCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRGb3JtYXR0ZWRQYXJ0MiA9IGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5zbGljZShzZWxlY3Rpb25FbmQsIGluaXRpYWxGb3JtYXR0ZWRWYWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ICE9PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYS4gSWYgdGhlcmUgaXMgYSBzZWxlY3Rpb24sIHJlbW92ZSB0aGUgc2VsZWN0ZWQgcGFydCwgYW5kIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlUGFzdGVkVGV4dChsZWZ0Rm9ybWF0dGVkUGFydDIgKyByaWdodEZvcm1hdHRlZFBhcnQyLCBob2xkZXIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGIuIEVsc2UgaWYgdGhpcyBpcyBvbmx5IG9uZSBjYXJldCAoYW5kIHRoZXJlZm9yZSBubyBzZWxlY3Rpb24pLCB0aGVuIHJldHVybiB0aGUgbGVmdCBhbmQgcmlnaHQgcGFydFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBwcmVwYXJlUGFzdGVkVGV4dChpbml0aWFsRm9ybWF0dGVkVmFsdWUsIGhvbGRlcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQWRkIGJhY2sgdGhlIG5lZ2F0aXZlIHNpZ24gaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFZhbHVlTmVnYXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gc2V0UmF3TmVnYXRpdmVTaWduKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgdGhlIHVuZm9ybWF0dGVkIHJlc3VsdCBzdHJpbmdcbiAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGNvbnZlcnRDaGFyYWN0ZXJDb3VudFRvSW5kZXhQb3NpdGlvbihjb3VudE51bWJlckNoYXJhY3RlcnNPblRoZUNhcmV0TGVmdFNpZGUoaW5pdGlhbEZvcm1hdHRlZFZhbHVlLCBzZWxlY3Rpb25TdGFydCwgaG9sZGVyLnNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIpKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQYXN0ZU5lZ2F0aXZlQW5kSW5pdGlhbFZhbHVlSXNQb3NpdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgaW5pdGlhbCBwYXN0ZSBpcyBuZWdhdGl2ZSBhbmQgdGhlIGluaXRpYWwgdmFsdWUgaXMgbm90LCB0aGVuIEkgbXVzdCBvZmZzZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGJ5IG9uZSBwbGFjZSB0byB0aGUgcmlnaHQgdG8gdGFrZSB0aGUgYWRkaXRpb25hbCBoeXBoZW4gaW50byBhY2NvdW50XG4gICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKys7XG4gICAgICAgICAgICAgICAgICAgIC8vVE9ETyBRdWlkIGlmIHRoZSBuZWdhdGl2ZSBzaWduIGlzIG5vdCBvbiB0aGUgbGVmdCAobmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgYW5kIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50KT9cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZWZ0UGFydCA9IHJlc3VsdC5zbGljZSgwLCBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyk7XG4gICAgICAgICAgICAgICAgcmlnaHRQYXJ0ID0gcmVzdWx0LnNsaWNlKGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLCByZXN1bHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAocGFzdGVkVGV4dCA9PT0gJy4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIG9ubHkgcGFzdGUgYSBzaW5nbGUgZGVjaW1hbCBjaGFyYWN0ZXIsIHRoZW4gd2UgcmVtb3ZlIHRoZSBwcmV2aW91c2x5IGV4aXN0aW5nIG9uZSAoaWYgYW55KVxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFpbnMobGVmdFBhcnQsICcuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIEkgcmVtb3ZlIGEgZG90IGhlcmUsIHRoZW4gSSBuZWVkIHRvIHVwZGF0ZSB0aGUgY2FyZXQgcG9zaXRpb24gKGRlY3JlbWVudCBpdCBieSAxKSB3aGVuIHBvc2l0aW9uaW5nIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUbyBkbyBzbywgd2Uga2VlcCB0aGF0IGluZm8gaW4gb3JkZXIgdG8gbW9kaWZ5IHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdFBhcnRDb250YWluZWRBRG90ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnRQYXJ0ID0gbGVmdFBhcnQucmVwbGFjZSgnLicsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByaWdodFBhcnQgPSByaWdodFBhcnQucmVwbGFjZSgnLicsICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gLS0gSGVyZSwgd2UgYXJlIGdvb2QgdG8gZ28gdG8gY29udGludWUgb24gdGhlIHNhbWUgYmFzaXNcblxuICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIHRoZSB1bmZvcm1hdHRlZCByZXN1bHRcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBgJHtsZWZ0UGFydH0ke3Bhc3RlZFRleHR9JHtyaWdodFBhcnR9YDtcblxuICAgICAgICAgICAgICAgIC8vIDIuIENhbGN1bGF0ZSB0aGUgY2FyZXQgcG9zaXRpb24gaW4gdGhlIHVuZm9ybWF0dGVkIHZhbHVlLCBmb3IgbGF0ZXIgdXNlXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvblN0YXJ0ID09PSBzZWxlY3Rpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gc2VsZWN0aW9uLCB0aGVuIHRoZSBjYXJldCBwb3NpdGlvbiBpcyBzZXQgYWZ0ZXIgdGhlIHBhc3RlZCB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4V2hlcmVQYXN0ZWRUZXh0SGFzQmVlbkluc2VydGVkID0gY29udmVydENoYXJhY3RlckNvdW50VG9JbmRleFBvc2l0aW9uKGNvdW50TnVtYmVyQ2hhcmFjdGVyc09uVGhlQ2FyZXRMZWZ0U2lkZShpbml0aWFsRm9ybWF0dGVkVmFsdWUsIHNlbGVjdGlvblN0YXJ0LCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uT25Jbml0aWFsVGV4dEFmdGVyUGFzdGluZyA9IGluZGV4V2hlcmVQYXN0ZWRUZXh0SGFzQmVlbkluc2VydGVkICsgcGFzdGVkVGV4dC5sZW5ndGg7IC8vIEkgbXVzdCBub3QgY291bnQgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXN0ZWQgdGV4dCAoaWUuICcuJylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBbGxJbnB1dFRleHRTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHdoZW4gYWxsIHRoZSBpbnB1dCB0ZXh0IGlzIHNlbGVjdGVkIGJlZm9yZSBwYXN0aW5nLCB3aGljaCBtZWFucyB3ZSdsbCBjb21wbGV0ZWx5IGVyYXNlIGl0cyBjb250ZW50IGFuZCBwYXN0ZSBvbmx5IHRoZSBjbGlwYm9hcmQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0UGFydCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIHNlbGVjdGVkIGZyb20gdGhlIGNhcmV0IHBvc2l0aW9uIHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IChvbiB0aGUgZmFyIHJpZ2h0KVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uU3RhcnQsIGhvbGRlci5zZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyKSkgKyBwYXN0ZWRUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbCBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUgPSBjb252ZXJ0Q2hhcmFjdGVyQ291bnRUb0luZGV4UG9zaXRpb24oY291bnROdW1iZXJDaGFyYWN0ZXJzT25UaGVDYXJldExlZnRTaWRlKGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSwgc2VsZWN0aW9uRW5kLCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3RlcikpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBIZXJlIEkgbXVzdCBub3QgY291bnQgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBwYXN0ZWQgdGV4dCAoaWUuICcuJyksIG9yIHRoZSB0aG91c2FuZCBzZXBhcmF0b3JzIGluIHRoZSBpbml0aWFsIHNlbGVjdGVkIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IGUudGFyZ2V0LnZhbHVlLnNsaWNlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcgPSBpbmRleFNlbGVjdGlvbkVuZEluUmF3VmFsdWUgLSBzZWxlY3Rpb25TaXplICsgY291bnRDaGFySW5UZXh0KGhvbGRlci5zZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yLCBzZWxlY3RlZFRleHQpICsgcGFzdGVkVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIGNhcmV0IHBvc2l0aW9uIGZvciBzcGVjaWFsIGNhc2VzLCBvbmx5IGlmIHRoZSB3aG9sZSBpbnB1dCBoYXMgbm90IGJlZW4gc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsSW5wdXRUZXh0U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUGFzdGVOZWdhdGl2ZUFuZEluaXRpYWxWYWx1ZUlzUG9zaXRpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwYXN0ZWQgdmFsdWUgaGFzIGEgJy0nIHNpZ24sIGJ1dCB0aGUgaW5pdGlhbCB2YWx1ZSBkb2VzIG5vdCwgb2Zmc2V0IHRoZSBpbmRleCBieSBvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nKys7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobGVmdFBhcnRDb250YWluZWRBRG90KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIGRvdCBoYXMgYmVlbiByZW1vdmVkIGZvciB0aGUgcGFydCBvbiB0aGUgbGVmdCBvZiB0aGUgY2FyZXQsIHdlIGRlY3JlbWVudCB0aGUgY2FyZXQgaW5kZXggcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmV0UG9zaXRpb25PbkluaXRpYWxUZXh0QWZ0ZXJQYXN0aW5nLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA1LiBDaGVjayBpZiB0aGUgcmVzdWx0IGlzIGEgdmFsaWQgbnVtYmVyLCBpZiBub3QsIGRyb3AgdGhlIHBhc3RlIGFuZCBkbyBub3RoaW5nLlxuICAgICAgICBpZiAoIWlzTnVtYmVyKHJlc3VsdCkgfHwgcmVzdWx0ID09PSAnJykge1xuICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5vbkludmFsaWRQYXN0ZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIHdvdWxkIHJlc3VsdCBpbnRvIGFuIGludmFsaWQgY29udGVudCAnJHtyZXN1bHR9Jy5gKTsgLy9UT0RPIFNob3VsZCB3ZSBzZW5kIGEgd2FybmluZyBpbnN0ZWFkIG9mIHRocm93aW5nIGFuIGVycm9yP1xuICAgICAgICAgICAgICAgIC8vVE9ETyBUaGlzIGlzIG5vdCBEUlkgOyByZWZhY3RvciB3aXRoIGFib3ZlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyA2LiBJZiBpdCdzIGEgdmFsaWQgbnVtYmVyLCBjaGVjayBpZiBpdCBmYWxscyBpbnNpZGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gdmFsdWUuIElmIHRoaXMgZmFpbHMsIG1vZGlmeSB0aGUgdmFsdWUgZm9sbG93aW5nIHRoaXMgcHJvY2VkdXJlIDpcbiAgICAgICAgLypcbiAgICAgICAgICogSWYgJ2Vycm9yJyAodGhpcyBpcyB0aGUgZGVmYXVsdCkgOlxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgdGhlbiB0aHJvdyBhbiBlcnJvciBpbiB0aGUgY29uc29sZS5cbiAgICAgICAgICogICAgICAtIERvIG5vdCBjaGFuZ2UgdGhlIGlucHV0IHZhbHVlLCBkbyBub3QgY2hhbmdlIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAgICAgICAgICogSWYgJ2lnbm9yZScgOlxuICAgICAgICAgKiAgICAgIC0gTm9ybWFsIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCBpZiBpdCBmYWlscywgZG8gbm90aGluZyBtb3JlLlxuICAgICAgICAgKiAgICAgIC0gRG8gbm90IGNoYW5nZSB0aGUgaW5wdXQgdmFsdWUsIGRvIG5vdCBjaGFuZ2UgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICAgICAgICAgKiBJZiAnY2xhbXAnIDpcbiAgICAgICAgICogICAgICAtIE5vcm1hbCBwYXN0ZSBiZWhhdmlvci5cbiAgICAgICAgICogICAgICAtIFRyeSB0byBzZXQgdGhlIG5ldyB2YWx1ZSwgaWYgaXQgZmFpbHMsIHNldCB0aGUgdmFsdWUgdG8gdGhlIG1pbmltdW0gb3IgbWF4aW11bSBsaW1pdCwgd2hpY2hldmVyIGlzIGNsb3Nlc3QgdG8gdGhlXG4gICAgICAgICAqICAgICAgICBwYXN0ZSByZXN1bHQuXG4gICAgICAgICAqICAgICAgLSBDaGFuZ2UgdGhlIGNhcmV0IHBvc2l0aW9uIHRvIGJlIHBvc2l0aW9uZWQgb24gdGhlIGxlZnQgaGFuZCBzaWRlIG9mIHRoZSBkZWNpbWFsIGNoYXJhY3Rlci5cbiAgICAgICAgICogSWYgJ3RydW5jYXRlJyA6XG4gICAgICAgICAqICAgICAgLSBUcnVuY2F0ZSBwYXN0ZSBiZWhhdmlvci5cbiAgICAgICAgICogICAgICAtIFRyeSB0byBzZXQgdGhlIG5ldyB2YWx1ZSwgdW50aWwgaXQgZmFpbHMgKGlmIHRoZSByZXN1bHQgaXMgb3V0IG9mIHRoZSBtaW4gYW5kIG1heCB2YWx1ZSBsaW1pdHMpLlxuICAgICAgICAgKiAgICAgIC0gRHJvcCB0aGUgcmVtYWluaW5nIG5vbi1wYXN0ZWQgbnVtYmVycywgYW5kIGtlZXAgdGhlIGxhc3Qga25vd24gbm9uLWZhaWxpbmcgcmVzdWx0LlxuICAgICAgICAgKiAgICAgIC0gQ2hhbmdlIHRoZSBjYXJldCBwb3NpdGlvbiB0byBiZSBwb3NpdGlvbmVkIGFmdGVyIHRoZSBsYXN0IHBhc3RlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAqIElmICdyZXBsYWNlJyA6XG4gICAgICAgICAqICAgICAgLSBSZXBsYWNlIHBhc3RlIGJlaGF2aW9yLlxuICAgICAgICAgKiAgICAgIC0gVHJ5IHRvIHNldCB0aGUgbmV3IHZhbHVlLCB1bnRpbCBpdCBmYWlscyAoaWYgdGhlIHJlc3VsdCBpcyBvdXQgb2YgdGhlIG1pbiBhbmQgbWF4IHZhbHVlIGxpbWl0cykuXG4gICAgICAgICAqICAgICAtIFRoZW4gdHJ5IHRvIHJlcGxhY2UgYXMgbWFueSBudW1iZXJzIGFzIHBvc3NpYmxlIHdpdGggdGhlIHBhc3RlZCBvbmVzLiBPbmNlIGl0IGZhaWxzLCBrZWVwIHRoZSBsYXN0IGtub3duIG5vbi1mYWlsaW5nIHJlc3VsdC5cbiAgICAgICAgICogICAgICAtIENoYW5nZSB0aGUgY2FyZXQgcG9zaXRpb24gdG8gYmUgcG9zaXRpb25lZCBhZnRlciB0aGUgbGFzdCBwYXN0ZWQgY2hhcmFjdGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHZhbHVlSGFzQmVlblNldCA9IGZhbHNlO1xuICAgICAgICBsZXQgdmFsdWVIYXNCZWVuQ2xhbXBlZCA9IGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHJlc3VsdCk7XG4gICAgICAgICAgICB2YWx1ZUhhc0JlZW5TZXQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbGV0IGNsYW1wZWRWYWx1ZTtcbiAgICAgICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxuICAgICAgICAgICAgICAgICAgICBjbGFtcGVkVmFsdWUgPSBjbGFtcFRvUmFuZ2VMaW1pdHMocmVzdWx0LCBob2xkZXIuc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIGNsYW1wZWRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBGYXRhbCBlcnJvcjogVW5hYmxlIHRvIHNldCB0aGUgY2xhbXBlZCB2YWx1ZSAnJHtjbGFtcGVkVmFsdWV9Jy5gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlSGFzQmVlbkNsYW1wZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0JlZW5TZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBjbGFtcGVkVmFsdWU7IC8vIFRoaXMgaXMgdXNlZCBvbmx5IGZvciBzZXR0aW5nIHRoZSBjYXJldCBwb3NpdGlvbiBsYXRlclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3JlcGxhY2UnOlxuICAgICAgICAgICAgICAgICAgICAvLyBUaHJvdyBhbiBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwYXN0ZWQgdmFsdWUgJyR7cmF3UGFzdGVkVGV4dH0nIHJlc3VsdHMgaW4gYSB2YWx1ZSAnJHtyZXN1bHR9JyB0aGF0IGlzIG91dHNpZGUgb2YgdGhlIG1pbmltdW0gWyR7aG9sZGVyLnNldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtIFske2hvbGRlci5zZXR0aW5ncy5tYXhpbXVtVmFsdWV9XSB2YWx1ZSByYW5nZS5gKTtcbiAgICAgICAgICAgICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgY2FzZSAnaWdub3JlJzpcbiAgICAgICAgICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIC4uLmFuZCBub3RoaW5nIGVsc2Ugc2hvdWxkIGJlIGNoYW5nZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIDcuIFRoZW4gbGFzdGx5LCBzZXQgdGhlIGNhcmV0IHBvc2l0aW9uIGF0IHRoZSByaWdodCBsb2dpY2FsIHBsYWNlXG4gICAgICAgIGxldCBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXI7XG4gICAgICAgIGlmICh2YWx1ZUhhc0JlZW5TZXQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoaG9sZGVyLnNldHRpbmdzLm9uSW52YWxpZFBhc3RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xhbXAnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVIYXNCZWVuQ2xhbXBlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhvbGRlci5zZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgZS50YXJnZXQudmFsdWUubGVuZ3RoIC0gaG9sZGVyLnNldHRpbmdzLmN1cnJlbmN5U3ltYm9sLmxlbmd0aCk7IC8vIFRoaXMgcHV0cyB0aGUgY2FyZXQgb24gdGhlIHJpZ2h0IG9mIHRoZSBsYXN0IGRlY2ltYWwgcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0RWxlbWVudFNlbGVjdGlvbihlLnRhcmdldCwgZS50YXJnZXQudmFsdWUubGVuZ3RoKTsgLy8gLi5hbmQgdGhpcyBvbiB0aGUgZmFyIHJpZ2h0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IC8vIGVsc2UgaWYgdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjbGFtcGVkLCB0aGUgZGVmYXVsdCBiZWhhdmlvciBpcyB1c2VkLi4uXG4gICAgICAgICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBjYXNlICdpZ25vcmUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3RydW5jYXRlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdyZXBsYWNlJzpcbiAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbmV2ZXIgb25lIG9yIG11bHRpcGxlIGNoYXJhY3RlcnMgYXJlIHBhc3RlZCwgdGhpcyBtZWFucyB3ZSBoYXZlIHRvIG1hbmFnZSB0aGUgcG90ZW50aWFsIHRob3VzYW5kIHNlcGFyYXRvcnMgdGhhdCBjb3VsZCBiZSBhZGRlZCBieSB0aGUgZm9ybWF0dGluZ1xuICAgICAgICAgICAgICAgICAgICBjYXJldFBvc2l0aW9uSW5Gb3JtYXR0ZWROdW1iZXIgPSBmaW5kQ2FyZXRQb3NpdGlvbkluRm9ybWF0dGVkTnVtYmVyKHJlc3VsdCwgY2FyZXRQb3NpdGlvbk9uSW5pdGlhbFRleHRBZnRlclBhc3RpbmcsIGUudGFyZ2V0LnZhbHVlLCBob2xkZXIuc2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgICAgIHNldEVsZW1lbnRTZWxlY3Rpb24oZS50YXJnZXQsIGNhcmV0UG9zaXRpb25JbkZvcm1hdHRlZE51bWJlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyA4LiBXZSBtYWtlIHN1cmUgd2Ugc2VuZCBhbiBpbnB1dCBldmVudCBvbmx5IGlmIHRoZSByZXN1bHQgaXMgZGlmZmVyZW50IHRoYW4gdGhlIGluaXRpYWwgdmFsdWUgYmVmb3JlIHRoZSBwYXN0ZVxuICAgICAgICBpZiAodmFsdWVIYXNCZWVuU2V0ICYmIGluaXRpYWxGb3JtYXR0ZWRWYWx1ZSAhPT0gZS50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE9uIGEgJ25vcm1hbCcgbm9uLWF1dG9OdW1lcmljIGlucHV0LCBhbiBgaW5wdXRgIGV2ZW50IGlzIHNlbnQgd2hlbiBhIHBhc3RlIGlzIGRvbmUuIFdlIG1pbWljIHRoYXQuXG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2lucHV0JywgZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2hlbiBmb2N1c2luZyBvdXQgb2YgdGhlIGlucHV0LCB3ZSBjaGVjayBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBpZiBpdCBoYXMsIHRoZW4gd2Ugc2VuZCBhIGBjaGFuZ2VgIGV2ZW50IChzaW5jZSB0aGUgbmF0aXZlIG9uZSB3b3VsZCBoYXZlIGJlZW4gcHJldmVudGVkIGJ5IGBlLnByZXZlbnREZWZhdWx0KClgIGNhbGxlZCBpbiB0aGUgb3RoZXIgZXZlbnQgbGlzdGVuZXJzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXV0b051bWVyaWNIb2xkZXJ9IGhvbGRlclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvbkJsdXIoaG9sZGVyLCBlKSB7XG4gICAgICAgIGlmIChlLnRhcmdldC52YWx1ZSAhPT0gaG9sZGVyLnZhbHVlT25Gb2N1cykge1xuICAgICAgICAgICAgdHJpZ2dlckV2ZW50KCdjaGFuZ2UnLCBlLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlLnByZXZlbnREZWZhdWx0KCk7IC8vIC4uLmFuZCBpbW1lZGlhdGVseSBwcmV2ZW50IHRoZSBicm93c2VyIHRvIHNlbmQgYSBzZWNvbmQgY2hhbmdlIGV2ZW50ICh0aGF0IHNvbWVob3cgZ2V0cyBwaWNrZWQgdXAgYnkgalF1ZXJ5LCBidXQgbm90IGJ5IGBhZGRFdmVudExpc3RlbmVyKClgIC8vRklYTUUgS05PV04gQlVHIDogVGhpcyBkb2VzIG5vdCBwcmV2ZW50IHRoZSBzZWNvbmQgY2hhbmdlIGV2ZW50IHRvIGJlIHBpY2tlZCB1cCBieSBqUXVlcnksIHdoaWNoIGFkZHMgJy4wMCcgYXQgdGhlIGVuZCBvZiBhbiBpbnRlZ2VyXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVyIGZvciAnc3VibWl0JyBldmVudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0F1dG9OdW1lcmljSG9sZGVyfSBob2xkZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvblN1Ym1pdCgkdGhpcywgaG9sZGVyKSB7XG4gICAgICAgICR0aGlzLmNsb3Nlc3QoJ2Zvcm0nKS5vbignc3VibWl0LmF1dG9OdW1lcmljJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGhvbGRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0ICRzZXR0aW5ncyA9IGhvbGRlci5zZXR0aW5nc0Nsb25lO1xuXG4gICAgICAgICAgICAgICAgaWYgKCRzZXR0aW5ncy51bmZvcm1hdE9uU3VibWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgkc2V0dGluZ3MucmF3VmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBqUXVlcnkgc2VsZWN0ZWQgaW5wdXQgaWYgdGhlIHRhZyBhbmQgdHlwZSBhcmUgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9ICR0aGlzIGpRdWVyeS1zZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufCp9XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0SW5wdXRJZlN1cHBvcnRlZFRhZ0FuZFR5cGUoJHRoaXMpIHtcbiAgICAgICAgLy8gU3VwcG9ydGVkIGlucHV0IHR5cGVcbiAgICAgICAgY29uc3QgJGlucHV0ID0gJHRoaXMuaXMoJ2lucHV0W3R5cGU9dGV4dF0sIGlucHV0W3R5cGU9aGlkZGVuXSwgaW5wdXRbdHlwZT10ZWxdLCBpbnB1dDpub3QoW3R5cGVdKScpO1xuXG4gICAgICAgIC8vIENoZWNrcyBmb3Igbm9uLXN1cHBvcnRlZCBpbnB1dCB0eXBlc1xuICAgICAgICBpZiAoISRpbnB1dCAmJiAkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0Jykge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGlucHV0IHR5cGUgXCIkeyR0aGlzLnByb3AoJ3R5cGUnKX1cIiBpcyBub3Qgc3VwcG9ydGVkIGJ5IGF1dG9OdW1lcmljYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgZm9yIG5vbi1zdXBwb3J0ZWQgdGFnc1xuICAgICAgICBjb25zdCBjdXJyZW50RWxlbWVudFRhZyA9ICR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoY3VycmVudEVsZW1lbnRUYWcgIT09ICdpbnB1dCcgJiYgIWlzSW5BcnJheShjdXJyZW50RWxlbWVudFRhZywgYWxsb3dlZFRhZ0xpc3QpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgPCR7Y3VycmVudEVsZW1lbnRUYWd9PiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICRpbnB1dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIHRoZSBkZWZhdWx0IHZhbHVlIG9uIHBhZ2UgbG9hZC5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBvbmx5IGlmIHRoZSBgZm9ybWF0T25QYWdlTG9hZGAgb3B0aW9uIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJGlucHV0IGpRdWVyeS1zZWxlY3RlZCA8aW5wdXQ+IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gJHRoaXMgalF1ZXJ5LXNlbGVjdGVkIERPTSBlbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChzZXR0aW5ncywgJGlucHV0LCAkdGhpcykge1xuICAgICAgICBsZXQgc2V0VmFsdWUgPSB0cnVlO1xuXG4gICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9ICR0aGlzLnZhbCgpO1xuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIElmIHRoZSBpbnB1dCB2YWx1ZSBoYXMgYmVlbiBzZXQgYnkgdGhlIGRldiwgYnV0IG5vdCBkaXJlY3RseSBhcyBhbiBhdHRyaWJ1dGUgaW4gdGhlIGh0bWwsIHRoZW4gaXQgdGFrZXNcbiAgICAgICAgICAgICAqIHByZWNlZGVuY2UgYW5kIHNob3VsZCBnZXQgZm9ybWF0dGVkIG9uIGluaXQgKGlmIHRoaXMgaW5wdXQgdmFsdWUgaXMgYSB2YWxpZCBudW1iZXIgYW5kIHRoYXQgdGhlXG4gICAgICAgICAgICAgKiBkZXZlbG9wZXIgd2FudHMgaXQgZm9ybWF0dGVkIG9uIGluaXQgKGNmLiBgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZGApKS5cbiAgICAgICAgICAgICAqIE5vdGU7IHRoaXMgaXMgdHJ1ZSB3aGF0ZXZlciB0aGUgZGV2ZWxvcGVyIGhhcyBzZXQgZm9yIGBkYXRhLWFuLWRlZmF1bHRgIGluIHRoZSBodG1sIChhc3AubmV0IHVzZXJzKS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBJbiBvdGhlciB3b3JkcyA6IGlmIGBkZWZhdWx0VmFsdWVPdmVycmlkZWAgaXMgbm90IG51bGwsIGl0IG1lYW5zIHRoZSBkZXZlbG9wZXIgaXMgdHJ5aW5nIHRvIHByZXZlbnQgcG9zdGJhY2sgcHJvYmxlbXMuXG4gICAgICAgICAgICAgKiBCdXQgaWYgYGlucHV0LnZhbHVlYCBpcyBzZXQgdG8gYSBudW1iZXIsIGFuZCBgJHRoaXMuYXR0cigndmFsdWUnKWAgaXMgbm90IHNldCwgdGhlbiBpdCBtZWFucyB0aGUgZGV2IGhhc1xuICAgICAgICAgICAgICogY2hhbmdlZCB0aGUgaW5wdXQgdmFsdWUsIGFuZCB0aGVuIGl0IG1lYW5zIHdlIHNob3VsZCBub3Qgb3ZlcndyaXRlIGhpcyBvd24gZGVjaXNpb24gdG8gZG8gc28uXG4gICAgICAgICAgICAgKiBIZW5jZSwgaWYgYGRlZmF1bHRWYWx1ZU92ZXJyaWRlYCBpcyBub3QgbnVsbCwgYnV0IGBpbnB1dC52YWx1ZWAgaXMgYSBudW1iZXIgYW5kIGAkdGhpcy5hdHRyKCd2YWx1ZScpYCBpcyBub3Qgc2V0LFxuICAgICAgICAgICAgICogd2Ugc2hvdWxkIGlnbm9yZSBgZGVmYXVsdFZhbHVlT3ZlcnJpZGVgIGFsdG9nZXRoZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHVuTG9jYWxpemVkQ3VycmVudFZhbHVlID0gdG9OdW1lcmljVmFsdWUoY3VycmVudFZhbHVlLCBzZXR0aW5ncyk7IC8vIFRoaXMgYWxsb3dzIHRvIHVzZSBhIGxvY2FsaXplZCB2YWx1ZSBvbiBzdGFydHVwXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCAmJiBjdXJyZW50VmFsdWUgIT09ICcnICYmIGlzVW5kZWZpbmVkT3JOdWxsT3JFbXB0eSgkdGhpcy5hdHRyKCd2YWx1ZScpKSkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBgdmFsdWVgIGlzIHZhbGlkIG9yIG5vdFxuICAgICAgICAgICAgICAgIGlmICghaXNOYU4odW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpICYmIEluZmluaXR5ICE9PSB1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgdW5Mb2NhbGl6ZWRDdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vdCwgaW5mb3JtIHRoZSBkZXZlbG9wZXIgdGhhdCBub3RoaW5nIHVzYWJsZSBoYXMgYmVlbiBwcm92aWRlZFxuICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7Y3VycmVudFZhbHVlfV0gdXNlZCBpbiB0aGUgaW5wdXQgaXMgbm90IGEgdmFsaWQgdmFsdWUgYXV0b051bWVyaWMgY2FuIHdvcmsgd2l0aC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIENoZWNrcyBmb3IgOlxuICAgICAgICAgICAgICAgICAqIC0gcGFnZSByZWxvYWQgZnJvbSBiYWNrIGJ1dHRvbiwgYW5kXG4gICAgICAgICAgICAgICAgICogLSBBU1AubmV0IGZvcm0gcG9zdCBiYWNrXG4gICAgICAgICAgICAgICAgICogICAgICBUaGUgZm9sbG93aW5nIEhUTUwgZGF0YSBhdHRyaWJ1dGUgaXMgUkVRVUlSRUQgKGRhdGEtYW4tZGVmYXVsdD1cInNhbWUgdmFsdWUgYXMgdGhlIHZhbHVlIGF0dHJpYnV0ZVwiKVxuICAgICAgICAgICAgICAgICAqICAgICAgZXhhbXBsZTogPGFzcDpUZXh0Qm94IHJ1bmF0PVwic2VydmVyXCIgaWQ9XCJzb21lSURcIiB0ZXh0PVwiMTIzNC41NlwiIGRhdGEtYW4tZGVmYXVsdD1cIjEyMzQuNTZcIj5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlICE9PSBudWxsICYmIHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlLnRvU3RyaW5nKCkgIT09IGN1cnJlbnRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlID09PSBudWxsICYmIGN1cnJlbnRWYWx1ZSAhPT0gJycgJiYgY3VycmVudFZhbHVlICE9PSAkdGhpcy5hdHRyKCd2YWx1ZScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoY3VycmVudFZhbHVlICE9PSAnJyAmJiAkdGhpcy5hdHRyKCd0eXBlJykgPT09ICdoaWRkZW4nICYmICFpc051bWJlcih1bkxvY2FsaXplZEN1cnJlbnRWYWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAhPT0gbnVsbCAmJiBzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiBzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ2dldCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMgdmFsdWUgc2hvdWxkIE5PVCBiZSBzYXZlZCBpbiBzZXNzaW9uU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0b1N0cmlwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIgIT09IG51bGwgJiYgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KGN1cnJlbnRWYWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmlwID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHNldHRpbmdzLm5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50ID09PSAncycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQgIT09ICdwJyAmJiBzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCA9PT0gJ3MnKSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgIT09ICcnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZWdhdGl2ZShjdXJyZW50VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgKyBzdHJpcEFsbE5vbk51bWJlckNoYXJhY3RlcnModG9TdHJpcCwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh0b1N0cmlwLCBzZXR0aW5ncywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Fsd2F5cyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoc2V0dGluZ3MuY3VycmVuY3lTeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICd6ZXJvJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCAnMCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldFZhbHVlICYmIGN1cnJlbnRWYWx1ZSA9PT0gJHRoaXMuYXR0cigndmFsdWUnKSkge1xuICAgICAgICAgICAgICAgICR0aGlzLmF1dG9OdW1lcmljKCdzZXQnLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSW5BcnJheSgkdGhpcy5wcm9wKCd0YWdOYW1lJykudG9Mb3dlckNhc2UoKSwgc2V0dGluZ3MudGFnTGlzdCkgJiYgJHRoaXMudGV4dCgpICE9PSAnJykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlZmF1bHRWYWx1ZU92ZXJyaWRlID09PSAkdGhpcy50ZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnRleHQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkdGhpcy5hdXRvTnVtZXJpYygnc2V0JywgJHRoaXMudGV4dCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuaGFuY2UgdGhlIHVzZXIgZXhwZXJpZW5jZSBieSBtb2RpZnlpbmcgdGhlIGRlZmF1bHQgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBvcHRpb24gZGVwZW5kaW5nIG9uIGBjdXJyZW5jeVN5bWJvbGAgYW5kIGBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdXNlciBoYXMgbm90IHNldCB0aGUgcGxhY2VtZW50IG9mIHRoZSBuZWdhdGl2ZSBzaWduIChgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRgKSwgYnV0IGhhcyBzZXQgYSBjdXJyZW5jeSBzeW1ib2wgKGBjdXJyZW5jeVN5bWJvbGApLFxuICAgICAqIHRoZW4gd2UgbW9kaWZ5IHRoZSBkZWZhdWx0IHZhbHVlIG9mIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgaW4gb3JkZXIgdG8ga2VlcCB0aGUgcmVzdWx0aW5nIG91dHB1dCBsb2dpY2FsIGJ5IGRlZmF1bHQgOlxuICAgICAqIC0gXCIkLTEsMjM0LjU2XCIgaW5zdGVhZCBvZiBcIi0kMSwyMzQuNTZcIiAoe2N1cnJlbmN5U3ltYm9sOiBcIiRcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwiclwifSlcbiAgICAgKiAtIFwiLTEsMjM0LjU2JFwiIGluc3RlYWQgb2YgXCIxLDIzNC41Ni0kXCIgKHtjdXJyZW5jeVN5bWJvbDogXCIkXCIsIGN1cnJlbmN5U3ltYm9sUGxhY2VtZW50OiBcInNcIiwgbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQ6IFwicFwifSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3ROZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudE9wdGlvbihzZXR0aW5ncykge1xuICAgICAgICAvLyBJZiBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCBpcyBhbHJlYWR5IHNldCwgd2UgZG8gbm90IG92ZXJ3cml0ZSBpdFxuICAgICAgICBpZiAoIWlzTnVsbChzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoc2V0dGluZ3MpICYmXG4gICAgICAgICAgICBpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkoc2V0dGluZ3MubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQpICYmXG4gICAgICAgICAgICAhaXNVbmRlZmluZWRPck51bGxPckVtcHR5KHNldHRpbmdzLmN1cnJlbmN5U3ltYm9sKSkge1xuICAgICAgICAgICAgc3dpdGNoIChzZXR0aW5ncy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9ICdwJzsgLy8gRGVmYXVsdCAtMSwyMzQuNTYg4oKsXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3AnOlxuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9ICdsJzsgLy8gRGVmYXVsdCAtJDEsMjM0LjU2XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTZXRzIHRoZSBkZWZhdWx0IHZhbHVlIGlmIGBuZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudGAgaXMgYG51bGxgXG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCA9ICdsJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuYWx5emUgYW5kIHNhdmUgdGhlIG1pbmltdW1WYWx1ZSBhbmQgbWF4aW11bVZhbHVlIGludGVnZXIgc2l6ZSBmb3IgbGF0ZXIgdXNlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHNldHRpbmdzXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMoc2V0dGluZ3MpIHtcbiAgICAgICAgbGV0IFttYXhpbXVtVmFsdWVJbnRlZ2VyUGFydF0gPSBzZXR0aW5ncy5tYXhpbXVtVmFsdWUudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgICBsZXQgW21pbmltdW1WYWx1ZUludGVnZXJQYXJ0XSA9ICghc2V0dGluZ3MubWluaW11bVZhbHVlICYmIHNldHRpbmdzLm1pbmltdW1WYWx1ZSAhPT0gMCk/W106c2V0dGluZ3MubWluaW11bVZhbHVlLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgICAgbWF4aW11bVZhbHVlSW50ZWdlclBhcnQgPSBtYXhpbXVtVmFsdWVJbnRlZ2VyUGFydC5yZXBsYWNlKCctJywgJycpO1xuICAgICAgICBtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydCA9IG1pbmltdW1WYWx1ZUludGVnZXJQYXJ0LnJlcGxhY2UoJy0nLCAnJyk7XG5cbiAgICAgICAgc2V0dGluZ3MubUludFBvcyA9IE1hdGgubWF4KG1heGltdW1WYWx1ZUludGVnZXJQYXJ0Lmxlbmd0aCwgMSk7XG4gICAgICAgIHNldHRpbmdzLm1JbnROZWcgPSBNYXRoLm1heChtaW5pbXVtVmFsdWVJbnRlZ2VyUGFydC5sZW5ndGgsIDEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSBgZGVjaW1hbFBsYWNlc092ZXJyaWRlYCBhcyBuZWVkZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvcnJlY3REZWNpbWFsUGxhY2VzT3ZlcnJpZGVPcHRpb24oc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKCFpc051bGwoc2V0dGluZ3Muc2NhbGVEaXZpc29yKSAmJiAhaXNOdWxsKHNldHRpbmdzLnNjYWxlRGVjaW1hbFBsYWNlcykpIHtcbiAgICAgICAgICAgIC8vIE92ZXJyaWRlIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyB3aXRoIHRoZSBvbmUgZGVmaW5lZCB3aXRoIHRoZSBudW1iZXIgb2YgZGVjaW1hbHMgdG8gc2hvdyB3aGVuIG5vdCBpbiBmb2N1cywgaWYgc2V0XG4gICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSBzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNOdWxsKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBzZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHNldHRpbmdzLm9EZWMgPSBTdHJpbmcoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlKTtcblxuICAgICAgICAvLyBNb3N0IGNhbGN1bHVzIGFzc3VtZSBgZGVjaW1hbFBsYWNlc092ZXJyaWRlYCBpcyBhbiBpbnRlZ2VyLCB0aGUgZm9sbG93aW5nIHN0YXRlbWVudCBtYWtlcyBpdCBjbGVhciAob3RoZXJ3aXNlIGhhdmluZyBpdCBhcyBhIHN0cmluZyBsZWFkcyB0byBwcm9ibGVtcyBpbiByb3VuZGluZyBmb3IgaW5zdGFuY2UpXG4gICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IE51bWJlcihzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFsdGVybmF0aXZlIGRlY2ltYWwgc2VwYXJhdG9yIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldHNBbHRlcm5hdGl2ZURlY2ltYWxTZXBhcmF0b3JDaGFyYWN0ZXIoc2V0dGluZ3MpIHtcbiAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpICYmIE51bWJlcihzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpID4gMCkge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgPT09ICcuJyAmJiBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLCcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgPSAnLCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIgPT09ICcsJyAmJiBzZXR0aW5ncy5kaWdpdEdyb3VwU2VwYXJhdG9yICE9PSAnLicpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUgPSAnLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWNoZXMgcmVndWxhciBleHByZXNzaW9ucyBmb3Igc3RyaXBBbGxOb25OdW1iZXJDaGFyYWN0ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc2V0dGluZ3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWNoZXNVc3VhbFJlZ3VsYXJFeHByZXNzaW9ucyhzZXR0aW5ncykge1xuICAgICAgICBjb25zdCBhbGxOdW1iZXJzUmVnID0gJ1swLTldJztcbiAgICAgICAgY29uc3Qgbm9BbGxOdW1iZXJzUmVnID0gJ1teMC05XSc7XG5cbiAgICAgICAgLy8gVGVzdCBpZiB0aGVyZSBpcyBhIG5lZ2F0aXZlIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nXG4gICAgICAgIGNvbnN0IGFOZWdSZWcgPSBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXI/YChbLVxcXFwke3NldHRpbmdzLm5lZ2F0aXZlU2lnbkNoYXJhY3Rlcn1dPylgOicoLT8pJztcbiAgICAgICAgc2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcCA9IGFOZWdSZWc7XG5cbiAgICAgICAgbGV0IG5lZ2F0aXZlU2lnblJlZ1BhcnQ7XG4gICAgICAgIGlmIChzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIG5lZ2F0aXZlU2lnblJlZ1BhcnQgPSBgXFxcXCR7c2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyfWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWdhdGl2ZVNpZ25SZWdQYXJ0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgc2V0dGluZ3Muc2tpcEZpcnN0QXV0b1N0cmlwID0gbmV3IFJlZ0V4cChgJHthTmVnUmVnfVteLSR7bmVnYXRpdmVTaWduUmVnUGFydH1cXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfSR7YWxsTnVtYmVyc1JlZ31dLio/KCR7YWxsTnVtYmVyc1JlZ318XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke2FsbE51bWJlcnNSZWd9KWApO1xuICAgICAgICBzZXR0aW5ncy5za2lwTGFzdEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYCgke2FsbE51bWJlcnNSZWd9XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0/KVteXFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke2FsbE51bWJlcnNSZWd9XSR7bm9BbGxOdW1iZXJzUmVnfSokYCk7XG5cbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IGAtMDEyMzQ1Njc4OVxcXFwke3NldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXJ9YDtcbiAgICAgICAgc2V0dGluZ3MuYWxsb3dlZEF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZycpO1xuICAgICAgICBzZXR0aW5ncy5udW1SZWdBdXRvU3RyaXAgPSBuZXcgUmVnRXhwKGAke2FOZWdSZWd9KD86XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0/KCR7YWxsTnVtYmVyc1JlZ30rXFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke2FsbE51bWJlcnNSZWd9Kyl8KCR7YWxsTnVtYmVyc1JlZ30qKD86XFxcXCR7c2V0dGluZ3MuZGVjaW1hbENoYXJhY3Rlcn0ke2FsbE51bWJlcnNSZWd9Kik/KSlgKTtcblxuICAgICAgICAvLyBVc2luZyB0aGlzIHJlZ2V4IHZlcnNpb24gYF4ke3NldHRpbmdzLmFOZWdSZWdBdXRvU3RyaXB9MCooXFxcXGR8JClgIGVudGlyZWx5IGNsZWFyIHRoZSBpbnB1dCBvbiBibHVyXG4gICAgICAgIHNldHRpbmdzLnN0cmlwUmVnID0gbmV3IFJlZ0V4cChgXiR7c2V0dGluZ3MuYU5lZ1JlZ0F1dG9TdHJpcH0wKigke2FsbE51bWJlcnNSZWd9KWApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vZGlmeSB0aGUgdXNlciBzZXR0aW5ncyB0byBtYWtlIHRoZW0gJ2V4cGxvaXRhYmxlJyBsYXRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyYW5zZm9ybU9wdGlvbnNWYWx1ZXNUb0RlZmF1bHRUeXBlcyhzZXR0aW5ncykge1xuICAgICAgICAkLmVhY2goc2V0dGluZ3MsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgJ3RydWUnIGFuZCAnZmFsc2UnIHRvIHJlYWwgQm9vbGVhblxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAndHJ1ZScgfHwgdmFsdWUgPT09ICdmYWxzZScpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1trZXldID0gdmFsdWUgPT09ICd0cnVlJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ29udmVydCBudW1iZXJzIGluIG9wdGlvbnMgdG8gc3RyaW5nc1xuICAgICAgICAgICAgLy9UT0RPIGlmIGEgdmFsdWUgaXMgYWxyZWFkeSBvZiB0eXBlICdOdW1iZXInLCBzaG91bGRuJ3Qgd2Uga2VlcCBpdCBhcyBhIG51bWJlciBmb3IgZnVydGhlciBtYW5pcHVsYXRpb24sIGluc3RlYWQgb2YgdXNpbmcgYSBzdHJpbmc/XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBrZXkgIT09ICdhU2NhbGUnKSB7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3Nba2V5XSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIG9sZCBzZXR0aW5ncyBvcHRpb25zIG5hbWUgdG8gbmV3IG9uZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKG9wdGlvbnMpIHtcbiAgICAgICAgLy9UT0RPIERlbGV0ZSB0aGlzIGZ1bmN0aW9uIG9uY2UgdGhlIG9sZCBvcHRpb25zIGFyZSBub3QgdXNlZCBhbnltb3JlXG4gICAgICAgIGNvbnN0IG9sZE9wdGlvbnNDb252ZXJ0ZXIgPSB7XG4gICAgICAgICAgICAvLyBPbGQgb3B0aW9uIG5hbWUsIHdpdGggdGhlaXIgY29ycmVzcG9uZGluZyBuZXcgb3B0aW9uXG4gICAgICAgICAgICBhU2VwICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RpZ2l0R3JvdXBTZXBhcmF0b3InLFxuICAgICAgICAgICAgblNlcCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdub1NlcGFyYXRvck9uRm9jdXMnLFxuICAgICAgICAgICAgZEdyb3VwICAgICAgICAgICAgICAgICAgICAgICA6ICdkaWdpdGFsR3JvdXBTcGFjaW5nJyxcbiAgICAgICAgICAgIGFEZWMgICAgICAgICAgICAgICAgICAgICAgICAgOiAnZGVjaW1hbENoYXJhY3RlcicsXG4gICAgICAgICAgICBhbHREZWMgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZScsXG4gICAgICAgICAgICBhU2lnbiAgICAgICAgICAgICAgICAgICAgICAgIDogJ2N1cnJlbmN5U3ltYm9sJyxcbiAgICAgICAgICAgIHBTaWduICAgICAgICAgICAgICAgICAgICAgICAgOiAnY3VycmVuY3lTeW1ib2xQbGFjZW1lbnQnLFxuICAgICAgICAgICAgcE5lZyAgICAgICAgICAgICAgICAgICAgICAgICA6ICduZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCcsXG4gICAgICAgICAgICBhU3VmZml4ICAgICAgICAgICAgICAgICAgICAgIDogJ3N1ZmZpeFRleHQnLFxuICAgICAgICAgICAgb0xpbWl0cyAgICAgICAgICAgICAgICAgICAgICA6ICdvdmVycmlkZU1pbk1heExpbWl0cycsXG4gICAgICAgICAgICB2TWF4ICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21heGltdW1WYWx1ZScsXG4gICAgICAgICAgICB2TWluICAgICAgICAgICAgICAgICAgICAgICAgIDogJ21pbmltdW1WYWx1ZScsXG4gICAgICAgICAgICBtRGVjICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScsXG4gICAgICAgICAgICBlRGVjICAgICAgICAgICAgICAgICAgICAgICAgIDogJ2RlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMnLFxuICAgICAgICAgICAgc2NhbGVEZWNpbWFsICAgICAgICAgICAgICAgICA6ICdzY2FsZURlY2ltYWxQbGFjZXMnLFxuICAgICAgICAgICAgYVN0b3IgICAgICAgICAgICAgICAgICAgICAgICA6ICdzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlJyxcbiAgICAgICAgICAgIG1Sb3VuZCAgICAgICAgICAgICAgICAgICAgICAgOiAncm91bmRpbmdNZXRob2QnLFxuICAgICAgICAgICAgYVBhZCAgICAgICAgICAgICAgICAgICAgICAgICA6ICdhbGxvd0RlY2ltYWxQYWRkaW5nJyxcbiAgICAgICAgICAgIG5CcmFja2V0ICAgICAgICAgICAgICAgICAgICAgOiAnbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXInLFxuICAgICAgICAgICAgd0VtcHR5ICAgICAgICAgICAgICAgICAgICAgICA6ICdlbXB0eUlucHV0QmVoYXZpb3InLFxuICAgICAgICAgICAgbFplcm8gICAgICAgICAgICAgICAgICAgICAgICA6ICdsZWFkaW5nWmVybycsXG4gICAgICAgICAgICBhRm9ybSAgICAgICAgICAgICAgICAgICAgICAgIDogJ2Zvcm1hdE9uUGFnZUxvYWQnLFxuICAgICAgICAgICAgc051bWJlciAgICAgICAgICAgICAgICAgICAgICA6ICdzZWxlY3ROdW1iZXJPbmx5JyxcbiAgICAgICAgICAgIGFuRGVmYXVsdCAgICAgICAgICAgICAgICAgICAgOiAnZGVmYXVsdFZhbHVlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgdW5TZXRPblN1Ym1pdCAgICAgICAgICAgICAgICA6ICd1bmZvcm1hdE9uU3VibWl0JyxcbiAgICAgICAgICAgIG91dHB1dFR5cGUgICAgICAgICAgICAgICAgICAgOiAnb3V0cHV0Rm9ybWF0JyxcbiAgICAgICAgICAgIGRlYnVnICAgICAgICAgICAgICAgICAgICAgICAgOiAnc2hvd1dhcm5pbmdzJyxcbiAgICAgICAgICAgIC8vIEN1cnJlbnQgb3B0aW9ucyA6XG4gICAgICAgICAgICBkaWdpdEdyb3VwU2VwYXJhdG9yICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5vU2VwYXJhdG9yT25Gb2N1cyAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGlnaXRhbEdyb3VwU3BhY2luZyAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWNpbWFsQ2hhcmFjdGVyICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZSAgOiB0cnVlLFxuICAgICAgICAgICAgY3VycmVuY3lTeW1ib2wgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50OiB0cnVlLFxuICAgICAgICAgICAgc2hvd1Bvc2l0aXZlU2lnbiAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzdWZmaXhUZXh0ICAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG92ZXJyaWRlTWluTWF4TGltaXRzICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbWF4aW11bVZhbHVlICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBtaW5pbXVtVmFsdWUgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGRlY2ltYWxQbGFjZXNPdmVycmlkZSAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyAgICA6IHRydWUsXG4gICAgICAgICAgICBzY2FsZURpdmlzb3IgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHNjYWxlRGVjaW1hbFBsYWNlcyAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2NhbGVTeW1ib2wgICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG9uSW52YWxpZFBhc3RlICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgcm91bmRpbmdNZXRob2QgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBhbGxvd0RlY2ltYWxQYWRkaW5nICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIG5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICAgOiB0cnVlLFxuICAgICAgICAgICAgZW1wdHlJbnB1dEJlaGF2aW9yICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBsZWFkaW5nWmVybyAgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGZvcm1hdE9uUGFnZUxvYWQgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2VsZWN0TnVtYmVyT25seSAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVPdmVycmlkZSAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIHVuZm9ybWF0T25TdWJtaXQgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb3V0cHV0Rm9ybWF0ICAgICAgICAgICAgICAgICA6IHRydWUsXG4gICAgICAgICAgICBzaG93V2FybmluZ3MgICAgICAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgIGZhaWxPblVua25vd25PcHRpb24gICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgLy9GSVhNRSBGaW5kIGEgd2F5IHRvIGV4Y2x1ZGUgdGhvc2UgaW50ZXJuYWwgZGF0YSBmcm9tIHRoZSBzZXR0aW5ncyBvYmplY3QgKGlkZWFsbHkgYnkgdXNpbmcgYW5vdGhlciBvYmplY3QsIG9yIGJldHRlciB5ZXQsIGNsYXNzIGF0dHJpYnV0ZXMpIC0tPlxuICAgICAgICAgICAgaGFzRm9jdXMgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgcnVuT25jZSAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgcmF3VmFsdWUgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgdHJhaWxpbmdOZWdhdGl2ZSAgICAgOiB0cnVlLFxuICAgICAgICAgICAgY2FyZXRGaXggICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgdGhyb3dJbnB1dCAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc3RyaXAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgdGFnTGlzdCAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbmVnYXRpdmVTaWduQ2hhcmFjdGVyOiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpdmVTaWduQ2hhcmFjdGVyOiB0cnVlLFxuICAgICAgICAgICAgbUludFBvcyAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbUludE5lZyAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb0RlYyAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb1BhZCAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb0JyYWNrZXQgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb1NlcCAgICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb1NpZ24gICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgb1N1ZmZpeCAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgYU5lZ1JlZ0F1dG9TdHJpcCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc2tpcEZpcnN0QXV0b1N0cmlwICAgOiB0cnVlLFxuICAgICAgICAgICAgc2tpcExhc3RBdXRvU3RyaXAgICAgOiB0cnVlLFxuICAgICAgICAgICAgYWxsb3dlZEF1dG9TdHJpcCAgICAgOiB0cnVlLFxuICAgICAgICAgICAgbnVtUmVnQXV0b1N0cmlwICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgc3RyaXBSZWcgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICAgICAgaG9sZGVyICAgICAgICAgICAgICAgOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIGluIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkT3B0aW9uc0NvbnZlcnRlcltvcHRpb25dID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcHRpb24gaXMgYSAnbmV3JyBvcHRpb24sIHdlIGNvbnRpbnVlIGxvb3BpbmdcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKG9sZE9wdGlvbnNDb252ZXJ0ZXIuaGFzT3duUHJvcGVydHkob3B0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFbHNlIHdlIGhhdmUgYW4gJ29sZCcgb3B0aW9uIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZyhgWW91IGFyZSB1c2luZyB0aGUgZGVwcmVjYXRlZCBvcHRpb24gbmFtZSAnJHtvcHRpb259Jy4gUGxlYXNlIHVzZSAnJHtvbGRPcHRpb25zQ29udmVydGVyW29wdGlvbl19JyBpbnN0ZWFkIGZyb20gbm93IG9uLiBUaGUgb2xkIG9wdGlvbiBuYW1lIHdpbGwgYmUgZHJvcHBlZCBzb29uLmAsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gd2UgbW9kaWZ5IHRoZSBpbml0aWFsIG9wdGlvbiBvYmplY3QgdG8gdXNlIHRoZSBuZXcgb3B0aW9ucyBpbnN0ZWFkIG9mIHRoZSBvbGQgb25lc1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zW29sZE9wdGlvbnNDb252ZXJ0ZXJbb3B0aW9uXV0gPSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4ub3IgdGhlIG9wdGlvbiBuYW1lIGlzIHVua25vd24uIFRoaXMgbWVhbnMgdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIG9wdGlvbnMgb2JqZWN0LCB0aGVyZWZvcmUgd2UgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYE9wdGlvbiBuYW1lICcke29wdGlvbn0nIGlzIHVua25vd24uIFBsZWFzZSBmaXggdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGF1dG9OdW1lcmljYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5hbHlzZSB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBwYXNzZWQgYnkgdGhlIHVzZXIsIHZhbGlkYXRlIGFuZCBjbGVhbiB0aGVtLCB0aGVuIHJldHVybiB0aGVtLlxuICAgICAqIE5vdGU6IFRoaXMgcmV0dXJucyBgbnVsbGAgaWYgc29tZWhvdyB0aGUgc2V0dGluZ3MgcmV0dXJuZWQgYnkgalF1ZXJ5IGlzIG5vdCBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7b2JqZWN0fSAkdGhpcyBqUXVlcnktc2VsZWN0ZWQgRE9NIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IHVwZGF0ZSAtIElmIFRSVUUsIHRoZW4gdGhlIHNldHRpbmdzIGFscmVhZHkgZXhpc3RzIGFuZCB0aGlzIGZ1bmN0aW9uIG9ubHkgdXBkYXRlcyB0aGVtIGluc3RlYWQgb2YgcmVjcmVhdGluZyB0aGVtIGZyb20gc2NyYXRjaFxuICAgICAqIEByZXR1cm5zIHtvYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRJbml0aWFsU2V0dGluZ3Mob3B0aW9ucywgJHRoaXMsIHVwZGF0ZSA9IGZhbHNlKSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gZ3JhYiBcImF1dG9OdW1lcmljXCIgc2V0dGluZ3MuIElmIHRoZXkgZG8gbm90IGV4aXN0LCBpdCByZXR1cm5zIFwidW5kZWZpbmVkXCIuXG4gICAgICAgIGxldCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG5cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgdXNlZCBvbGQgb3B0aW9ucywgd2UgY29udmVydCB0aGVtIHRvIG5ldyBvbmVzXG4gICAgICAgIGlmICh1cGRhdGUgfHwgIWlzTnVsbChvcHRpb25zKSkge1xuICAgICAgICAgICAgY29udmVydE9sZE9wdGlvbnNUb05ld09uZXMob3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlIHx8IGlzVW5kZWZpbmVkKHNldHRpbmdzKSkge1xuICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBzZXR0aW5ncyBhcmUgdXBkYXRlZFxuICAgICAgICAgICAgICAgIHNldHRpbmdzID0gJC5leHRlbmQoc2V0dGluZ3MsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBjb3VsZG4ndCBncmFiIGFueSBzZXR0aW5ncywgY3JlYXRlIHRoZW0gZnJvbSB0aGUgZGVmYXVsdCBvbmVzIGFuZCBjb21iaW5lIHRoZW0gd2l0aCB0aGUgb3B0aW9ucyBwYXNzZWRcbiAgICAgICAgICAgICAgICAvLyBUaGUgc2V0dGluZ3MgYXJlIGdlbmVyYXRlZCBmb3IgdGhlIGZpcnN0IHRpbWVcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFsc28gYXR0ZW1wdCB0byBncmFiIHRoZSBIVE1MNSBkYXRhLiBJZiBpdCBkb2Vzbid0IGV4aXN0LCB3ZSdsbCBnZXQgXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgIGNvbnN0IHRhZ0RhdGEgPSAkdGhpcy5kYXRhKCk7XG4gICAgICAgICAgICAgICAgc2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgZGVmYXVsdFNldHRpbmdzLCB0YWdEYXRhLCBvcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIGhhc0ZvY3VzICAgICAgICA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBydW5PbmNlICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgcmF3VmFsdWUgICAgICAgIDogJycsXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsaW5nTmVnYXRpdmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBjYXJldEZpeCAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dJbnB1dCAgICAgIDogdHJ1ZSwgLy8gVGhyb3cgaW5wdXQgZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgc3RyaXAgICAgICAgICAgIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdGFnTGlzdCAgICAgICAgIDogYWxsb3dlZFRhZ0xpc3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIE1vZGlmeSB0aGUgdXNlciBzZXR0aW5ncyB0byBtYWtlIHRoZW0gJ2V4cGxvaXRhYmxlJ1xuICAgICAgICAgICAgdHJhbnNmb3JtT3B0aW9uc1ZhbHVlc1RvRGVmYXVsdFR5cGVzKHNldHRpbmdzKTtcblxuICAgICAgICAgICAgLy8gSW1wcm92ZSB0aGUgYG5lZ2F0aXZlUG9zaXRpdmVTaWduUGxhY2VtZW50YCBvcHRpb24gaWYgbmVlZGVkXG4gICAgICAgICAgICBjb3JyZWN0TmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnRPcHRpb24oc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBTZXQgdGhlIG5lZ2F0aXZlIGFuZCBwb3NpdGl2ZSBzaWducywgYXMgbmVlZGVkXG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSBzZXR0aW5ncy5taW5pbXVtVmFsdWUgPCAwID8gJy0nIDogJyc7XG4gICAgICAgICAgICBzZXR0aW5ncy5wb3NpdGl2ZVNpZ25DaGFyYWN0ZXIgPSBzZXR0aW5ncy5tYXhpbXVtVmFsdWUgPj0gMCA/ICcrJyA6ICcnO1xuXG4gICAgICAgICAgICAvLyBBZGRpdGlvbmFsIGNoYW5nZXMgdG8gdGhlIHNldHRpbmdzIG9iamVjdCAoZnJvbSB0aGUgb3JpZ2luYWwgYXV0b0NvZGUoKSBmdW5jdGlvbilcbiAgICAgICAgICAgIHJ1bkNhbGxiYWNrc0ZvdW5kSW5UaGVTZXR0aW5nc09iamVjdCgkdGhpcywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgY2FsY3VsYXRlVk1pbkFuZFZNYXhJbnRlZ2VyU2l6ZXMoc2V0dGluZ3MpO1xuICAgICAgICAgICAgY29ycmVjdERlY2ltYWxQbGFjZXNPdmVycmlkZU9wdGlvbihzZXR0aW5ncyk7XG4gICAgICAgICAgICBzZXRzQWx0ZXJuYXRpdmVEZWNpbWFsU2VwYXJhdG9yQ2hhcmFjdGVyKHNldHRpbmdzKTtcbiAgICAgICAgICAgIGNhY2hlc1VzdWFsUmVndWxhckV4cHJlc3Npb25zKHNldHRpbmdzKTtcblxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNldHRpbmdzXG4gICAgICAgICAgICB2YWxpZGF0ZShzZXR0aW5ncywgZmFsc2UpOyAvLyBUaHJvd3MgaWYgbmVjZXNzYXJ5XG5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNldHRpbmdzIHNhdmVkIGZvciB1c2Ugd2hlbiBkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzLCBzY2FsZURpdmlzb3IgJiBub1NlcGFyYXRvck9uRm9jdXMgb3B0aW9ucyBhcmUgYmVpbmcgdXNlZFxuICAgICAgICAgICAga2VlcEFuT3JpZ2luYWxTZXR0aW5nc0NvcHkoc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBuZXcgc2V0dGluZ3NcbiAgICAgICAgICAgICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJywgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICByZXR1cm4gc2V0dGluZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgdGhlIGB2YWx1ZWAgcGFyYW1ldGVyIHRoYXQgY2FuIGVpdGhlciBiZSA6XG4gICAgICogLSBhIHJlYWwgbnVtYmVyLFxuICAgICAqIC0gYSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgcmVhbCBudW1iZXIsIG9yXG4gICAgICogLSBhIHN0cmluZyByZXByZXNlbnRpbmcgYSBsb2NhbGl6ZWQgbnVtYmVyICh3aXRoIHNwZWNpZmljIGdyb3VwIHNlcGFyYXRvcnMgYW5kIGRlY2ltYWwgY2hhcmFjdGVyKSxcbiAgICAgKiAuLi50byBhIHN0cmluZyByZXByZXNlbnRpbmcgYSByZWFsICdqYXZhc2NyaXB0JyBudW1iZXIgKGllLiAnMTIzNCcgb3IgJzEyMzQuNTY3JykuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYE5hTmAgaWYgc3VjaCBjb252ZXJzaW9uIGZhaWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR8ZmxvYXR8c3RyaW5nfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBzZXR0aW5nc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8TmFOfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTnVtZXJpY1ZhbHVlKHZhbHVlLCBzZXR0aW5ncykge1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBpZiAoaXNOdW1iZXIoTnVtYmVyKHZhbHVlKSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSB2YWx1ZSBoYXMgZWl0aGVyIGFscmVhZHkgYmVlbiBzdHJpcHBlZCwgb3IgYSAncmVhbCcgamF2YXNjcmlwdCBudW1iZXIgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gICAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEVsc2UgaWYgaXQncyBhIHN0cmluZyB0aGF0IGBOdW1iZXIoKWAgY2Fubm90IHR5cGVjYXN0LCB0aGVuIHdlIHRyeSB0byBjb252ZXJ0IHRoZSBsb2NhbGl6ZWQgbnVtZXJpYyBzdHJpbmcgdG8gYSBudW1lcmljIG9uZVxuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgdmFsdWUgdG8gYSBudW1lcmljIHN0cmluZywgc3RyaXBwaW5nIHVubmVjZXNzYXJ5IGNoYXJhY3RlcnMgaW4gdGhlIHByb2Nlc3NcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnZlcnRUb051bWVyaWNTdHJpbmcodmFsdWUudG9TdHJpbmcoKSwgc2V0dGluZ3MpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIHN0aWxsIG5vdCBhIG51bWVyaWMgc3RyaW5nLCB0aGVuIHdlIHRocm93IGEgd2FybmluZ1xuICAgICAgICAgICAgaWYgKCFpc051bWJlcihOdW1iZXIocmVzdWx0KSkpIHtcbiAgICAgICAgICAgICAgICB3YXJuaW5nKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nIFwic2V0XCIgaXMgbm90IG51bWVyaWMgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgdXNlZCBhcHByb3ByaWF0ZWx5LmAsIHNldHRpbmdzLnNob3dXYXJuaW5ncyk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gTmFOO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2RzIHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY1xuICAgICAqL1xuICAgIGNvbnN0IG1ldGhvZHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gaW5pdGlhbGl6ZSBhdXRvTnVtZXJpYyBhbmQgYXR0YWNoIHRoZSBzZXR0aW5ncyAob3B0aW9ucyBjYW4gYmUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyKVxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2RpZ2l0R3JvdXBTZXBhcmF0b3I6IFwiLlwiLCBkZWNpbWFsQ2hhcmFjdGVyOiBcIixcIiwgY3VycmVuY3lTeW1ib2w6ICfigqwgJ30pXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnaW5pdCcpOyAgICAgICAgICAgIC8vIEluaXRpYXRlIGF1dG9OdW1lcmljIHdpdGggZGVmYXVsdHNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCk7ICAgICAgICAgICAgICAgICAgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBkZWZhdWx0c1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2luaXQnLCB7b3B0aW9uc30pOyAvLyBJbml0aWF0ZSBhdXRvTnVtZXJpYyB3aXRoIG9wdGlvbnNcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKHtvcHRpb25zfSk7ICAgICAgICAgLy8gSW5pdGlhdGUgYXV0b051bWVyaWMgd2l0aCBvcHRpb25zXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqIEByZXR1cm5zIHsqfHtzdGF0ZW1lbnRzLCBicmFuY2hlcywgbGluZXMsIGZ1bmN0aW9ucywgZXhjbHVkZXMsIG92ZXJyaWRlc318e3N0YXRlbWVudHMsIGJyYW5jaGVzLCBsaW5lcywgZnVuY3Rpb25zLCBleGNsdWRlc318e3N0YXRlbWVudHMsIGxpbmVzLCBicmFuY2hlcywgZnVuY3Rpb25zLCBleGNsdWRlc319XG4gICAgICAgICAqL1xuICAgICAgICBpbml0KG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSAkKHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9IGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKCR0aGlzKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVsbChzZXR0aW5ncykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBBdXRvTnVtZXJpY0hvbGRlciBvYmplY3QgdGhhdCBzdG9yZSB0aGUgZmllbGQgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvbGRlciA9IGdldEF1dG9OdW1lcmljSG9sZGVyKCR0aGlzLCBzZXR0aW5ncywgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFzZXR0aW5ncy5ydW5PbmNlICYmIHNldHRpbmdzLmZvcm1hdE9uUGFnZUxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0RGVmYXVsdFZhbHVlT25QYWdlTG9hZChzZXR0aW5ncywgJGlucHV0LCAkdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2V0dGluZ3MucnVuT25jZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGV2ZW50cyBsaXN0ZW5lcnMgdG8gc3VwcG9ydGVkIGlucHV0IHR5cGVzIChcInRleHRcIiwgXCJoaWRkZW5cIiwgXCJ0ZWxcIiBhbmQgbm8gdHlwZSlcbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGUgPT4geyBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIGUgPT4geyBvbkZvY3VzSW5BbmRNb3VzZUVudGVyKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGUgPT4geyBvbkZvY3VzT3V0QW5kTW91c2VMZWF2ZSgkdGhpcywgaG9sZGVyLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBlID0+IHsgb25Gb2N1c091dEFuZE1vdXNlTGVhdmUoJHRoaXMsIGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZSA9PiB7IG9uS2V5ZG93bihob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBlID0+IHsgb25LZXlwcmVzcyhob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBlID0+IHsgb25LZXl1cChob2xkZXIsIHNldHRpbmdzLCBlKTsgfSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBlID0+IHsgb25CbHVyKGhvbGRlciwgZSk7IH0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIGUgPT4geyBvblBhc3RlKCR0aGlzLCBob2xkZXIsIGUpOyB9LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VibWl0KCR0aGlzLCBob2xkZXIpOyAvL1RPRE8gU3dpdGNoIHRvIGBhZGRFdmVudExpc3RlbmVyJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gc3RvcCBhbmQgcmVtb3ZlIGF1dG9OdW1lcmljIGZvciB0aGUgY3VycmVudCBlbGVtZW50LlxuICAgICAgICAgKiBOb3RlOiB0aGlzIGRvZXMgbm90IHJlbW92ZSB0aGUgZm9ybWF0dGluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKFwiZGVzdHJveVwiKTsgLy8gRGVzdHJveXMgYXV0b051bWVyaWMgb24gdGhpcyBzZWxlY3RlZCBlbGVtZW50XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHsqfGpRdWVyeX1cbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5yZW1vdmVEYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5vZmYoJy5hdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gY2xlYXIgdGhlIHZhbHVlIGZyb20gc2Vzc2lvblN0b3JhZ2UgKG9yIGNvb2tpZSwgZGVwZW5kaW5nIG9uIGJyb3dzZXIgc3VwcG9ydHMpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ3aXBlXCIpOyAvLyBSZW1vdmVzIHNlc3Npb24gc3RvcmFnZSBhbmQgY29va2llcyBmcm9tIG1lbW9yeVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICB3aXBlKCkge1xuICAgICAgICAgICAgcmV0dXJuICQodGhpcykuZWFjaChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gJHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy52YWwoJycpO1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3dpcGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRoYXQgdXBkYXRlcyB0aGUgYXV0b051bWVyaWMgc2V0dGluZ3MuXG4gICAgICAgICAqIEl0IGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgaWYgbmVlZGVkLlxuICAgICAgICAgKiBUaGUgb3B0aW9ucyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIgaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgdGhlIHNldHRpbmdzIChpZS4ge2RpZ2l0R3JvdXBTZXBhcmF0b3I6IFwiLlwiLCBkZWNpbWFsQ2hhcmFjdGVyOiBcIixcIiwgY3VycmVuY3lTeW1ib2w6ICfigqwgJ30pLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoXCJ1cGRhdGVcIiwge29wdGlvbnN9KTsgLy8gVXBkYXRlcyB0aGUgc2V0dGluZ3NcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdXBkYXRlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gUmV0cmlldmUgdGhlIGN1cnJlbnQgdW5mb3JtYXR0ZWQgaW5wdXQgdmFsdWVcbiAgICAgICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmlwID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBzZXR0aW5nc1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gZ2V0SW5pdGlhbFNldHRpbmdzKG9wdGlvbnMsICR0aGlzLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgQXV0b051bWVyaWNIb2xkZXIgb2JqZWN0IHRoYXQgc3RvcmUgdGhlIGZpZWxkIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBnZXRBdXRvTnVtZXJpY0hvbGRlcigkdGhpcywgc2V0dGluZ3MsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgLy8gUmVmb3JtYXQgdGhlIGlucHV0IHZhbHVlIHdpdGggdGhlIG5ldyBzZXR0aW5nc1xuICAgICAgICAgICAgICAgIGlmICgkdGhpcy52YWwoKSAhPT0gJycgfHwgJHRoaXMudGV4dCgpICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsIHN0cmlwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGZvcm1hdCB0aGUgdmFsdWUgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxuICAgICAgICAgKiBJZiB0aGUgdmFsdWUgaXMgcGFzc2VkIGFzIGEgc3RyaW5nLCBpdCBjYW4gYmUgYW4gaW50ZWdlciAnMTIzNCcgb3IgYSBkb3VibGUgJzEyMzQuNTY3ODknXG4gICAgICAgICAqIGFuZCBtdXN0IGNvbnRhaW4gb25seSBudW1iZXJzIGFuZCBvbmUgZGVjaW1hbCAocGVyaW9kKSBjaGFyYWN0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdzZXQnLCAnMTIzNDUuNjcnKTsgLy8gRm9ybWF0cyB0aGUgdmFsdWUgYmVpbmcgcGFzc2VkIGFzIHRoZSBzZWNvbmQgcGFyYW1ldGVyXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gbmV3VmFsdWVcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0KG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChuZXdWYWx1ZSA9PT0gbnVsbCB8fCBpc1VuZGVmaW5lZChuZXdWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vVE9ETyBUaGlzIGxvb2tzIGEgbG90IGxpa2UgYGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKClgLiBJcyB0aGF0IG5lY2Vzc2FyeT8gQ2FuIHRoZSBpbnB1dCBlbGVtZW50IGJlIGNoYW5nZWQgc2luY2UgYXV0b051bWVyaWMgaGFzIGJlZW4gaW5pdGlhbGl6ZWQ/XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihgSW5pdGlhbGl6aW5nIGF1dG9OdW1lcmljIGlzIHJlcXVpcmVkIHByaW9yIHRvIGNhbGxpbmcgdGhlIFwic2V0XCIgbWV0aG9kLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgdHJhaWxpbmcgbmVnYXRpdmUgc2V0dGluZ3MsIHNpbmNlIGl0J3MgcG9zc2libGUgdGhlIHByZXZpb3VzIHZhbHVlIHdhcyBuZWdhdGl2ZSwgYnV0IG5vdCB0aGUgbmV3bHkgc2V0IG9uZVxuICAgICAgICAgICAgICAgIHNldHRpbmdzLnRyYWlsaW5nTmVnYXRpdmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGNvbnN0ICRpbnB1dCA9ICR0aGlzLmlzKCdpbnB1dFt0eXBlPXRleHRdLCBpbnB1dFt0eXBlPWhpZGRlbl0sIGlucHV0W3R5cGU9dGVsXSwgaW5wdXQ6bm90KFt0eXBlXSknKTtcblxuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRvTnVtZXJpY1ZhbHVlKG5ld1ZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFttaW5UZXN0LCBtYXhUZXN0XSA9IGNoZWNrSWZJblJhbmdlV2l0aE92ZXJyaWRlT3B0aW9uKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgdGVzdCBpcyBuZWVkZWQgYnkgdGhlIHNob3dQb3NpdGl2ZVNpZ24gb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzWmVybyA9IGlzWmVyb09ySGFzTm9WYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJzAnO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblRlc3QgJiYgbWF4VGVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCRpbnB1dCB8fCBpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gZW5zdXJlIHJvdW5kaW5nIGRvZXMgbm90IGhhcHBlbiB0d2ljZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBoYXNCZWVuUm91bmRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcm91bmRzIHRoZSB0aGUgZXh0ZW5kZWQgZGVjaW1hbCBwbGFjZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wRGVjaW1hbCA9IHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc0JlZW5Sb3VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gdGVtcERlY2ltYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnNjYWxlRGl2aXNvciAmJiAhc2V0dGluZ3Mub25PZmYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0b051bWVyaWNWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlIC8gc2V0dGluZ3Muc2NhbGVEaXZpc29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zY2FsZURlY2ltYWxQbGFjZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBEZWNpbWFsID0gc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MuZGVjaW1hbFBsYWNlc092ZXJyaWRlID0gc2V0dGluZ3Muc2NhbGVEZWNpbWFsUGxhY2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSByb3VuZFZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNCZWVuUm91bmRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUgPSB0ZW1wRGVjaW1hbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdW5kcyBpZiB0aGlzIGhhcyBub3QgYmVlbiBkb25lIGFscmVhZHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWhhc0JlZW5Sb3VuZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gcm91bmRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlcyByYXdWYWx1ZSBpbmNsdWRpbmcgdGhlIGRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5yYXdWYWx1ZSA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModmFsdWUucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gYWRkR3JvdXBTZXBhcmF0b3JzKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlICYmIChzZXR0aW5ncy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzIHx8IHNldHRpbmdzLnNjYWxlRGl2aXNvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlVmFsdWVUb1BlcnNpc3RlbnRTdG9yYWdlKCR0aGlzWzBdLCBzZXR0aW5ncywgJ3NldCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGluZ3MucmF3VmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNhdmVWYWx1ZVRvUGVyc2lzdGVudFN0b3JhZ2UoJHRoaXNbMF0sIHNldHRpbmdzLCAnd2lwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0ZW1wdGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1pblRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptaW5FeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1heFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdGhpcy50cmlnZ2VyKCdhdXRvTnVtZXJpYzptYXhFeGNlZWRlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7YXR0ZW1wdGVkVmFsdWV9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgbWluaW11bVZhbHVlIFske3NldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtVmFsdWUgWyR7c2V0dGluZ3MubWF4aW11bVZhbHVlfV0gcmFuZ2Ugc2V0IGZvciB0aGlzIGVsZW1lbnRgKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICR0aGlzLnZhbCgnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJHRoaXMudmFsKCcnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIXNldHRpbmdzLmhhc0ZvY3VzICYmIHNldHRpbmdzLnNjYWxlU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgKyBzZXR0aW5ncy5zY2FsZVN5bWJvbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoJGlucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy52YWwodmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkdGhpcy50ZXh0KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHVuLWZvcm1hdCBpbnB1dHMuXG4gICAgICAgICAqIFRoaXMgaXMgaGFuZHkgdG8gdXNlIHJpZ2h0IGJlZm9yZSBmb3JtIHN1Ym1pc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEJ5IGRlZmF1bHQsIHZhbHVlcyBhcmUgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5ncyAoaWUuIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiksIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZC5cbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIsIG9yIGV2ZW4gcGxhaW4gbnVtYmVycy5cbiAgICAgICAgICogUGxlYXNlIHNlZSBvcHRpb24gXCJvdXRwdXRGb3JtYXRcIiBmb3IgbW9yZSBkZXRhaWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBleGFtcGxlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygndW5TZXQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp8alF1ZXJ5fVxuICAgICAgICAgKi9cbiAgICAgICAgdW5TZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJCh0aGlzKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0ICR0aGlzID0gZ2V0Q3VycmVudEVsZW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3MgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldHRpbmdzLmhhc0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMudmFsKCR0aGlzLmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byByZS1mb3JtYXQgaW5wdXRzLlxuICAgICAgICAgKiBUaGlzIGlzIGhhbmR5IHRvIHVzZSByaWdodCBhZnRlciBmb3JtIHN1Ym1pc3Npb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgY2FsbGVkIGFmdGVyIHRoZSAndW5TZXQnIG1ldGhvZCB0byByZWZvcm1hdCB0aGUgaW5wdXRcbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGUgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdyZVNldCcpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7KnxqUXVlcnl9XG4gICAgICAgICAqL1xuICAgICAgICByZVNldCgpIHtcbiAgICAgICAgICAgIHJldHVybiAkKHRoaXMpLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYXV0b051bWVyaWMoJ3NldCcsICR0aGlzLnZhbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHVzYWdlICQoc29tZVNlbGVjdG9yKS5hdXRvTnVtZXJpYygnZ2V0Jyk7XG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAvL1RPRE8gV2h5IHdvdWxkIHdlIG5lZWQgdG8gZ2V0IGEgbmV3IHJlZmVyZW5jZSB0byAkdGhpcyBzaW5jZSBpdCBoYXMgYmVlbiBkb25lIGluIGBpbml0KClgP1xuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgIC8vVE9ETyBUaGlzIGxvb2tzIGEgbG90IGxpa2UgYGdldElucHV0SWZTdXBwb3J0ZWRUYWdBbmRUeXBlKClgLiBJcyB0aGF0IG5lY2Vzc2FyeT8gQ2FuIHRoZSBpbnB1dCBlbGVtZW50IGJlIGNoYW5nZWQgc2luY2UgYXV0b051bWVyaWMgaGFzIGJlZW4gaW5pdGlhbGl6ZWQ/XG4gICAgICAgICAgICBjb25zdCAkaW5wdXQgPSAkdGhpcy5pcygnaW5wdXRbdHlwZT10ZXh0XSwgaW5wdXRbdHlwZT1oaWRkZW5dLCBpbnB1dFt0eXBlPXRlbF0sIGlucHV0Om5vdChbdHlwZV0pJyk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICR0aGlzLmRhdGEoJ2F1dG9OdW1lcmljJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNldHRpbmdzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYEluaXRpYWxpemluZyBhdXRvTnVtZXJpYyBpcyByZXF1aXJlZCBwcmlvciB0byBjYWxsaW5nIHRoZSBcImdldFwiIG1ldGhvZC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZGV0ZXJtaW5lIHRoZSBlbGVtZW50IHR5cGUgdGhlbiB1c2UgLmVxKDApIHNlbGVjdG9yIHRvIGdyYWIgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluIHNlbGVjdG9yXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgICAgIGlmICgkaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICR0aGlzLmVxKDApLnZhbCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0luQXJyYXkoJHRoaXMucHJvcCgndGFnTmFtZScpLnRvTG93ZXJDYXNlKCksIHNldHRpbmdzLnRhZ0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAkdGhpcy5lcSgwKS50ZXh0KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBcIjwkeyR0aGlzLnByb3AoJ3RhZ05hbWUnKS50b0xvd2VyQ2FzZSgpfT5cIiB0YWcgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cyB8fCBzZXR0aW5ncy5zY2FsZURpdmlzb3IpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHNldHRpbmdzLnJhd1ZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUZXN0IGlmIHRoZSB2YWx1ZSBpcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzVmFsdWVOZWdhdGl2ZSA9IGlzTmVnYXRpdmUodmFsdWUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCEoL1xcZC8pLnRlc3QodmFsdWUpICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ2ZvY3VzJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAnJyAmJiBzZXR0aW5ncy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXR0aW5ncy5oYXNGb2N1cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG9nZ2xlTmVnYXRpdmVCcmFja2V0KHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJ1bk9uY2UgfHwgc2V0dGluZ3MuZm9ybWF0T25QYWdlTG9hZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXBzIHRyYWlsaW5nIG5lZ2F0aXZlIHN5bWJvbFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHN0cmlwQWxsTm9uTnVtYmVyQ2hhcmFjdGVycyh2YWx1ZSwgc2V0dGluZ3MsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmltcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB6ZXJvcyB3aGVuIGxlYWRpbmdaZXJvIGRvZXMgTk9UIGVxdWFsIFwia2VlcFwiLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGNsZWFuTGVhZGluZ1RyYWlsaW5nWmVyb3ModmFsdWUucmVwbGFjZShzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyLCAnLicpLCBzZXR0aW5ncyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUGxhY2VzIHRoZSBuZWdhdGl2ZSBzeW1ib2wgaW4gZnJvbnQgb2YgdGhlIHRyYWlsaW5nIG5lZ2F0aXZlXG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy50cmFpbGluZ05lZ2F0aXZlICYmIGlzVmFsdWVOZWdhdGl2ZSAmJiAhaXNOZWdhdGl2ZSh2YWx1ZSkgJiYgTnVtYmVyKHZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnLScgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gJycgfHwgdmFsdWUgPT09ICcnICYmIHNldHRpbmdzLmVtcHR5SW5wdXRCZWhhdmlvciA9PT0gJ3plcm8nKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gbW9kaWZ5TmVnYXRpdmVTaWduQW5kRGVjaW1hbENoYXJhY3RlckZvclJhd1ZhbHVlKHZhbHVlLCBzZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGEgbnVtZXJpYyBzdHJpbmdcbiAgICAgICAgICAgIC8vIFRoaXMgZ2V0cyByaWQgb2YgdGhlIHRyYWlsaW5nIHplcm9zIGluIHRoZSBkZWNpbWFsIHBsYWNlcyBzaW5jZSBgZ2V0YCBkb2VzIG5vdCBwYWQgZGVjaW1hbHNcbiAgICAgICAgICAgIHJldHVybiB0cmltUGFkZGVkWmVyb3NGcm9tRGVjaW1hbFBsYWNlcyh2YWx1ZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHZhbHVlLCBidXQgZm9sbG93aW5nIHRoZSBgb3V0cHV0Rm9ybWF0YCBzZXR0aW5nLCB3aGljaCBtZWFucyB0aGUgb3V0cHV0IGNhbiBlaXRoZXIgYmUgOlxuICAgICAgICAgKiAtIGEgc3RyaW5nICh0aGF0IGNvdWxkIG9yIGNvdWxkIG5vdCByZXByZXNlbnQgYSBudW1iZXIgKGllLiBcIjEyMzQ1LDY3LVwiKSksIG9yXG4gICAgICAgICAqIC0gYSBwbGFpbiBudW1iZXIgKGlmIHRoZSBzZXR0aW5nICdudW1iZXInIGlzIHVzZWQpLlxuICAgICAgICAgKlxuICAgICAgICAgKiBCeSBkZWZhdWx0IHRoZSByZXR1cm5lZCB2YWx1ZXMgYXJlIGFuIElTTyBudW1lcmljIHN0cmluZyBcIjEyMzQuNTZcIiBvciBcIi0xMjM0LjU2XCIgd2hlcmUgdGhlIGRlY2ltYWwgY2hhcmFjdGVyIGlzIGEgcGVyaW9kLlxuICAgICAgICAgKiBDaGVjayB0aGUgXCJvdXRwdXRGb3JtYXRcIiBvcHRpb24gZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdXNhZ2UgJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRMb2NhbGl6ZWQnKTtcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMb2NhbGl6ZWQoKSB7XG4gICAgICAgICAgICBjb25zdCAkdGhpcyA9IGdldEN1cnJlbnRFbGVtZW50KHRoaXMpO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuICAgICAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAkdGhpcy5kYXRhKCdhdXRvTnVtZXJpYycpO1xuXG4gICAgICAgICAgICBpZiAoTnVtYmVyKHZhbHVlKSA9PT0gMCAmJiBzZXR0aW5ncy5sZWFkaW5nWmVybyAhPT0gJ2tlZXAnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAnMCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0b0xvY2FsZSh2YWx1ZSwgc2V0dGluZ3Mub3V0cHV0Rm9ybWF0KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBpbnB1dCB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIHJlYWwgSmF2YXNjcmlwdCBudW1iZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB1c2FnZSAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldE51bWJlcicpO1xuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TnVtYmVyKCkge1xuICAgICAgICAgICAgY29uc3QgJHRoaXMgPSBnZXRDdXJyZW50RWxlbWVudCh0aGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gJHRoaXMuYXV0b051bWVyaWMoJ2dldCcpO1xuXG4gICAgICAgICAgICByZXR1cm4gdG9Mb2NhbGUodmFsdWUsICdudW1iZXInKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJuIHRoZSBjdXJyZW50IGZvcm1hdHRlZCB2YWx1ZSBvZiB0aGUgYXV0b051bWVyaWMgZWxlbWVudC5cbiAgICAgICAgICogQHVzYWdlIGFOSW5wdXQuYXV0b051bWVyaWMoJ2dldEZvcm1hdHRlZCcpKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0Rm9ybWF0dGVkKCkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGB0aGlzWzBdYCBleGlzdHMgYXMgd2VsbCBhcyBgLnZhbHVlYCBiZWZvcmUgdHJ5aW5nIHRvIGFjY2VzcyB0aGF0IHByb3BlcnR5XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJzAnKSB8fCAhKCd2YWx1ZScgaW4gdGhpc1swXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKCdVbmFibGUgdG8gZ2V0IHRoZSBmb3JtYXR0ZWQgc3RyaW5nIGZyb20gdGhlIGVsZW1lbnQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzWzBdLnZhbHVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgXCJnZXRTdHJpbmdcIiBtZXRob2QgdXNlcyBqUXVlcnkncyAuc2VyaWFsaXplKCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhIHRleHQgc3RyaW5nIGluIHN0YW5kYXJkIFVSTC1lbmNvZGVkIG5vdGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJdCB0aGVuIGxvb3BzIHRocm91Z2ggdGhlIHN0cmluZyBhbmQgdW4tZm9ybWF0cyB0aGUgaW5wdXRzIHdpdGggYXV0b051bWVyaWMuXG4gICAgICAgICAqIEJ5IGRlZmF1bHRzIHZhbHVlcyByZXR1cm5lZCBhcyBJU08gbnVtZXJpYyBzdHJpbmcgXCIxMjM0LjU2XCIgb3IgXCItMTIzNC41NlwiIHdoZXJlIHRoZSBkZWNpbWFsIGNoYXJhY3RlciBpcyBhIHBlcmlvZFxuICAgICAgICAgKiBMb2NhbGUgZm9ybWF0cyBhcmUgc3VwcG9ydGVkIFwiMTIzNC41Ni1cIiBvciBcIjEyMzQsNTZcIiBvciBcIi0xMjM0LDU2IG9yIFwiMTIzNCw1Ni1cIiBvciBwbGFpbiBudW1iZXJzID0+IHBsZWFzZSBzZWUgb3B0aW9uIFwib3V0cHV0Rm9ybWF0XCIgZm9yIGRldGFpbHNcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGdldFN0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBfZ2V0U3RyaW5nT3JBcnJheShmYWxzZSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBcImdldEFycmF5XCIgbWV0aG9kIG9uIHRoZSBvdGhlciBoYW5kIHVzZXMgalF1ZXJ5J3MgLnNlcmlhbGl6ZUFycmF5KCkgbWV0aG9kIHRoYXQgY3JlYXRlcyBhcnJheSBvciBvYmplY3RzIHRoYXQgY2FuIGJlIGVuY29kZWQgYXMgYSBKU09OIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgdGhlbiBsb29wcyB0aHJvdWdoIHRoZSBzdHJpbmcgYW5kIHVuLWZvcm1hdHMgdGhlIGlucHV0cyB3aXRoIGF1dG9OdW1lcmljLlxuICAgICAgICAgKiBCeSBkZWZhdWx0cyB2YWx1ZXMgcmV0dXJuZWQgYXMgSVNPIG51bWVyaWMgc3RyaW5nIFwiMTIzNC41NlwiIG9yIFwiLTEyMzQuNTZcIiB3aGVyZSB0aGUgZGVjaW1hbCBjaGFyYWN0ZXIgaXMgYSBwZXJpb2RcbiAgICAgICAgICogTG9jYWxlIGZvcm1hdHMgYXJlIHN1cHBvcnRlZCBcIjEyMzQuNTYtXCIgb3IgXCIxMjM0LDU2XCIgb3IgXCItMTIzNCw1NiBvciBcIjEyMzQsNTYtXCIgb3IgcGxhaW4gbnVtYmVycyA9PiBwbGVhc2Ugc2VlIG9wdGlvbiBcIm91dHB1dEZvcm1hdFwiIGZvciBkZXRhaWxzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHt7fXxbXX1cbiAgICAgICAgICovXG4gICAgICAgIGdldEFycmF5KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9nZXRTdHJpbmdPckFycmF5KHRydWUsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgJ2dldFNldHRpbmdzJyBmdW5jdGlvbiByZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgY3VycmVudCBhdXRvTnVtZXJpYyBzZXR0aW5ncy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogJChzb21lU2VsZWN0b3IpLmF1dG9OdW1lcmljKCdnZXRTZXR0aW5ncycpO1xuICAgICAgICAgKiAkKHNvbWVTZWxlY3RvcikuYXV0b051bWVyaWMoJ2dldFNldHRpbmdzJykuZGVjaW1hbENoYXJhY3RlcjsgLy8gUmV0dXJuIHRoZSBkZWNpbWFsQ2hhcmFjdGVyIHNldHRpbmcgYXMgYSBzdHJpbmcgLSBhbnkgdmFsaWQgb3B0aW9uIG5hbWUgY2FuIGJlIHVzZWRcbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICAgICAgLy9UT0RPIEFkZCBhbiBvcHRpb24gYXJndW1lbnQgYG9wdGlvbk5hbWVgIHRvIHRoaXMgZnVuY3Rpb24gc28gdGhhdCBpdCByZXR1cm4gb25seSB0aGUgdmFsdWUgb2YgdGhhdCBvcHRpb24sIG5vdCB0aGUgZW50aXJlIHNldHRpbmdzIG9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSgnYXV0b051bWVyaWMnKTtcbiAgICAgICAgfSxcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGF1dG9OdW1lcmljIGZ1bmN0aW9uIGFjY2VwdHMgbWV0aG9kcyBuYW1lcyAoaW4gc3RyaW5nIGZvcm1hdCkgYW5kIHRob3NlIG1ldGhvZCBwYXJhbWV0ZXJzIGlmIG5lZWRlZC5cbiAgICAgKiBJdCBpbml0aWFsaXplIGF1dG9OdW1lcmljIG9uIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZCBUaGUgbWV0aG9kIG5hbWUgKGllLiAnc2V0JywgJ2dldCcsIGV0Yy4pXG4gICAgICogQHBhcmFtIHsqfSBhcmdzXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgJC5mbi5hdXRvTnVtZXJpYyA9IGZ1bmN0aW9uKG1ldGhvZCwgLi4uYXJncykge1xuICAgICAgICBpZiAobWV0aG9kc1ttZXRob2RdKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kc1ttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdvYmplY3QnIHx8ICFtZXRob2QpIHtcbiAgICAgICAgICAgIC8vIFRoZSBvcHRpb25zIGhhdmUgYmVlbiBwYXNzZWQgZGlyZWN0bHksIHdpdGhvdXQgdXNpbmcgYSBuYW1lZCBtZXRob2RcbiAgICAgICAgICAgIHJldHVybiBtZXRob2RzLmluaXQuYXBwbHkodGhpcywgW21ldGhvZF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3dFcnJvcihgTWV0aG9kIFwiJHttZXRob2R9XCIgaXMgbm90IHN1cHBvcnRlZCBieSBhdXRvTnVtZXJpY2ApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGRlZmF1bHQgYXV0b051bWVyaWMgc2V0dGluZ3MuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldERlZmF1bHRDb25maWcgPSAoKSA9PiBkZWZhdWx0U2V0dGluZ3M7XG5cbiAgICAkLmZuLmF1dG9OdW1lcmljLmRlZmF1bHRzID0gZGVmYXVsdFNldHRpbmdzOyAvLyBNYWtlIHRob3NlIHNldHRpbmdzIHB1YmxpYyB2aWEgalF1ZXJ5IHRvby5cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbGwgdGhlIHByZWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucyBpbiBvbmUgb2JqZWN0LlxuICAgICAqIFlvdSBjYW4gYWxzbyBhY2Nlc3MgYSBzcGVjaWZpYyBsYW5ndWFnZSBvYmplY3QgZGlyZWN0bHkgYnkgdXNpbmcgYGFuLmdldExhbmd1YWdlcygpLkZyZW5jaGAgZm9yIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRMYW5ndWFnZXMgPSAoKSA9PiBsYW5ndWFnZU9wdGlvbjtcblxuICAgICQuZm4uYXV0b051bWVyaWMubGFuZyA9IGxhbmd1YWdlT3B0aW9uOyAvLyBNYWtlIHRob3NlIHByZWRlZmluZWQgbGFuZ3VhZ2Ugb3B0aW9ucyBwdWJsaWMgdmlhIGpRdWVyeSB0b28uXG5cbiAgICAvKipcbiAgICAgKiBQdWJsaWMgZnVuY3Rpb24gdGhhdCBhbGxvd3MgZm9ybWF0dGluZyB3aXRob3V0IGFuIGVsZW1lbnQgdHJpZ2dlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gdmFsdWUgQSBudW1iZXIsIG9yIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50IGEgamF2YXNjcmlwdCBudW1iZXJcbiAgICAgKiBAcGFyYW0ge29iamVjdHxudWxsfSBvcHRpb25zXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgYXV0b0Zvcm1hdCA9ICh2YWx1ZSwgb3B0aW9ucyA9IG51bGwpID0+IHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU3RyaW5nKHZhbHVlKSAmJiAhaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgXCIke3ZhbHVlfVwiIGJlaW5nIFwic2V0XCIgaXMgbm90IG51bWVyaWMgYW5kIHRoZXJlZm9yZSBjYW5ub3QgYmUgdXNlZCBhcHByb3ByaWF0ZWx5LmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSW5pdGlhdGUgYSB2ZXJ5IGJhc2ljIHNldHRpbmdzIG9iamVjdFxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCBkZWZhdWx0U2V0dGluZ3MsIHsgc3RyaXA6IGZhbHNlIH0sIG9wdGlvbnMpO1xuICAgICAgICBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICBzZXR0aW5ncy5uZWdhdGl2ZVNpZ25DaGFyYWN0ZXIgPSAnLSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNOdWxsKHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLmRlY2ltYWxQbGFjZXNPdmVycmlkZSA9IG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgoc2V0dGluZ3MubWluaW11bVZhbHVlLCBzZXR0aW5ncy5tYXhpbXVtVmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgdGhlIHZhbGlkaXR5IG9mIHRoZSBgdmFsdWVgIHBhcmFtZXRlclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSB2YWx1ZSB0byBhIG51bWVyaWMgc3RyaW5nLCBzdHJpcHBpbmcgdW5uZWNlc3NhcnkgY2hhcmFjdGVycyBpbiB0aGUgcHJvY2Vzc1xuICAgICAgICBsZXQgdmFsdWVTdHJpbmcgPSB0b051bWVyaWNWYWx1ZSh2YWx1ZSwgc2V0dGluZ3MpO1xuICAgICAgICBpZiAoaXNOYU4odmFsdWVTdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWVTdHJpbmd9XSB0aGF0IHlvdSBhcmUgdHJ5aW5nIHRvIGZvcm1hdCBpcyBub3QgYSByZWNvZ25pemVkIG51bWJlci5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJhc2ljIHRlc3RzIHRvIGNoZWNrIGlmIHRoZSBnaXZlbiB2YWx1ZVN0cmluZyBpcyB2YWxpZFxuICAgICAgICBjb25zdCBbbWluVGVzdCwgbWF4VGVzdF0gPSBjaGVja0lmSW5SYW5nZVdpdGhPdmVycmlkZU9wdGlvbih2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xuICAgICAgICBpZiAoIW1pblRlc3QgfHwgIW1heFRlc3QpIHtcbiAgICAgICAgICAgIC8vIFRocm93IGEgY3VzdG9tIGV2ZW50XG4gICAgICAgICAgICB0cmlnZ2VyRXZlbnQoJ2F1dG9Gb3JtYXQuYXV0b051bWVyaWMnLCBkb2N1bWVudCwgYFJhbmdlIHRlc3QgZmFpbGVkYCk7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgdmFsdWUgWyR7dmFsdWVTdHJpbmd9XSBiZWluZyBzZXQgZmFsbHMgb3V0c2lkZSBvZiB0aGUgbWluaW11bVZhbHVlIFske3NldHRpbmdzLm1pbmltdW1WYWx1ZX1dIGFuZCBtYXhpbXVtVmFsdWUgWyR7c2V0dGluZ3MubWF4aW11bVZhbHVlfV0gcmFuZ2Ugc2V0IGZvciB0aGlzIGVsZW1lbnRgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV2ZXJ5dGhpbmcgaXMgb2ssIHByb2NlZWQgdG8gcm91bmRpbmcsIGZvcm1hdHRpbmcgYW5kIGdyb3VwaW5nXG4gICAgICAgIHZhbHVlU3RyaW5nID0gcm91bmRWYWx1ZSh2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZVN0cmluZyA9IG1vZGlmeU5lZ2F0aXZlU2lnbkFuZERlY2ltYWxDaGFyYWN0ZXJGb3JGb3JtYXR0ZWRWYWx1ZSh2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xuICAgICAgICB2YWx1ZVN0cmluZyA9IGFkZEdyb3VwU2VwYXJhdG9ycyh2YWx1ZVN0cmluZywgc2V0dGluZ3MpO1xuXG4gICAgICAgIHJldHVybiB2YWx1ZVN0cmluZztcbiAgICB9O1xuXG4gICAgJC5mbi5hdXRvRm9ybWF0ID0gYXV0b0Zvcm1hdDsgLy8gVGhlIGpRdWVyeSBleHBvcnRcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBmdW5jdGlvbiB0aGF0IGFsbG93cyB1bmZvcm1hdHRpbmcgd2l0aG91dCBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgYXV0b1VuRm9ybWF0ID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh2YWx1ZSkgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2l2aW5nIGFuIHVuZm9ybWF0dGVkIHZhbHVlIHNob3VsZCByZXR1cm4gdGhlIHNhbWUgdW5mb3JtYXR0ZWQgdmFsdWUsIHdoYXRldmVyIHRoZSBvcHRpb25zIHBhc3NlZCBhcyBhIHBhcmFtZXRlclxuICAgICAgICBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0FycmF5KHZhbHVlKSB8fCBpc09iamVjdCh2YWx1ZSkpIHsgLy9UT0RPIENvbXBsZXRlIHRoZSB0ZXN0IHRvIHRocm93IHdoZW4gZ2l2ZW4gYSB3cm9uZ2x5IGZvcm1hdHRlZCBudW1iZXIgKGllLiAnZm9vYmFyJylcbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSB2YWxpZGl0eSBvZiB0aGUgYHZhbHVlYCBwYXJhbWV0ZXJcbiAgICAgICAgICAgIHRocm93RXJyb3IoYEEgbnVtYmVyIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhIG51bWJlciBpcyBuZWVkZWQgdG8gYmUgYWJsZSB0byB1bmZvcm1hdCBpdCwgWyR7dmFsdWV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgeyBzdHJpcDogZmFsc2UgfSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGFsbG93ZWQgPSBgLTAxMjM0NTY3ODlcXFxcJHtzZXR0aW5ncy5kZWNpbWFsQ2hhcmFjdGVyfWA7XG4gICAgICAgIGNvbnN0IGF1dG9TdHJpcCA9IG5ldyBSZWdFeHAoYFteJHthbGxvd2VkfV1gLCAnZ2knKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuXG4gICAgICAgIC8vIFRoaXMgY2hlY2tzIGlzIGEgbmVnYXRpdmUgc2lnbiBpcyBhbnl3aGVyZSBpbiB0aGUgYHZhbHVlYCwgbm90IGp1c3Qgb24gdGhlIHZlcnkgZmlyc3QgY2hhcmFjdGVyIChpZS4gJzEyMzQ1LjY3LScpXG4gICAgICAgIGlmIChpc05lZ2F0aXZlKHZhbHVlKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyICYmIHNldHRpbmdzLm5lZ2F0aXZlQnJhY2tldHNUeXBlT25CbHVyLnNwbGl0KCcsJylbMF0gPT09IHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgc2V0dGluZ3MubmVnYXRpdmVTaWduQ2hhcmFjdGVyID0gJy0nO1xuICAgICAgICAgICAgc2V0dGluZ3MuaGFzRm9jdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFsdWUgPSB0b2dnbGVOZWdhdGl2ZUJyYWNrZXQodmFsdWUsIHNldHRpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShhdXRvU3RyaXAsICcnKTtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHNldHRpbmdzLmRlY2ltYWxDaGFyYWN0ZXIsICcuJyk7XG4gICAgICAgIHZhbHVlID0gdG9Mb2NhbGUodmFsdWUsIHNldHRpbmdzLm91dHB1dEZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG5cbiAgICAkLmZuLmF1dG9VbmZvcm1hdCA9IGF1dG9VbkZvcm1hdDsgLy8gVGhlIGpRdWVyeSBleHBvcnRcblxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlIHRoZSBnaXZlbiBvcHRpb24gb2JqZWN0LlxuICAgICAqIElmIHRoZSBvcHRpb25zIGFyZSB2YWxpZCwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIG5vdGhpbmcsIG90aGVyd2lzZSBpZiB0aGUgb3B0aW9ucyBhcmUgaW52YWxpZCwgdGhpcyBmdW5jdGlvbiB0aHJvd3MgYW4gZXJyb3IuXG4gICAgICpcbiAgICAgKiBUaGlzIHRlc3RzIGlmIHRoZSBvcHRpb25zIGFyZSBub3QgY29uZmxpY3RpbmcgYW5kIGFyZSB3ZWxsIGZvcm1hdHRlZC5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxlbmllbnQgc2luY2UgaXQgb25seSB0ZXN0cyB0aGUgc2V0dGluZ3MgcHJvcGVydGllcyA7IGl0IGlnbm9yZXMgYW55IG90aGVyIHByb3BlcnRpZXMgdGhlIG9wdGlvbnMgb2JqZWN0IGNvdWxkIGhhdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHVzZXJPcHRpb25zXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBzaG91bGRFeHRlbmREZWZhdWx0T3B0aW9ucyBJZiBUUlVFLCB0aGVuIHRoaXMgZnVuY3Rpb24gd2lsbCBleHRlbmRzIHRoZSBgdXNlck9wdGlvbnNgIHBhc3NlZCBieSB0aGUgdXNlciwgd2l0aCB0aGUgZGVmYXVsdCBvcHRpb25zLlxuICAgICAqIEB0aHJvd3MgRXJyb3JcbiAgICAgKi9cbiAgICB2YWxpZGF0ZSA9ICh1c2VyT3B0aW9ucywgc2hvdWxkRXh0ZW5kRGVmYXVsdE9wdGlvbnMgPSB0cnVlKSA9PiB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZE9yTnVsbE9yRW1wdHkodXNlck9wdGlvbnMpIHx8ICFpc09iamVjdCh1c2VyT3B0aW9ucykgfHwgaXNFbXB0eU9iaih1c2VyT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB1c2VyT3B0aW9ucyBhcmUgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHZhbGlkIG9iamVjdCwgWyR7dXNlck9wdGlvbnN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoZSB1c2VyIHVzZWQgb2xkIG9wdGlvbnMsIHdlIGNvbnZlcnQgdGhlbSB0byBuZXcgb25lc1xuICAgICAgICBpZiAoIWlzTnVsbCh1c2VyT3B0aW9ucykpIHtcbiAgICAgICAgICAgIGNvbnZlcnRPbGRPcHRpb25zVG9OZXdPbmVzKHVzZXJPcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSB1c2VyIGNhbiBjaG9vc2UgaWYgdGhlIGB1c2VyT3B0aW9uc2AgaGFzIGFscmVhZHkgYmVlbiBleHRlbmRlZCB3aXRoIHRoZSBkZWZhdWx0IG9wdGlvbnMsIG9yIG5vdFxuICAgICAgICBsZXQgb3B0aW9ucztcbiAgICAgICAgaWYgKHNob3VsZEV4dGVuZERlZmF1bHRPcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gJC5leHRlbmQoe30sIGRlZmF1bHRTZXR0aW5ncywgdXNlck9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHVzZXJPcHRpb25zO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgdGhpbmdzIGZpcnN0LCB3ZSB0ZXN0IHRoYXQgdGhlIGBzaG93V2FybmluZ3NgIG9wdGlvbiBpcyB2YWxpZFxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zaG93V2FybmluZ3MpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zaG93V2FybmluZ3MpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGVidWcgb3B0aW9uICdzaG93V2FybmluZ3MnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNob3dXYXJuaW5nc31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zIG5lZWRlZCBmb3IgdGhlIGZvbGxvd2luZyB0ZXN0c1xuICAgICAgICBjb25zdCB0ZXN0UG9zaXRpdmVJbnRlZ2VyID0gL15bMC05XSskLztcbiAgICAgICAgY29uc3QgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMgPSAvWzAtOV0rLztcbiAgICAgICAgLy8gY29uc3QgdGVzdEZsb2F0QW5kUG9zc2libGVOZWdhdGl2ZVNpZ24gPSAvXi0/WzAtOV0rKFxcLj9bMC05XSspJC87XG4gICAgICAgIGNvbnN0IHRlc3RGbG9hdE9ySW50ZWdlckFuZFBvc3NpYmxlTmVnYXRpdmVTaWduID0gL14tP1swLTldKyhcXC4/WzAtOV0rKT8kLztcbiAgICAgICAgY29uc3QgdGVzdFBvc2l0aXZlRmxvYXRPckludGVnZXIgPSAvXlswLTldKyhcXC4/WzAtOV0rKT8kLztcblxuICAgICAgICAvLyBUaGVuIHRlc3RzIHRoZSBvcHRpb25zIGluZGl2aWR1YWxseVxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IsIFtcbiAgICAgICAgICAgICcsJywgICAgICAvLyBDb21tYVxuICAgICAgICAgICAgJy4nLCAgICAgIC8vIERvdFxuICAgICAgICAgICAgJyAnLCAgICAgIC8vIE5vcm1hbCBzcGFjZVxuICAgICAgICAgICAgJ1xcdTIwMDknLCAvLyBUaGluLXNwYWNlXG4gICAgICAgICAgICAnXFx1MjAyZicsIC8vIE5hcnJvdyBuby1icmVhayBzcGFjZVxuICAgICAgICAgICAgJ1xcdTAwYTAnLCAvLyBOby1icmVhayBzcGFjZVxuICAgICAgICAgICAgJycsICAgICAgIC8vIE5vIHNlcGFyYXRvclxuICAgICAgICAgICAgXCInXCIsICAgICAgLy8gQXBvc3Ryb3BoZVxuICAgICAgICAgICAgJ9msJywgICAgICAvLyBBcmFiaWMgdGhvdXNhbmRzIHNlcGFyYXRvclxuICAgICAgICAgICAgJ8uZJywgICAgICAvLyBEb3QgYWJvdmVcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB0aG91c2FuZCBzZXBhcmF0b3IgY2hhcmFjdGVyIG9wdGlvbiAnZGlnaXRHcm91cFNlcGFyYXRvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSAnLCcsICcuJywgJ9msJywgJ8uZJywgXCInXCIsICcgJywgJ1xcdTIwMDknLCAnXFx1MjAyZicsICdcXHUwMGEwJyBvciBlbXB0eSAoJycpLCBbJHtvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3J9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1cykgJiYgIWlzQm9vbGVhbihvcHRpb25zLm5vU2VwYXJhdG9yT25Gb2N1cykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSAnbm9TZXBhcmF0b3JPbkZvY3VzJyBvcHRpb24gaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMubm9TZXBhcmF0b3JPbkZvY3VzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRpZ2l0YWxHcm91cFNwYWNpbmcpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlnaXRhbCBncm91cGluZyBmb3IgdGhvdXNhbmQgc2VwYXJhdG9yIG9wdGlvbiAnZGlnaXRhbEdyb3VwU3BhY2luZycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZGlnaXRhbEdyb3VwU3BhY2luZ31dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyLCBbXG4gICAgICAgICAgICAnLCcsIC8vIENvbW1hXG4gICAgICAgICAgICAnLicsIC8vIERvdFxuICAgICAgICAgICAgJ8K3JywgLy8gTWlkZGxlLWRvdFxuICAgICAgICAgICAgJ9mrJywgLy8gQXJhYmljIGRlY2ltYWwgc2VwYXJhdG9yXG4gICAgICAgICAgICAn4o6WJywgLy8gRGVjaW1hbCBzZXBhcmF0b3Iga2V5IHN5bWJvbFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RlY2ltYWxDaGFyYWN0ZXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgJy4nLCAnLCcsICfCtycsICfijpYnIG9yICfZqycsIFske29wdGlvbnMuZGVjaW1hbENoYXJhY3Rlcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHRoZSBkZWNpbWFsIGFuZCB0aG91c2FuZCBjaGFyYWN0ZXJzIGFyZSB0aGUgc2FtZVxuICAgICAgICBpZiAob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyID09PSBvcHRpb25zLmRpZ2l0R3JvdXBTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYGF1dG9OdW1lcmljIHdpbGwgbm90IGZ1bmN0aW9uIHByb3Blcmx5IHdoZW4gdGhlIGRlY2ltYWwgY2hhcmFjdGVyICdkZWNpbWFsQ2hhcmFjdGVyJyBbJHtvcHRpb25zLmRlY2ltYWxDaGFyYWN0ZXJ9XSBhbmQgdGhlIHRob3VzYW5kIHNlcGFyYXRvciAnZGlnaXRHcm91cFNlcGFyYXRvcicgWyR7b3B0aW9ucy5kaWdpdEdyb3VwU2VwYXJhdG9yfV0gYXJlIHRoZSBzYW1lIGNoYXJhY3Rlci5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbENoYXJhY3RlckFsdGVybmF0aXZlKSAmJiAhaXNTdHJpbmcob3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmUpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgYWx0ZXJuYXRlIGRlY2ltYWwgc2VwYXJhdG9yIGNoYXJhY3RlciBvcHRpb24gJ2RlY2ltYWxDaGFyYWN0ZXJBbHRlcm5hdGl2ZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5kZWNpbWFsQ2hhcmFjdGVyQWx0ZXJuYXRpdmV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcHRpb25zLmN1cnJlbmN5U3ltYm9sICE9PSAnJyAmJiAhaXNTdHJpbmcob3B0aW9ucy5jdXJyZW5jeVN5bWJvbCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjdXJyZW5jeSBzeW1ib2wgb3B0aW9uICdjdXJyZW5jeVN5bWJvbCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHN0cmluZywgWyR7b3B0aW9ucy5jdXJyZW5jeVN5bWJvbH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudCwgWydwJywgJ3MnXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBwbGFjZW1lbnQgb2YgdGhlIGN1cnJlbmN5IHNpZ24gb3B0aW9uICdjdXJyZW5jeVN5bWJvbFBsYWNlbWVudCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ3AnIChwcmVmaXgpIG9yICdzJyAoc3VmZml4KSwgWyR7b3B0aW9ucy5jdXJyZW5jeVN5bWJvbFBsYWNlbWVudH1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc0luQXJyYXkob3B0aW9ucy5uZWdhdGl2ZVBvc2l0aXZlU2lnblBsYWNlbWVudCwgWydwJywgJ3MnLCAnbCcsICdyJywgbnVsbF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgcGxhY2VtZW50IG9mIHRoZSBuZWdhdGl2ZSBzaWduIG9wdGlvbiAnbmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdwJyAocHJlZml4KSwgJ3MnIChzdWZmaXgpLCAnbCcgKGxlZnQpLCAncicgKHJpZ2h0KSBvciAnbnVsbCcsIFske29wdGlvbnMubmVnYXRpdmVQb3NpdGl2ZVNpZ25QbGFjZW1lbnR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFpc1RydWVPckZhbHNlU3RyaW5nKG9wdGlvbnMuc2hvd1Bvc2l0aXZlU2lnbikgJiYgIWlzQm9vbGVhbihvcHRpb25zLnNob3dQb3NpdGl2ZVNpZ24pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2hvdyBwb3NpdGl2ZSBzaWduIG9wdGlvbiAnc2hvd1Bvc2l0aXZlU2lnbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuc2hvd1Bvc2l0aXZlU2lnbn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1N0cmluZyhvcHRpb25zLnN1ZmZpeFRleHQpIHx8IChvcHRpb25zLnN1ZmZpeFRleHQgIT09ICcnICYmIChpc05lZ2F0aXZlKG9wdGlvbnMuc3VmZml4VGV4dCkgfHwgdGVzdE51bWVyaWNhbENoYXJhY3RlcnMudGVzdChvcHRpb25zLnN1ZmZpeFRleHQpKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBhZGRpdGlvbmFsIHN1ZmZpeCBvcHRpb24gJ3N1ZmZpeFRleHQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgbm90IGNvbnRhaW5zIHRoZSBuZWdhdGl2ZSBzaWduICctJyBub3IgYW55IG51bWVyaWNhbCBjaGFyYWN0ZXJzLCBbJHtvcHRpb25zLnN1ZmZpeFRleHR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMub3ZlcnJpZGVNaW5NYXhMaW1pdHMpICYmICFpc0luQXJyYXkob3B0aW9ucy5vdmVycmlkZU1pbk1heExpbWl0cywgWydjZWlsaW5nJywgJ2Zsb29yJywgJ2lnbm9yZSddKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG92ZXJyaWRlIG1pbiAmIG1heCBsaW1pdHMgb3B0aW9uICdvdmVycmlkZU1pbk1heExpbWl0cycgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ2NlaWxpbmcnLCAnZmxvb3InIG9yICdpZ25vcmUnLCBbJHtvcHRpb25zLm92ZXJyaWRlTWluTWF4TGltaXRzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzU3RyaW5nKG9wdGlvbnMubWF4aW11bVZhbHVlKSB8fCAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLm1heGltdW1WYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiAnbWF4aW11bVZhbHVlJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyBhIHBvc2l0aXZlIG9yIG5lZ2F0aXZlIG51bWJlciwgWyR7b3B0aW9ucy5tYXhpbXVtVmFsdWV9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNTdHJpbmcob3B0aW9ucy5taW5pbXVtVmFsdWUpIHx8ICF0ZXN0RmxvYXRPckludGVnZXJBbmRQb3NzaWJsZU5lZ2F0aXZlU2lnbi50ZXN0KG9wdGlvbnMubWluaW11bVZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIG1pbmltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uICdtaW5pbXVtVmFsdWUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLm1pbmltdW1WYWx1ZX1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnNlRmxvYXQob3B0aW9ucy5taW5pbXVtVmFsdWUpID4gcGFyc2VGbG9hdChvcHRpb25zLm1heGltdW1WYWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlIG9wdGlvbiBpcyBncmVhdGVyIHRoYW4gdGhlIG1heGltdW0gcG9zc2libGUgdmFsdWUgb3B0aW9uIDsgJ21pbmltdW1WYWx1ZScgWyR7b3B0aW9ucy5taW5pbXVtVmFsdWV9XSBzaG91bGQgYmUgc21hbGxlciB0aGFuICdtYXhpbXVtVmFsdWUnIFske29wdGlvbnMubWF4aW11bVZhbHVlfV0uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIShpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpIHx8XG4gICAgICAgICAgICAoaXNJbnQob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlID49IDApIHx8IC8vIElmIGludGVnZXIgb3B0aW9uXG4gICAgICAgICAgICAoaXNTdHJpbmcob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIHRlc3RQb3NpdGl2ZUludGVnZXIudGVzdChvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpKSAgLy8gSWYgc3RyaW5nIG9wdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvcHRpb24gJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIGludGVnZXIsIFske29wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcml0ZSBhIHdhcm5pbmcgbWVzc2FnZSBpbiB0aGUgY29uc29sZSBpZiB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgaW4gbWluaW11bVZhbHVlL21heGltdW1WYWx1ZSBpcyBvdmVycmlkZGVuIGJ5IGRlY2ltYWxQbGFjZXNPdmVycmlkZSAoYW5kIG5vdCBpZiBkZWNpbWFsUGxhY2VzT3ZlcnJpZGUgaXMgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBkZWNpbWFsIHVzZWQgaW4gbWluaW11bVZhbHVlL21heGltdW1WYWx1ZSlcbiAgICAgICAgY29uc3Qgdk1pbkFuZFZNYXhNYXhpbXVtRGVjaW1hbFBsYWNlcyA9IG1heGltdW1WTWluQW5kVk1heERlY2ltYWxMZW5ndGgob3B0aW9ucy5taW5pbXVtVmFsdWUsIG9wdGlvbnMubWF4aW11bVZhbHVlKTtcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpICYmIHZNaW5BbmRWTWF4TWF4aW11bURlY2ltYWxQbGFjZXMgIT09IE51bWJlcihvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZSkpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFNldHRpbmcgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgdG8gWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XSB3aWxsIG92ZXJyaWRlIHRoZSBkZWNpbWFscyBkZWNsYXJlZCBpbiAnbWluaW11bVZhbHVlJyBbJHtvcHRpb25zLm1pbmltdW1WYWx1ZX1dIGFuZCAnbWF4aW11bVZhbHVlJyBbJHtvcHRpb25zLm1heGltdW1WYWx1ZX1dLmAsIG9wdGlvbnMuc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghb3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nICYmICFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGBTZXR0aW5nICdhbGxvd0RlY2ltYWxQYWRkaW5nJyB0byBbZmFsc2VdIHdpbGwgb3ZlcnJpZGUgdGhlIGN1cnJlbnQgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgc2V0dGluZyBbJHtvcHRpb25zLmRlY2ltYWxQbGFjZXNPdmVycmlkZX1dLmAsIG9wdGlvbnMuc2hvd1dhcm5pbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykgJiYgKCFpc1N0cmluZyhvcHRpb25zLmRlY2ltYWxQbGFjZXNTaG93bk9uRm9jdXMpIHx8ICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBudW1iZXIgb2YgZXhwYW5kZWQgZGVjaW1hbCBwbGFjZXMgb3B0aW9uICdkZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja3MgaWYgdGhlIGV4dGVuZGVkIGRlY2ltYWwgcGxhY2VzIFwiZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1c1wiIGlzIGdyZWF0ZXIgdGhhbiB0aGUgbm9ybWFsIGRlY2ltYWwgcGxhY2VzIFwiZGVjaW1hbFBsYWNlc092ZXJyaWRlXCJcbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzKSAmJiAhaXNOdWxsKG9wdGlvbnMuZGVjaW1hbFBsYWNlc092ZXJyaWRlKSAmJiBOdW1iZXIob3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGUpID4gTnVtYmVyKG9wdGlvbnMuZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cykpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoYFRoZSBleHRlbmRlZCBkZWNpbWFsIHBsYWNlcyAnZGVjaW1hbFBsYWNlc1Nob3duT25Gb2N1cycgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzU2hvd25PbkZvY3VzfV0gc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB0aGUgJ2RlY2ltYWxQbGFjZXNPdmVycmlkZScgWyR7b3B0aW9ucy5kZWNpbWFsUGxhY2VzT3ZlcnJpZGV9XSB2YWx1ZS4gQ3VycmVudGx5LCB0aGlzIHdpbGwgbGltaXQgdGhlIGFiaWxpdHkgb2YgeW91ciBjbGllbnQgdG8gbWFudWFsbHkgY2hhbmdlIHNvbWUgb2YgdGhlIGRlY2ltYWwgcGxhY2VzLiBEbyB5b3UgcmVhbGx5IHdhbnQgdG8gZG8gdGhhdD9gLCBvcHRpb25zLnNob3dXYXJuaW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLnNjYWxlRGl2aXNvcikgJiYgIXRlc3RQb3NpdGl2ZUZsb2F0T3JJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURpdmlzb3IpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgZGl2aXNvciBvcHRpb24gJ3NjYWxlRGl2aXNvcicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlciwgcHJlZmVyYWJseSBhbiBpbnRlZ2VyLCBbJHtvcHRpb25zLnNjYWxlRGl2aXNvcn1dIGdpdmVuLmApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc051bGwob3B0aW9ucy5zY2FsZURlY2ltYWxQbGFjZXMpICYmICF0ZXN0UG9zaXRpdmVJbnRlZ2VyLnRlc3Qob3B0aW9ucy5zY2FsZURlY2ltYWxQbGFjZXMpKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgc2NhbGUgbnVtYmVyIG9mIGRlY2ltYWxzIG9wdGlvbiAnc2NhbGVEZWNpbWFsUGxhY2VzJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgWyR7b3B0aW9ucy5zY2FsZURlY2ltYWxQbGFjZXN9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuc2NhbGVTeW1ib2wpICYmICFpc1N0cmluZyhvcHRpb25zLnNjYWxlU3ltYm9sKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNjYWxlIHN5bWJvbCBvcHRpb24gJ3NjYWxlU3ltYm9sJyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGEgc3RyaW5nLCBbJHtvcHRpb25zLnNjYWxlU3ltYm9sfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5zYXZlVmFsdWVUb1Nlc3Npb25TdG9yYWdlKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuc2F2ZVZhbHVlVG9TZXNzaW9uU3RvcmFnZSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBzYXZlIHRvIHNlc3Npb24gc3RvcmFnZSBvcHRpb24gJ3NhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2UnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNhdmVWYWx1ZVRvU2Vzc2lvblN0b3JhZ2V9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMub25JbnZhbGlkUGFzdGUsIFtcbiAgICAgICAgICAgICdlcnJvcicsXG4gICAgICAgICAgICAnaWdub3JlJyxcbiAgICAgICAgICAgICdjbGFtcCcsXG4gICAgICAgICAgICAndHJ1bmNhdGUnLFxuICAgICAgICAgICAgJ3JlcGxhY2UnLFxuICAgICAgICBdKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHBhc3RlIGJlaGF2aW9yIG9wdGlvbiAnb25JbnZhbGlkUGFzdGUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdlcnJvcicsICdpZ25vcmUnLCAnY2xhbXAnLCAndHJ1bmNhdGUnIG9yICdyZXBsYWNlJyAoY2YuIGRvY3VtZW50YXRpb24pLCBbJHtvcHRpb25zLm9uSW52YWxpZFBhc3RlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzSW5BcnJheShvcHRpb25zLnJvdW5kaW5nTWV0aG9kLCBbXG4gICAgICAgICAgICAnUycsXG4gICAgICAgICAgICAnQScsXG4gICAgICAgICAgICAncycsXG4gICAgICAgICAgICAnYScsXG4gICAgICAgICAgICAnQicsXG4gICAgICAgICAgICAnVScsXG4gICAgICAgICAgICAnRCcsXG4gICAgICAgICAgICAnQycsXG4gICAgICAgICAgICAnRicsXG4gICAgICAgICAgICAnTjA1JyxcbiAgICAgICAgICAgICdDSEYnLFxuICAgICAgICAgICAgJ1UwNScsXG4gICAgICAgICAgICAnRDA1JyxcbiAgICAgICAgXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSByb3VuZGluZyBtZXRob2Qgb3B0aW9uICdyb3VuZGluZ01ldGhvZCcgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBlaXRoZXIgYmUgJ1MnLCAnQScsICdzJywgJ2EnLCAnQicsICdVJywgJ0QnLCAnQycsICdGJywgJ04wNScsICdDSEYnLCAnVTA1JyBvciAnRDA1JyAoY2YuIGRvY3VtZW50YXRpb24pLCBbJHtvcHRpb25zLnJvdW5kaW5nTWV0aG9kfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy5hbGxvd0RlY2ltYWxQYWRkaW5nKSAmJiAhaXNCb29sZWFuKG9wdGlvbnMuYWxsb3dEZWNpbWFsUGFkZGluZykpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBjb250cm9sIGRlY2ltYWwgcGFkZGluZyBvcHRpb24gJ2FsbG93RGVjaW1hbFBhZGRpbmcnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmFsbG93RGVjaW1hbFBhZGRpbmd9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXIpICYmICFpc0luQXJyYXkob3B0aW9ucy5uZWdhdGl2ZUJyYWNrZXRzVHlwZU9uQmx1ciwgWycoLCknLCAnWyxdJywgJzwsPicsICd7LH0nXSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSBicmFja2V0cyBmb3IgbmVnYXRpdmUgdmFsdWVzIG9wdGlvbiAnbmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXInIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICcoLCknLCAnWyxdJywgJzwsPicgb3IgJ3ssfScsIFske29wdGlvbnMubmVnYXRpdmVCcmFja2V0c1R5cGVPbkJsdXJ9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMuZW1wdHlJbnB1dEJlaGF2aW9yLCBbJ2ZvY3VzJywgJ3ByZXNzJywgJ2Fsd2F5cycsICd6ZXJvJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgZGlzcGxheSBvbiBlbXB0eSBzdHJpbmcgb3B0aW9uICdlbXB0eUlucHV0QmVoYXZpb3InIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdmb2N1cycsICdwcmVzcycsICdhbHdheXMnIG9yICd6ZXJvJywgWyR7b3B0aW9ucy5lbXB0eUlucHV0QmVoYXZpb3J9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNJbkFycmF5KG9wdGlvbnMubGVhZGluZ1plcm8sIFsnYWxsb3cnLCAnZGVueScsICdrZWVwJ10pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgbGVhZGluZyB6ZXJvIGJlaGF2aW9yIG9wdGlvbiAnbGVhZGluZ1plcm8nIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlICdhbGxvdycsICdkZW55JyBvciAna2VlcCcsIFske29wdGlvbnMubGVhZGluZ1plcm99XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmZvcm1hdE9uUGFnZUxvYWQpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5mb3JtYXRPblBhZ2VMb2FkKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGZvcm1hdCBvbiBpbml0aWFsaXphdGlvbiBvcHRpb24gJ2Zvcm1hdE9uUGFnZUxvYWQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLmZvcm1hdE9uUGFnZUxvYWR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLnNlbGVjdE51bWJlck9ubHkpICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5zZWxlY3ROdW1iZXJPbmx5KSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIHNlbGVjdCBudW1iZXIgb25seSBvcHRpb24gJ3NlbGVjdE51bWJlck9ubHknIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgZWl0aGVyICdmYWxzZScgb3IgJ3RydWUnLCBbJHtvcHRpb25zLnNlbGVjdE51bWJlck9ubHl9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNOdWxsKG9wdGlvbnMuZGVmYXVsdFZhbHVlT3ZlcnJpZGUpICYmIChvcHRpb25zLmRlZmF1bHRWYWx1ZU92ZXJyaWRlICE9PSAnJyAmJiAhdGVzdEZsb2F0T3JJbnRlZ2VyQW5kUG9zc2libGVOZWdhdGl2ZVNpZ24udGVzdChvcHRpb25zLmRlZmF1bHRWYWx1ZU92ZXJyaWRlKSkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSB1bmZvcm1hdHRlZCBkZWZhdWx0IHZhbHVlIG9wdGlvbiAnZGVmYXVsdFZhbHVlT3ZlcnJpZGUnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgYmUgYSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIGEgcG9zaXRpdmUgb3IgbmVnYXRpdmUgbnVtYmVyLCBbJHtvcHRpb25zLmRlZmF1bHRWYWx1ZU92ZXJyaWRlfV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzVHJ1ZU9yRmFsc2VTdHJpbmcob3B0aW9ucy51bmZvcm1hdE9uU3VibWl0KSAmJiAhaXNCb29sZWFuKG9wdGlvbnMudW5mb3JtYXRPblN1Ym1pdCkpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3IoYFRoZSByZW1vdmUgZm9ybWF0dGluZyBvbiBzdWJtaXQgb3B0aW9uICd1bmZvcm1hdE9uU3VibWl0JyBpcyBpbnZhbGlkIDsgaXQgc2hvdWxkIGJlIGVpdGhlciAnZmFsc2UnIG9yICd0cnVlJywgWyR7b3B0aW9ucy51bmZvcm1hdE9uU3VibWl0fV0gZ2l2ZW4uYCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTnVsbChvcHRpb25zLm91dHB1dEZvcm1hdCkgJiYgIWlzSW5BcnJheShvcHRpb25zLm91dHB1dEZvcm1hdCwgW1xuICAgICAgICAgICAgJ3N0cmluZycsXG4gICAgICAgICAgICAnbnVtYmVyJyxcbiAgICAgICAgICAgICcuJyxcbiAgICAgICAgICAgICctLicsXG4gICAgICAgICAgICAnLCcsXG4gICAgICAgICAgICAnLSwnLFxuICAgICAgICAgICAgJy4tJyxcbiAgICAgICAgICAgICcsLScsXG4gICAgICAgIF0pKSB7XG4gICAgICAgICAgICB0aHJvd0Vycm9yKGBUaGUgY3VzdG9tIGxvY2FsZSBmb3JtYXQgb3B0aW9uICdvdXRwdXRGb3JtYXQnIGlzIGludmFsaWQgOyBpdCBzaG91bGQgZWl0aGVyIGJlIG51bGwsICdzdHJpbmcnLCAnbnVtYmVyJywgJy4nLCAnLS4nLCAnLCcsICctLCcsICcuLScgb3IgJywtJywgWyR7b3B0aW9ucy5vdXRwdXRGb3JtYXR9XSBnaXZlbi5gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNUcnVlT3JGYWxzZVN0cmluZyhvcHRpb25zLmZhaWxPblVua25vd25PcHRpb24pICYmICFpc0Jvb2xlYW4ob3B0aW9ucy5mYWlsT25Vbmtub3duT3B0aW9uKSkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihgVGhlIGRlYnVnIG9wdGlvbiAnZmFpbE9uVW5rbm93bk9wdGlvbicgaXMgaW52YWxpZCA7IGl0IHNob3VsZCBiZSBlaXRoZXIgJ2ZhbHNlJyBvciAndHJ1ZScsIFske29wdGlvbnMuZmFpbE9uVW5rbm93bk9wdGlvbn1dIGdpdmVuLmApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgICQuZm4uYXV0b1ZhbGlkYXRlID0gdmFsaWRhdGU7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gVFJVRSBpcyB0aGUgc2V0dGluZ3Mvb3B0aW9ucyBhcmUgdmFsaWQsIEZBTFNFIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYXJlU2V0dGluZ3NWYWxpZCA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGlzVmFsaWQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsaWRhdGUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaXNWYWxpZDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGFrZSBhbiBhcmFiaWMgbnVtYmVyIGFzIGEgc3RyaW5nIGFuZCByZXR1cm4gYSBqYXZhc2NyaXB0IG51bWJlci5cbiAgICAgKiBCeSBkZWZhdWx0LCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHRyeSB0byBjb252ZXJ0IHRoZSBhcmFiaWMgZGVjaW1hbCBhbmQgdGhvdXNhbmQgc2VwYXJhdG9yIGNoYXJhY3RlcnMuXG4gICAgICogVGhpcyByZXR1cm5zIGBOYU5gIGlzIHRoZSBjb252ZXJzaW9uIGlzIG5vdCBwb3NzaWJsZS5cbiAgICAgKiBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNzAyNTM5Mi8yODM0ODk4XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXJhYmljTnVtYmVyc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmV0dXJuQU51bWJlciBJZiBgdHJ1ZWAsIHJldHVybiBhIE51bWJlciwgb3RoZXJ3aXNlIHJldHVybiBhIFN0cmluZ1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gcGFyc2VEZWNpbWFsQ2hhcmFjdGVyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBwYXJzZVRob3VzYW5kU2VwYXJhdG9yXG4gICAgICogQHJldHVybnMge3N0cmluZ3xudW1iZXJ8TmFOfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFyYWJpY1RvTGF0aW5OdW1iZXJzKGFyYWJpY051bWJlcnMsIHJldHVybkFOdW1iZXIgPSB0cnVlLCBwYXJzZURlY2ltYWxDaGFyYWN0ZXIgPSBmYWxzZSwgcGFyc2VUaG91c2FuZFNlcGFyYXRvciA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBhcmFiaWNOdW1iZXJzLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJhYmljTnVtYmVycztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJzZURlY2ltYWxDaGFyYWN0ZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC/Zqy8sICcuJyk7IC8vIERlY2ltYWwgY2hhcmFjdGVyXG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyc2VUaG91c2FuZFNlcGFyYXRvcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL9msL2csICcnKTsgLy8gVGhvdXNhbmQgc2VwYXJhdG9yXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBudW1iZXJzIG9ubHlcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1vZoNmh2aLZo9mk2aXZptmn2ajZqV0vZywgZCA9PiBkLmNoYXJDb2RlQXQoMCkgLSAxNjMyKSAvLyBBcmFiaWMgbnVtYmVyc1xuICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvW9uw27Hbstuz27Tbtdu227fbuNu5XS9nLCBkID0+IGQuY2hhckNvZGVBdCgwKSAtIDE3NzYpOyAvLyBQZXJzaWFuIG51bWJlcnNcblxuICAgICAgICAvLyBgTmFOYCBoYXMgcHJlY2VkZW5jZSBvdmVyIHRoZSBzdHJpbmcgYCdOYU4nYFxuICAgICAgICBjb25zdCByZXN1bHRBc051bWJlciA9IE51bWJlcihyZXN1bHQpO1xuICAgICAgICBpZiAoaXNOYU4ocmVzdWx0QXNOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0QXNOdW1iZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0dXJuQU51bWJlcikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0QXNOdW1iZXI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGN1c3RvbSBldmVudCBhbmQgaW1tZWRpYXRlbHkgc2VudCBpdCBmcm9tIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAqIEJ5IGRlZmF1bHQsIGlmIG5vIGVsZW1lbnQgaXMgZ2l2ZW4sIHRoZSBldmVudCBpcyB0aHJvd24gZnJvbSBgZG9jdW1lbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBkZXRhaWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBlbGVtZW50ID0gZG9jdW1lbnQsIGRldGFpbCA9IG51bGwpIHtcbiAgICAgICAgbGV0IGV2ZW50O1xuICAgICAgICBpZiAod2luZG93LkN1c3RvbUV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsLCBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UgfSk7IC8vIFRoaXMgaXMgbm90IHN1cHBvcnRlZCBieSBkZWZhdWx0IGJ5IElFIDsgV2UgdXNlIHRoZSBwb2x5ZmlsbCBmb3IgSUU5IGFuZCBsYXRlci5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnROYW1lLCB0cnVlLCB0cnVlLCB7IGRldGFpbCB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9seWZpbGwgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvQ3VzdG9tRXZlbnQgZm9yIG9ic29sZXRlIGJyb3dzZXJzIChJRSlcbiAgICAgKi9cbiAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBDdXN0b21FdmVudChldmVudCwgcGFyYW1zKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdm9pZCgwKSB9O1xuICAgICAgICAgICAgY29uc3QgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwpO1xuICAgICAgICAgICAgcmV0dXJuIGV2dDtcbiAgICAgICAgfVxuXG4gICAgICAgIEN1c3RvbUV2ZW50LnByb3RvdHlwZSA9IHdpbmRvdy5FdmVudC5wcm90b3R5cGU7XG4gICAgICAgIHdpbmRvdy5DdXN0b21FdmVudCA9IEN1c3RvbUV2ZW50O1xuICAgIH0pKCk7XG59KSk7XG5cbi8qKlxuICogVGhpcyBleHBvcnRzIHRoZSBpbnRlcmZhY2UgZm9yIHRoZSBhdXRvTnVtZXJpYyBvYmplY3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQge1xuICAgIGZvcm1hdCAgOiBhdXRvRm9ybWF0LFxuICAgIHVuRm9ybWF0OiBhdXRvVW5Gb3JtYXQsXG4gICAgZ2V0RGVmYXVsdENvbmZpZyxcbiAgICBnZXRMYW5ndWFnZXMsXG4gICAgdmFsaWRhdGUsIC8vIGFuLnZhbGlkYXRlKG9wdGlvbnMpIDogdGhyb3dzIGlmIG5lY2Vzc2FyeVxuICAgIGFyZVNldHRpbmdzVmFsaWQsIC8vIGFuLmFyZVNldHRpbmdzVmFsaWQob3B0aW9ucykgOiByZXR1cm4gdHJ1ZSBvciBmYWxzZSAvL1RPRE8gSXMgdGhpcyByZWR1bmRhbnQ/IFNob3VsZCB3ZSBsZXQgdGhlIGRldmVsb3BlcnMgd3JhcCBlYWNoIGF1dG9OdW1lcmljLnZhbGlkYXRlKCkgY2FsbHMgaW4gdHJ5L2NhdGNoIGJsb2NrPyBPciBzaG91bGQgd2UganVzdCBmYWNpbGl0YXRlIHRoZWlyIGxpZmUgYnkgZG9pbmcgaXQgYWxyZWFkeT9cblxuICAgIC8vVE9ETyBDb21wbGV0ZSB0aGUgaW50ZXJmYWNlIHdpdGggZnVuY3Rpb25zIGhhdmluZyB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZXMgOlxuICAgIC8vaW5pdCAgICAgICAgIDogYW4uaW5pdChvcHRpb25zLCBpbnB1dClcbiAgICAvL2dldCAgICAgICAgICA6IGFuLmdldChpbnB1dClcbiAgICAvL3NldCAgICAgICAgICA6IGFuLnNldCh2YWx1ZSwgaW5wdXQpXG4gICAgLy9mb3JtU3RyaW5nICAgOiBhbi5mb3JtU3RyaW5nKGZvcm0pXG4gICAgLy9mb3JtQXJyYXkgICAgOiBhbi5mb3JtQXJyYXkoZm9ybSlcbiAgICAvL2dldEZvcm1hdHRlZCA6IGFuLmdldEZvcm1hdHRlZChpbnB1dClcbiAgICAvL3Vuc2V0ICAgICAgICA6IGFuLnVuc2V0KGlucHV0KSAvL3RvIHJlbmFtZSB0byAndW5mb3JtYXQnPyAoYW5kIG1lcmdlIHdpdGggYXV0b1VuRm9ybWF0L3VuRm9ybWF0PylcbiAgICAvL3JlZm9ybWF0ICAgICA6IGFuLnJlZm9ybWF0KGlucHV0KSAvLyAncmVTZXQnIGlzIHZlcnkgdG8gY2xvc2UgdG8gJ3Jlc2V0JyBhbmQgdGhlcmVmb3JlIHNob3VsZCBiZSByZW5hbWVkLiBXZSBjb3VsZCBzdGlsbCBleHBvc2UgJ3JlU2V0JywgYnV0IGFkZCBhIEBkZXByZWNhdGVkIHRhZyBvbiBpdHMgZGVjbGFyYXRpb24uXG4gICAgLy9zZXR0aW5ncyAgICAgOiBhbi5zZXR0aW5ncyhpbnB1dClcbiAgICAvL3VwZGF0ZSAgICAgICA6IGFuLnVwZGF0ZShvcHRpb25zLCBpbnB1dClcbiAgICAvL3dpcGUgICAgICAgICA6IGFuLndpcGUoaW5wdXQpXG4gICAgLy9kZXN0cm95ICAgICAgOiBhbi5kZXN0cm95KGlucHV0KVxuXG4gICAgLy9yYXcgICAgICAgICAgOiBhbi5yYXcoaW5wdXQpIC8vIFJldHVybiB0aGUgdW5mb3JtYXR0ZWQgdmFsdWUgYXMgYSBzdHJpbmdcbiAgICAvL251bWJlciAgICAgICA6IGFuLm51bWJlcihpbnB1dCkgLy8gUmV0dXJuIHRoZSB1bmZvcm1hdHRlZCB2YWx1ZSBhcyBhIG51bWJlciAoV2FybmluZzogVGhpcyBjYW4gbGVhZCB0byBwcmVjaXNpb24gcHJvYmxlbXMgd2l0aCBiaWcgbnVtYmVycylcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvYXV0b051bWVyaWMuanMiXSwic291cmNlUm9vdCI6IiJ9");
    }, function(module, exports) {
        eval("module.exports = __WEBPACK_EXTERNAL_MODULE_1__;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vZXh0ZXJuYWwge1wicm9vdFwiOlwialF1ZXJ5XCIsXCJjb21tb25qc1wiOlwianF1ZXJ5XCIsXCJjb21tb25qczJcIjpcImpxdWVyeVwiLFwiYW1kXCI6XCJqcXVlcnlcIn0/NWNiYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzFfXztcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyBleHRlcm5hbCB7XCJyb290XCI6XCJqUXVlcnlcIixcImNvbW1vbmpzXCI6XCJqcXVlcnlcIixcImNvbW1vbmpzMlwiOlwianF1ZXJ5XCIsXCJhbWRcIjpcImpxdWVyeVwifVxuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9");
    } ]);
}), "undefined" == typeof jQuery) throw new Error("Bootstrap's JavaScript requires jQuery");

+function($) {
    "use strict";
    var version = $.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || 1 == version[0] && 9 == version[1] && version[2] < 1 || version[0] > 3) throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4");
}(jQuery), +function($) {
    "use strict";
    function transitionEnd() {
        var el = document.createElement("bootstrap"), transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames) if (void 0 !== el.style[name]) return {
            end: transEndEventNames[name]
        };
        return !1;
    }
    $.fn.emulateTransitionEnd = function(duration) {
        var called = !1, $el = this;
        $(this).one("bsTransitionEnd", function() {
            called = !0;
        });
        var callback = function() {
            called || $($el).trigger($.support.transition.end);
        };
        return setTimeout(callback, duration), this;
    }, $(function() {
        $.support.transition = transitionEnd(), $.support.transition && ($.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function(e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        });
    });
}(jQuery), +function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.alert");
            data || $this.data("bs.alert", data = new Alert(this)), "string" == typeof option && data[option].call($this);
        });
    }
    var dismiss = '[data-dismiss="alert"]', Alert = function(el) {
        $(el).on("click", dismiss, this.close);
    };
    Alert.VERSION = "3.3.7", Alert.TRANSITION_DURATION = 150, Alert.prototype.close = function(e) {
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove();
        }
        var $this = $(this), selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = $("#" === selector ? [] : selector);
        e && e.preventDefault(), $parent.length || ($parent = $this.closest(".alert")), 
        $parent.trigger(e = $.Event("close.bs.alert")), e.isDefaultPrevented() || ($parent.removeClass("in"), 
        $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement());
    };
    var old = $.fn.alert;
    $.fn.alert = Plugin, $.fn.alert.Constructor = Alert, $.fn.alert.noConflict = function() {
        return $.fn.alert = old, this;
    }, $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close);
}(jQuery), +function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.button"), options = "object" == typeof option && option;
            data || $this.data("bs.button", data = new Button(this, options)), "toggle" == option ? data.toggle() : option && data.setState(option);
        });
    }
    var Button = function(element, options) {
        this.$element = $(element), this.options = $.extend({}, Button.DEFAULTS, options), 
        this.isLoading = !1;
    };
    Button.VERSION = "3.3.7", Button.DEFAULTS = {
        loadingText: "loading..."
    }, Button.prototype.setState = function(state) {
        var d = "disabled", $el = this.$element, val = $el.is("input") ? "val" : "html", data = $el.data();
        state += "Text", null == data.resetText && $el.data("resetText", $el[val]()), setTimeout($.proxy(function() {
            $el[val](null == data[state] ? this.options[state] : data[state]), "loadingText" == state ? (this.isLoading = !0, 
            $el.addClass(d).attr(d, d).prop(d, !0)) : this.isLoading && (this.isLoading = !1, 
            $el.removeClass(d).removeAttr(d).prop(d, !1));
        }, this), 0);
    }, Button.prototype.toggle = function() {
        var changed = !0, $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            "radio" == $input.prop("type") ? ($input.prop("checked") && (changed = !1), $parent.find(".active").removeClass("active"), 
            this.$element.addClass("active")) : "checkbox" == $input.prop("type") && ($input.prop("checked") !== this.$element.hasClass("active") && (changed = !1), 
            this.$element.toggleClass("active")), $input.prop("checked", this.$element.hasClass("active")), 
            changed && $input.trigger("change");
        } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active");
    };
    var old = $.fn.button;
    $.fn.button = Plugin, $.fn.button.Constructor = Button, $.fn.button.noConflict = function() {
        return $.fn.button = old, this;
    }, $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target).closest(".btn");
        Plugin.call($btn, "toggle"), $(e.target).is('input[type="radio"], input[type="checkbox"]') || (e.preventDefault(), 
        $btn.is("input,button") ? $btn.trigger("focus") : $btn.find("input:visible,button:visible").first().trigger("focus"));
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function(e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type));
    });
}(jQuery), +function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.carousel"), options = $.extend({}, Carousel.DEFAULTS, $this.data(), "object" == typeof option && option), action = "string" == typeof option ? option : options.slide;
            data || $this.data("bs.carousel", data = new Carousel(this, options)), "number" == typeof option ? data.to(option) : action ? data[action]() : options.interval && data.pause().cycle();
        });
    }
    var Carousel = function(element, options) {
        this.$element = $(element), this.$indicators = this.$element.find(".carousel-indicators"), 
        this.options = options, this.paused = null, this.sliding = null, this.interval = null, 
        this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this)), 
        "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this));
    };
    Carousel.VERSION = "3.3.7", Carousel.TRANSITION_DURATION = 600, Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, Carousel.prototype.keydown = function(e) {
        if (!/input|textarea/i.test(e.target.tagName)) {
            switch (e.which) {
              case 37:
                this.prev();
                break;

              case 39:
                this.next();
                break;

              default:
                return;
            }
            e.preventDefault();
        }
    }, Carousel.prototype.cycle = function(e) {
        return e || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval)), 
        this;
    }, Carousel.prototype.getItemIndex = function(item) {
        return this.$items = item.parent().children(".item"), this.$items.index(item || this.$active);
    }, Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active), willWrap = "prev" == direction && 0 === activeIndex || "next" == direction && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap) return active;
        var delta = "prev" == direction ? -1 : 1, itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
    }, Carousel.prototype.to = function(pos) {
        var that = this, activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        if (!(pos > this.$items.length - 1 || pos < 0)) return this.sliding ? this.$element.one("slid.bs.carousel", function() {
            that.to(pos);
        }) : activeIndex == pos ? this.pause().cycle() : this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos));
    }, Carousel.prototype.pause = function(e) {
        return e || (this.paused = !0), this.$element.find(".next, .prev").length && $.support.transition && (this.$element.trigger($.support.transition.end), 
        this.cycle(!0)), this.interval = clearInterval(this.interval), this;
    }, Carousel.prototype.next = function() {
        if (!this.sliding) return this.slide("next");
    }, Carousel.prototype.prev = function() {
        if (!this.sliding) return this.slide("prev");
    }, Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find(".item.active"), $next = next || this.getItemForDirection(type, $active), isCycling = this.interval, direction = "next" == type ? "left" : "right", that = this;
        if ($next.hasClass("active")) return this.sliding = !1;
        var relatedTarget = $next[0], slideEvent = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        if (this.$element.trigger(slideEvent), !slideEvent.isDefaultPrevented()) {
            if (this.sliding = !0, isCycling && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
                $nextIndicator && $nextIndicator.addClass("active");
            }
            var slidEvent = $.Event("slid.bs.carousel", {
                relatedTarget: relatedTarget,
                direction: direction
            });
            return $.support.transition && this.$element.hasClass("slide") ? ($next.addClass(type), 
            $next[0].offsetWidth, $active.addClass(direction), $next.addClass(direction), $active.one("bsTransitionEnd", function() {
                $next.removeClass([ type, direction ].join(" ")).addClass("active"), $active.removeClass([ "active", direction ].join(" ")), 
                that.sliding = !1, setTimeout(function() {
                    that.$element.trigger(slidEvent);
                }, 0);
            }).emulateTransitionEnd(Carousel.TRANSITION_DURATION)) : ($active.removeClass("active"), 
            $next.addClass("active"), this.sliding = !1, this.$element.trigger(slidEvent)), 
            isCycling && this.cycle(), this;
        }
    };
    var old = $.fn.carousel;
    $.fn.carousel = Plugin, $.fn.carousel.Constructor = Carousel, $.fn.carousel.noConflict = function() {
        return $.fn.carousel = old, this;
    };
    var clickHandler = function(e) {
        var href, $this = $(this), $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""));
        if ($target.hasClass("carousel")) {
            var options = $.extend({}, $target.data(), $this.data()), slideIndex = $this.attr("data-slide-to");
            slideIndex && (options.interval = !1), Plugin.call($target, options), slideIndex && $target.data("bs.carousel").to(slideIndex), 
            e.preventDefault();
        }
    };
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler), 
    $(window).on("load", function() {
        $('[data-ride="carousel"]').each(function() {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data());
        });
    });
}(jQuery), +function($) {
    "use strict";
    function getTargetFromTrigger($trigger) {
        var href, target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        return $(target);
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.collapse"), options = $.extend({}, Collapse.DEFAULTS, $this.data(), "object" == typeof option && option);
            !data && options.toggle && /show|hide/.test(option) && (options.toggle = !1), data || $this.data("bs.collapse", data = new Collapse(this, options)), 
            "string" == typeof option && data[option]();
        });
    }
    var Collapse = function(element, options) {
        this.$element = $(element), this.options = $.extend({}, Collapse.DEFAULTS, options), 
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],[data-toggle="collapse"][data-target="#' + element.id + '"]'), 
        this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), 
        this.options.toggle && this.toggle();
    };
    Collapse.VERSION = "3.3.7", Collapse.TRANSITION_DURATION = 350, Collapse.DEFAULTS = {
        toggle: !0
    }, Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass("width");
        return hasWidth ? "width" : "height";
    }, Collapse.prototype.show = function() {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var activesData, actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(actives && actives.length && (activesData = actives.data("bs.collapse"), activesData && activesData.transitioning))) {
                var startEvent = $.Event("show.bs.collapse");
                if (this.$element.trigger(startEvent), !startEvent.isDefaultPrevented()) {
                    actives && actives.length && (Plugin.call(actives, "hide"), activesData || actives.data("bs.collapse", null));
                    var dimension = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", !0), 
                    this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                    var complete = function() {
                        this.$element.removeClass("collapsing").addClass("collapse in")[dimension](""), 
                        this.transitioning = 0, this.$element.trigger("shown.bs.collapse");
                    };
                    if (!$.support.transition) return complete.call(this);
                    var scrollSize = $.camelCase([ "scroll", dimension ].join("-"));
                    this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
                }
            }
        }
    }, Collapse.prototype.hide = function() {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var startEvent = $.Event("hide.bs.collapse");
            if (this.$element.trigger(startEvent), !startEvent.isDefaultPrevented()) {
                var dimension = this.dimension();
                this.$element[dimension](this.$element[dimension]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), 
                this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                var complete = function() {
                    this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse");
                };
                return $.support.transition ? void this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION) : complete.call(this);
            }
        }
    }, Collapse.prototype.toggle = function() {
        this[this.$element.hasClass("in") ? "hide" : "show"]();
    }, Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
    }, Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen), $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen);
    };
    var old = $.fn.collapse;
    $.fn.collapse = Plugin, $.fn.collapse.Constructor = Collapse, $.fn.collapse.noConflict = function() {
        return $.fn.collapse = old, this;
    }, $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        $this.attr("data-target") || e.preventDefault();
        var $target = getTargetFromTrigger($this), data = $target.data("bs.collapse"), option = data ? "toggle" : $this.data();
        Plugin.call($target, option);
    });
}(jQuery), +function($) {
    "use strict";
    function getParent($this) {
        var selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"), selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
    }
    function clearMenus(e) {
        e && 3 === e.which || ($(backdrop).remove(), $(toggle).each(function() {
            var $this = $(this), $parent = getParent($this), relatedTarget = {
                relatedTarget: this
            };
            $parent.hasClass("open") && (e && "click" == e.type && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target) || ($parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget)), 
            e.isDefaultPrevented() || ($this.attr("aria-expanded", "false"), $parent.removeClass("open").trigger($.Event("hidden.bs.dropdown", relatedTarget)))));
        }));
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.dropdown");
            data || $this.data("bs.dropdown", data = new Dropdown(this)), "string" == typeof option && data[option].call($this);
        });
    }
    var backdrop = ".dropdown-backdrop", toggle = '[data-toggle="dropdown"]', Dropdown = function(element) {
        $(element).on("click.bs.dropdown", this.toggle);
    };
    Dropdown.VERSION = "3.3.7", Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if (!$this.is(".disabled, :disabled")) {
            var $parent = getParent($this), isActive = $parent.hasClass("open");
            if (clearMenus(), !isActive) {
                "ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length && $(document.createElement("div")).addClass("dropdown-backdrop").insertAfter($(this)).on("click", clearMenus);
                var relatedTarget = {
                    relatedTarget: this
                };
                if ($parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget)), e.isDefaultPrevented()) return;
                $this.trigger("focus").attr("aria-expanded", "true"), $parent.toggleClass("open").trigger($.Event("shown.bs.dropdown", relatedTarget));
            }
            return !1;
        }
    }, Dropdown.prototype.keydown = function(e) {
        if (/(38|40|27|32)/.test(e.which) && !/input|textarea/i.test(e.target.tagName)) {
            var $this = $(this);
            if (e.preventDefault(), e.stopPropagation(), !$this.is(".disabled, :disabled")) {
                var $parent = getParent($this), isActive = $parent.hasClass("open");
                if (!isActive && 27 != e.which || isActive && 27 == e.which) return 27 == e.which && $parent.find(toggle).trigger("focus"), 
                $this.trigger("click");
                var desc = " li:not(.disabled):visible a", $items = $parent.find(".dropdown-menu" + desc);
                if ($items.length) {
                    var index = $items.index(e.target);
                    38 == e.which && index > 0 && index--, 40 == e.which && index < $items.length - 1 && index++, 
                    ~index || (index = 0), $items.eq(index).trigger("focus");
                }
            }
        }
    };
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin, $.fn.dropdown.Constructor = Dropdown, $.fn.dropdown.noConflict = function() {
        return $.fn.dropdown = old, this;
    }, $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function(e) {
        e.stopPropagation();
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.prototype.keydown);
}(jQuery), +function($) {
    "use strict";
    function Plugin(option, _relatedTarget) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.modal"), options = $.extend({}, Modal.DEFAULTS, $this.data(), "object" == typeof option && option);
            data || $this.data("bs.modal", data = new Modal(this, options)), "string" == typeof option ? data[option](_relatedTarget) : options.show && data.show(_relatedTarget);
        });
    }
    var Modal = function(element, options) {
        this.options = options, this.$body = $(document.body), this.$element = $(element), 
        this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, 
        this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, 
        this.options.remote && this.$element.find(".modal-content").load(this.options.remote, $.proxy(function() {
            this.$element.trigger("loaded.bs.modal");
        }, this));
    };
    Modal.VERSION = "3.3.7", Modal.TRANSITION_DURATION = 300, Modal.BACKDROP_TRANSITION_DURATION = 150, 
    Modal.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
    }, Modal.prototype.show = function(_relatedTarget) {
        var that = this, e = $.Event("show.bs.modal", {
            relatedTarget: _relatedTarget
        });
        this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, 
        this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), 
        this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this)), 
        this.$dialog.on("mousedown.dismiss.bs.modal", function() {
            that.$element.one("mouseup.dismiss.bs.modal", function(e) {
                $(e.target).is(that.$element) && (that.ignoreBackdropClick = !0);
            });
        }), this.backdrop(function() {
            var transition = $.support.transition && that.$element.hasClass("fade");
            that.$element.parent().length || that.$element.appendTo(that.$body), that.$element.show().scrollTop(0), 
            that.adjustDialog(), transition && that.$element[0].offsetWidth, that.$element.addClass("in"), 
            that.enforceFocus();
            var e = $.Event("shown.bs.modal", {
                relatedTarget: _relatedTarget
            });
            transition ? that.$dialog.one("bsTransitionEnd", function() {
                that.$element.trigger("focus").trigger(e);
            }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e);
        }));
    }, Modal.prototype.hide = function(e) {
        e && e.preventDefault(), e = $.Event("hide.bs.modal"), this.$element.trigger(e), 
        this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), 
        $(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), 
        this.$dialog.off("mousedown.dismiss.bs.modal"), $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal());
    }, Modal.prototype.enforceFocus = function() {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function(e) {
            document === e.target || this.$element[0] === e.target || this.$element.has(e.target).length || this.$element.trigger("focus");
        }, this));
    }, Modal.prototype.escape = function() {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", $.proxy(function(e) {
            27 == e.which && this.hide();
        }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal");
    }, Modal.prototype.resize = function() {
        this.isShown ? $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this)) : $(window).off("resize.bs.modal");
    }, Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide(), this.backdrop(function() {
            that.$body.removeClass("modal-open"), that.resetAdjustments(), that.resetScrollbar(), 
            that.$element.trigger("hidden.bs.modal");
        });
    }, Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null;
    }, Modal.prototype.backdrop = function(callback) {
        var that = this, animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            if (this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body), 
            this.$element.on("click.dismiss.bs.modal", $.proxy(function(e) {
                return this.ignoreBackdropClick ? void (this.ignoreBackdropClick = !1) : void (e.target === e.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()));
            }, this)), doAnimate && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), 
            !callback) return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function() {
                that.removeBackdrop(), callback && callback();
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else callback && callback();
    }, Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
    }, Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        });
    }, Modal.prototype.resetAdjustments = function() {
        this.$element.css({
            paddingLeft: "",
            paddingRight: ""
        });
    }, Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect();
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth, this.scrollbarWidth = this.measureScrollbar();
    }, Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", bodyPad + this.scrollbarWidth);
    }, Modal.prototype.resetScrollbar = function() {
        this.$body.css("padding-right", this.originalBodyPad);
    }, Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure", this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        return this.$body[0].removeChild(scrollDiv), scrollbarWidth;
    };
    var old = $.fn.modal;
    $.fn.modal = Plugin, $.fn.modal.Constructor = Modal, $.fn.modal.noConflict = function() {
        return $.fn.modal = old, this;
    }, $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function(e) {
        var $this = $(this), href = $this.attr("href"), $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, "")), option = $target.data("bs.modal") ? "toggle" : $.extend({
            remote: !/#/.test(href) && href
        }, $target.data(), $this.data());
        $this.is("a") && e.preventDefault(), $target.one("show.bs.modal", function(showEvent) {
            showEvent.isDefaultPrevented() || $target.one("hidden.bs.modal", function() {
                $this.is(":visible") && $this.trigger("focus");
            });
        }), Plugin.call($target, option, this);
    });
}(jQuery), +function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.tooltip"), options = "object" == typeof option && option;
            !data && /destroy|hide/.test(option) || (data || $this.data("bs.tooltip", data = new Tooltip(this, options)), 
            "string" == typeof option && data[option]());
        });
    }
    var Tooltip = function(element, options) {
        this.type = null, this.options = null, this.enabled = null, this.timeout = null, 
        this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", element, options);
    };
    Tooltip.VERSION = "3.3.7", Tooltip.TRANSITION_DURATION = 150, Tooltip.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {
            selector: "body",
            padding: 0
        }
    }, Tooltip.prototype.init = function(type, element, options) {
        if (this.enabled = !0, this.type = type, this.$element = $(element), this.options = this.getOptions(options), 
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), 
        this.inState = {
            click: !1,
            hover: !1,
            focus: !1
        }, this.$element[0] instanceof document.constructor && !this.options.selector) throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var triggers = this.options.trigger.split(" "), i = triggers.length; i--; ) {
            var trigger = triggers[i];
            if ("click" == trigger) this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this)); else if ("manual" != trigger) {
                var eventIn = "hover" == trigger ? "mouseenter" : "focusin", eventOut = "hover" == trigger ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this)), 
                this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this));
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
            trigger: "manual",
            selector: ""
        }) : this.fixTitle();
    }, Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
    }, Tooltip.prototype.getOptions = function(options) {
        return options = $.extend({}, this.getDefaults(), this.$element.data(), options), 
        options.delay && "number" == typeof options.delay && (options.delay = {
            show: options.delay,
            hide: options.delay
        }), options;
    }, Tooltip.prototype.getDelegateOptions = function() {
        var options = {}, defaults = this.getDefaults();
        return this._options && $.each(this._options, function(key, value) {
            defaults[key] != value && (options[key] = value);
        }), options;
    }, Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        return self || (self = new this.constructor(obj.currentTarget, this.getDelegateOptions()), 
        $(obj.currentTarget).data("bs." + this.type, self)), obj instanceof $.Event && (self.inState["focusin" == obj.type ? "focus" : "hover"] = !0), 
        self.tip().hasClass("in") || "in" == self.hoverState ? void (self.hoverState = "in") : (clearTimeout(self.timeout), 
        self.hoverState = "in", self.options.delay && self.options.delay.show ? void (self.timeout = setTimeout(function() {
            "in" == self.hoverState && self.show();
        }, self.options.delay.show)) : self.show());
    }, Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) if (this.inState[key]) return !0;
        return !1;
    }, Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        if (self || (self = new this.constructor(obj.currentTarget, this.getDelegateOptions()), 
        $(obj.currentTarget).data("bs." + this.type, self)), obj instanceof $.Event && (self.inState["focusout" == obj.type ? "focus" : "hover"] = !1), 
        !self.isInStateTrue()) return clearTimeout(self.timeout), self.hoverState = "out", 
        self.options.delay && self.options.delay.hide ? void (self.timeout = setTimeout(function() {
            "out" == self.hoverState && self.hide();
        }, self.options.delay.hide)) : self.hide();
    }, Tooltip.prototype.show = function() {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom) return;
            var that = this, $tip = this.tip(), tipId = this.getUID(this.type);
            this.setContent(), $tip.attr("id", tipId), this.$element.attr("aria-describedby", tipId), 
            this.options.animation && $tip.addClass("fade");
            var placement = "function" == typeof this.options.placement ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement, autoToken = /\s?auto?\s?/i, autoPlace = autoToken.test(placement);
            autoPlace && (placement = placement.replace(autoToken, "") || "top"), $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this), this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element), 
            this.$element.trigger("inserted.bs." + this.type);
            var pos = this.getPosition(), actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement, viewportDim = this.getPosition(this.$viewport);
                placement = "bottom" == placement && pos.bottom + actualHeight > viewportDim.bottom ? "top" : "top" == placement && pos.top - actualHeight < viewportDim.top ? "bottom" : "right" == placement && pos.right + actualWidth > viewportDim.width ? "left" : "left" == placement && pos.left - actualWidth < viewportDim.left ? "right" : placement, 
                $tip.removeClass(orgPlacement).addClass(placement);
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function() {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type), that.hoverState = null, "out" == prevHoverState && that.leave(that);
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
    }, Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip(), width = $tip[0].offsetWidth, height = $tip[0].offsetHeight, marginTop = parseInt($tip.css("margin-top"), 10), marginLeft = parseInt($tip.css("margin-left"), 10);
        isNaN(marginTop) && (marginTop = 0), isNaN(marginLeft) && (marginLeft = 0), offset.top += marginTop, 
        offset.left += marginLeft, $.offset.setOffset($tip[0], $.extend({
            using: function(props) {
                $tip.css({
                    top: Math.round(props.top),
                    left: Math.round(props.left)
                });
            }
        }, offset), 0), $tip.addClass("in");
        var actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
        "top" == placement && actualHeight != height && (offset.top = offset.top + height - actualHeight);
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        delta.left ? offset.left += delta.left : offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement), arrowDelta = isVertical ? 2 * delta.left - width + actualWidth : 2 * delta.top - height + actualHeight, arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset), this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
    }, Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "");
    }, Tooltip.prototype.setContent = function() {
        var $tip = this.tip(), title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title), $tip.removeClass("fade in top bottom left right");
    }, Tooltip.prototype.hide = function(callback) {
        function complete() {
            "in" != that.hoverState && $tip.detach(), that.$element && that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type), 
            callback && callback();
        }
        var that = this, $tip = $(this.$tip), e = $.Event("hide.bs." + this.type);
        if (this.$element.trigger(e), !e.isDefaultPrevented()) return $tip.removeClass("in"), 
        $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete(), 
        this.hoverState = null, this;
    }, Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        ($e.attr("title") || "string" != typeof $e.attr("data-original-title")) && $e.attr("data-original-title", $e.attr("title") || "").attr("title", "");
    }, Tooltip.prototype.hasContent = function() {
        return this.getTitle();
    }, Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0], isBody = "BODY" == el.tagName, elRect = el.getBoundingClientRect();
        null == elRect.width && (elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
        }));
        var isSvg = window.SVGElement && el instanceof window.SVGElement, elOffset = isBody ? {
            top: 0,
            left: 0
        } : isSvg ? null : $element.offset(), scroll = {
            scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
        }, outerDims = isBody ? {
            width: $(window).width(),
            height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
    }, Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return "bottom" == placement ? {
            top: pos.top + pos.height,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "top" == placement ? {
            top: pos.top - actualHeight,
            left: pos.left + pos.width / 2 - actualWidth / 2
        } : "left" == placement ? {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left - actualWidth
        } : {
            top: pos.top + pos.height / 2 - actualHeight / 2,
            left: pos.left + pos.width
        };
    }, Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
            top: 0,
            left: 0
        };
        if (!this.$viewport) return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0, viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll, bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            topEdgeOffset < viewportDimensions.top ? delta.top = viewportDimensions.top - topEdgeOffset : bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height && (delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset);
        } else {
            var leftEdgeOffset = pos.left - viewportPadding, rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            leftEdgeOffset < viewportDimensions.left ? delta.left = viewportDimensions.left - leftEdgeOffset : rightEdgeOffset > viewportDimensions.right && (delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset);
        }
        return delta;
    }, Tooltip.prototype.getTitle = function() {
        var title, $e = this.$element, o = this.options;
        return title = $e.attr("data-original-title") || ("function" == typeof o.title ? o.title.call($e[0]) : o.title);
    }, Tooltip.prototype.getUID = function(prefix) {
        do prefix += ~~(1e6 * Math.random()); while (document.getElementById(prefix));
        return prefix;
    }, Tooltip.prototype.tip = function() {
        if (!this.$tip && (this.$tip = $(this.options.template), 1 != this.$tip.length)) throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip;
    }, Tooltip.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow");
    }, Tooltip.prototype.enable = function() {
        this.enabled = !0;
    }, Tooltip.prototype.disable = function() {
        this.enabled = !1;
    }, Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
    }, Tooltip.prototype.toggle = function(e) {
        var self = this;
        e && (self = $(e.currentTarget).data("bs." + this.type), self || (self = new this.constructor(e.currentTarget, this.getDelegateOptions()), 
        $(e.currentTarget).data("bs." + this.type, self))), e ? (self.inState.click = !self.inState.click, 
        self.isInStateTrue() ? self.enter(self) : self.leave(self)) : self.tip().hasClass("in") ? self.leave(self) : self.enter(self);
    }, Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout), this.hide(function() {
            that.$element.off("." + that.type).removeData("bs." + that.type), that.$tip && that.$tip.detach(), 
            that.$tip = null, that.$arrow = null, that.$viewport = null, that.$element = null;
        });
    };
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin, $.fn.tooltip.Constructor = Tooltip, $.fn.tooltip.noConflict = function() {
        return $.fn.tooltip = old, this;
    };
}(jQuery), +function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.popover"), options = "object" == typeof option && option;
            !data && /destroy|hide/.test(option) || (data || $this.data("bs.popover", data = new Popover(this, options)), 
            "string" == typeof option && data[option]());
        });
    }
    var Popover = function(element, options) {
        this.init("popover", element, options);
    };
    if (!$.fn.tooltip) throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.7", Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype), Popover.prototype.constructor = Popover, 
    Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
    }, Popover.prototype.setContent = function() {
        var $tip = this.tip(), title = this.getTitle(), content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title), $tip.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof content ? "html" : "append" : "text"](content), 
        $tip.removeClass("fade top bottom left right in"), $tip.find(".popover-title").html() || $tip.find(".popover-title").hide();
    }, Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
    }, Popover.prototype.getContent = function() {
        var $e = this.$element, o = this.options;
        return $e.attr("data-content") || ("function" == typeof o.content ? o.content.call($e[0]) : o.content);
    }, Popover.prototype.arrow = function() {
        return this.$arrow = this.$arrow || this.tip().find(".arrow");
    };
    var old = $.fn.popover;
    $.fn.popover = Plugin, $.fn.popover.Constructor = Popover, $.fn.popover.noConflict = function() {
        return $.fn.popover = old, this;
    };
}(jQuery), +function($) {
    "use strict";
    function ScrollSpy(element, options) {
        this.$body = $(document.body), this.$scrollElement = $($(element).is(document.body) ? window : element), 
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options), this.selector = (this.options.target || "") + " .nav li > a", 
        this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, 
        this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this)), this.refresh(), 
        this.process();
    }
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.scrollspy"), options = "object" == typeof option && option;
            data || $this.data("bs.scrollspy", data = new ScrollSpy(this, options)), "string" == typeof option && data[option]();
        });
    }
    ScrollSpy.VERSION = "3.3.7", ScrollSpy.DEFAULTS = {
        offset: 10
    }, ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
    }, ScrollSpy.prototype.refresh = function() {
        var that = this, offsetMethod = "offset", offsetBase = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), 
        $.isWindow(this.$scrollElement[0]) || (offsetMethod = "position", offsetBase = this.$scrollElement.scrollTop()), 
        this.$body.find(this.selector).map(function() {
            var $el = $(this), href = $el.data("target") || $el.attr("href"), $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") && [ [ $href[offsetMethod]().top + offsetBase, href ] ] || null;
        }).sort(function(a, b) {
            return a[0] - b[0];
        }).each(function() {
            that.offsets.push(this[0]), that.targets.push(this[1]);
        });
    }, ScrollSpy.prototype.process = function() {
        var i, scrollTop = this.$scrollElement.scrollTop() + this.options.offset, scrollHeight = this.getScrollHeight(), maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height(), offsets = this.offsets, targets = this.targets, activeTarget = this.activeTarget;
        if (this.scrollHeight != scrollHeight && this.refresh(), scrollTop >= maxScroll) return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        if (activeTarget && scrollTop < offsets[0]) return this.activeTarget = null, this.clear();
        for (i = offsets.length; i--; ) activeTarget != targets[i] && scrollTop >= offsets[i] && (void 0 === offsets[i + 1] || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
    }, ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target, this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]', active = $(selector).parents("li").addClass("active");
        active.parent(".dropdown-menu").length && (active = active.closest("li.dropdown").addClass("active")), 
        active.trigger("activate.bs.scrollspy");
    }, ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active");
    };
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin, $.fn.scrollspy.Constructor = ScrollSpy, $.fn.scrollspy.noConflict = function() {
        return $.fn.scrollspy = old, this;
    }, $(window).on("load.bs.scrollspy.data-api", function() {
        $('[data-spy="scroll"]').each(function() {
            var $spy = $(this);
            Plugin.call($spy, $spy.data());
        });
    });
}(jQuery), +function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.tab");
            data || $this.data("bs.tab", data = new Tab(this)), "string" == typeof option && data[option]();
        });
    }
    var Tab = function(element) {
        this.element = $(element);
    };
    Tab.VERSION = "3.3.7", Tab.TRANSITION_DURATION = 150, Tab.prototype.show = function() {
        var $this = this.element, $ul = $this.closest("ul:not(.dropdown-menu)"), selector = $this.data("target");
        if (selector || (selector = $this.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "")), 
        !$this.parent("li").hasClass("active")) {
            var $previous = $ul.find(".active:last a"), hideEvent = $.Event("hide.bs.tab", {
                relatedTarget: $this[0]
            }), showEvent = $.Event("show.bs.tab", {
                relatedTarget: $previous[0]
            });
            if ($previous.trigger(hideEvent), $this.trigger(showEvent), !showEvent.isDefaultPrevented() && !hideEvent.isDefaultPrevented()) {
                var $target = $(selector);
                this.activate($this.closest("li"), $ul), this.activate($target, $target.parent(), function() {
                    $previous.trigger({
                        type: "hidden.bs.tab",
                        relatedTarget: $this[0]
                    }), $this.trigger({
                        type: "shown.bs.tab",
                        relatedTarget: $previous[0]
                    });
                });
            }
        }
    }, Tab.prototype.activate = function(element, container, callback) {
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), 
            element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), 
            transition ? (element[0].offsetWidth, element.addClass("in")) : element.removeClass("fade"), 
            element.parent(".dropdown-menu").length && element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), 
            callback && callback();
        }
        var $active = container.find("> .active"), transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next(), 
        $active.removeClass("in");
    };
    var old = $.fn.tab;
    $.fn.tab = Plugin, $.fn.tab.Constructor = Tab, $.fn.tab.noConflict = function() {
        return $.fn.tab = old, this;
    };
    var clickHandler = function(e) {
        e.preventDefault(), Plugin.call($(this), "show");
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler);
}(jQuery), +function($) {
    "use strict";
    function Plugin(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("bs.affix"), options = "object" == typeof option && option;
            data || $this.data("bs.affix", data = new Affix(this, options)), "string" == typeof option && data[option]();
        });
    }
    var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options), this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this)), 
        this.$element = $(element), this.affixed = null, this.unpin = null, this.pinnedOffset = null, 
        this.checkPosition();
    };
    Affix.VERSION = "3.3.7", Affix.RESET = "affix affix-top affix-bottom", Affix.DEFAULTS = {
        offset: 0,
        target: window
    }, Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop(), position = this.$element.offset(), targetHeight = this.$target.height();
        if (null != offsetTop && "top" == this.affixed) return scrollTop < offsetTop && "top";
        if ("bottom" == this.affixed) return null != offsetTop ? !(scrollTop + this.unpin <= position.top) && "bottom" : !(scrollTop + targetHeight <= scrollHeight - offsetBottom) && "bottom";
        var initializing = null == this.affixed, colliderTop = initializing ? scrollTop : position.top, colliderHeight = initializing ? targetHeight : height;
        return null != offsetTop && scrollTop <= offsetTop ? "top" : null != offsetBottom && colliderTop + colliderHeight >= scrollHeight - offsetBottom && "bottom";
    }, Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset) return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop(), position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop;
    }, Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
    }, Affix.prototype.checkPosition = function() {
        if (this.$element.is(":visible")) {
            var height = this.$element.height(), offset = this.options.offset, offsetTop = offset.top, offsetBottom = offset.bottom, scrollHeight = Math.max($(document).height(), $(document.body).height());
            "object" != typeof offset && (offsetBottom = offsetTop = offset), "function" == typeof offsetTop && (offsetTop = offset.top(this.$element)), 
            "function" == typeof offsetBottom && (offsetBottom = offset.bottom(this.$element));
            var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
            if (this.affixed != affix) {
                null != this.unpin && this.$element.css("top", "");
                var affixType = "affix" + (affix ? "-" + affix : ""), e = $.Event(affixType + ".bs.affix");
                if (this.$element.trigger(e), e.isDefaultPrevented()) return;
                this.affixed = affix, this.unpin = "bottom" == affix ? this.getPinnedOffset() : null, 
                this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix");
            }
            "bottom" == affix && this.$element.offset({
                top: scrollHeight - height - offsetBottom
            });
        }
    };
    var old = $.fn.affix;
    $.fn.affix = Plugin, $.fn.affix.Constructor = Affix, $.fn.affix.noConflict = function() {
        return $.fn.affix = old, this;
    }, $(window).on("load", function() {
        $('[data-spy="affix"]').each(function() {
            var $spy = $(this), data = $spy.data();
            data.offset = data.offset || {}, null != data.offsetBottom && (data.offset.bottom = data.offsetBottom), 
            null != data.offsetTop && (data.offset.top = data.offsetTop), Plugin.call($spy, data);
        });
    });
}(jQuery), function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : factory("object" == typeof exports ? require("jquery") : jQuery);
}(function($, undefined) {
    function UTCDate() {
        return new Date(Date.UTC.apply(Date, arguments));
    }
    function UTCToday() {
        var today = new Date();
        return UTCDate(today.getFullYear(), today.getMonth(), today.getDate());
    }
    function isUTCEquals(date1, date2) {
        return date1.getUTCFullYear() === date2.getUTCFullYear() && date1.getUTCMonth() === date2.getUTCMonth() && date1.getUTCDate() === date2.getUTCDate();
    }
    function alias(method) {
        return function() {
            return this[method].apply(this, arguments);
        };
    }
    function isValidDate(d) {
        return d && !isNaN(d.getTime());
    }
    function opts_from_el(el, prefix) {
        function re_lower(_, a) {
            return a.toLowerCase();
        }
        var inkey, data = $(el).data(), out = {}, replace = new RegExp("^" + prefix.toLowerCase() + "([A-Z])");
        prefix = new RegExp("^" + prefix.toLowerCase());
        for (var key in data) prefix.test(key) && (inkey = key.replace(replace, re_lower), 
        out[inkey] = data[key]);
        return out;
    }
    function opts_from_locale(lang) {
        var out = {};
        if (dates[lang] || (lang = lang.split("-")[0], dates[lang])) {
            var d = dates[lang];
            return $.each(locale_opts, function(i, k) {
                k in d && (out[k] = d[k]);
            }), out;
        }
    }
    var DateArray = function() {
        var extras = {
            get: function(i) {
                return this.slice(i)[0];
            },
            contains: function(d) {
                for (var val = d && d.valueOf(), i = 0, l = this.length; i < l; i++) if (this[i].valueOf() === val) return i;
                return -1;
            },
            remove: function(i) {
                this.splice(i, 1);
            },
            replace: function(new_array) {
                new_array && ($.isArray(new_array) || (new_array = [ new_array ]), this.clear(), 
                this.push.apply(this, new_array));
            },
            clear: function() {
                this.length = 0;
            },
            copy: function() {
                var a = new DateArray();
                return a.replace(this), a;
            }
        };
        return function() {
            var a = [];
            return a.push.apply(a, arguments), $.extend(a, extras), a;
        };
    }(), Datepicker = function(element, options) {
        $(element).data("datepicker", this), this._process_options(options), this.dates = new DateArray(), 
        this.viewDate = this.o.defaultViewDate, this.focusDate = null, this.element = $(element), 
        this.isInput = this.element.is("input"), this.inputField = this.isInput ? this.element : this.element.find("input"), 
        this.component = !!this.element.hasClass("date") && this.element.find(".add-on, .input-group-addon, .btn"), 
        this.hasInput = this.component && this.inputField.length, this.component && 0 === this.component.length && (this.component = !1), 
        this.isInline = !this.component && this.element.is("div"), this.picker = $(DPGlobal.template), 
        this._check_template(this.o.templates.leftArrow) && this.picker.find(".prev").html(this.o.templates.leftArrow), 
        this._check_template(this.o.templates.rightArrow) && this.picker.find(".next").html(this.o.templates.rightArrow), 
        this._buildEvents(), this._attachEvents(), this.isInline ? this.picker.addClass("datepicker-inline").appendTo(this.element) : this.picker.addClass("datepicker-dropdown dropdown-menu"), 
        this.o.rtl && this.picker.addClass("datepicker-rtl"), this.viewMode = this.o.startView, 
        this.o.calendarWeeks && this.picker.find("thead .datepicker-title, tfoot .today, tfoot .clear").attr("colspan", function(i, val) {
            return parseInt(val) + 1;
        }), this._allow_update = !1, this.setStartDate(this._o.startDate), this.setEndDate(this._o.endDate), 
        this.setDaysOfWeekDisabled(this.o.daysOfWeekDisabled), this.setDaysOfWeekHighlighted(this.o.daysOfWeekHighlighted), 
        this.setDatesDisabled(this.o.datesDisabled), this.fillDow(), this.fillMonths(), 
        this._allow_update = !0, this.update(), this.showMode(), this.isInline && this.show();
    };
    Datepicker.prototype = {
        constructor: Datepicker,
        _resolveViewName: function(view, default_value) {
            return 0 === view || "days" === view || "month" === view ? 0 : 1 === view || "months" === view || "year" === view ? 1 : 2 === view || "years" === view || "decade" === view ? 2 : 3 === view || "decades" === view || "century" === view ? 3 : 4 === view || "centuries" === view || "millennium" === view ? 4 : default_value !== undefined && default_value;
        },
        _check_template: function(tmp) {
            try {
                if (tmp === undefined || "" === tmp) return !1;
                if ((tmp.match(/[<>]/g) || []).length <= 0) return !0;
                var jDom = $(tmp);
                return jDom.length > 0;
            } catch (ex) {
                return !1;
            }
        },
        _process_options: function(opts) {
            this._o = $.extend({}, this._o, opts);
            var o = this.o = $.extend({}, this._o), lang = o.language;
            dates[lang] || (lang = lang.split("-")[0], dates[lang] || (lang = defaults.language)), 
            o.language = lang, o.startView = this._resolveViewName(o.startView, 0), o.minViewMode = this._resolveViewName(o.minViewMode, 0), 
            o.maxViewMode = this._resolveViewName(o.maxViewMode, 4), o.startView = Math.min(o.startView, o.maxViewMode), 
            o.startView = Math.max(o.startView, o.minViewMode), o.multidate !== !0 && (o.multidate = Number(o.multidate) || !1, 
            o.multidate !== !1 && (o.multidate = Math.max(0, o.multidate))), o.multidateSeparator = String(o.multidateSeparator), 
            o.weekStart %= 7, o.weekEnd = (o.weekStart + 6) % 7;
            var format = DPGlobal.parseFormat(o.format);
            o.startDate !== -(1 / 0) && (o.startDate ? o.startDate instanceof Date ? o.startDate = this._local_to_utc(this._zero_time(o.startDate)) : o.startDate = DPGlobal.parseDate(o.startDate, format, o.language, o.assumeNearbyYear) : o.startDate = -(1 / 0)), 
            o.endDate !== 1 / 0 && (o.endDate ? o.endDate instanceof Date ? o.endDate = this._local_to_utc(this._zero_time(o.endDate)) : o.endDate = DPGlobal.parseDate(o.endDate, format, o.language, o.assumeNearbyYear) : o.endDate = 1 / 0), 
            o.daysOfWeekDisabled = o.daysOfWeekDisabled || [], $.isArray(o.daysOfWeekDisabled) || (o.daysOfWeekDisabled = o.daysOfWeekDisabled.split(/[,\s]*/)), 
            o.daysOfWeekDisabled = $.map(o.daysOfWeekDisabled, function(d) {
                return parseInt(d, 10);
            }), o.daysOfWeekHighlighted = o.daysOfWeekHighlighted || [], $.isArray(o.daysOfWeekHighlighted) || (o.daysOfWeekHighlighted = o.daysOfWeekHighlighted.split(/[,\s]*/)), 
            o.daysOfWeekHighlighted = $.map(o.daysOfWeekHighlighted, function(d) {
                return parseInt(d, 10);
            }), o.datesDisabled = o.datesDisabled || [], $.isArray(o.datesDisabled) || (o.datesDisabled = [ o.datesDisabled ]), 
            o.datesDisabled = $.map(o.datesDisabled, function(d) {
                return DPGlobal.parseDate(d, format, o.language, o.assumeNearbyYear);
            });
            var plc = String(o.orientation).toLowerCase().split(/\s+/g), _plc = o.orientation.toLowerCase();
            if (plc = $.grep(plc, function(word) {
                return /^auto|left|right|top|bottom$/.test(word);
            }), o.orientation = {
                x: "auto",
                y: "auto"
            }, _plc && "auto" !== _plc) if (1 === plc.length) switch (plc[0]) {
              case "top":
              case "bottom":
                o.orientation.y = plc[0];
                break;

              case "left":
              case "right":
                o.orientation.x = plc[0];
            } else _plc = $.grep(plc, function(word) {
                return /^left|right$/.test(word);
            }), o.orientation.x = _plc[0] || "auto", _plc = $.grep(plc, function(word) {
                return /^top|bottom$/.test(word);
            }), o.orientation.y = _plc[0] || "auto"; else ;
            if (o.defaultViewDate) {
                var year = o.defaultViewDate.year || new Date().getFullYear(), month = o.defaultViewDate.month || 0, day = o.defaultViewDate.day || 1;
                o.defaultViewDate = UTCDate(year, month, day);
            } else o.defaultViewDate = UTCToday();
        },
        _events: [],
        _secondaryEvents: [],
        _applyEvents: function(evs) {
            for (var el, ch, ev, i = 0; i < evs.length; i++) el = evs[i][0], 2 === evs[i].length ? (ch = undefined, 
            ev = evs[i][1]) : 3 === evs[i].length && (ch = evs[i][1], ev = evs[i][2]), el.on(ev, ch);
        },
        _unapplyEvents: function(evs) {
            for (var el, ev, ch, i = 0; i < evs.length; i++) el = evs[i][0], 2 === evs[i].length ? (ch = undefined, 
            ev = evs[i][1]) : 3 === evs[i].length && (ch = evs[i][1], ev = evs[i][2]), el.off(ev, ch);
        },
        _buildEvents: function() {
            var events = {
                keyup: $.proxy(function(e) {
                    $.inArray(e.keyCode, [ 27, 37, 39, 38, 40, 32, 13, 9 ]) === -1 && this.update();
                }, this),
                keydown: $.proxy(this.keydown, this),
                paste: $.proxy(this.paste, this)
            };
            this.o.showOnFocus === !0 && (events.focus = $.proxy(this.show, this)), this.isInput ? this._events = [ [ this.element, events ] ] : this.component && this.hasInput ? this._events = [ [ this.inputField, events ], [ this.component, {
                click: $.proxy(this.show, this)
            } ] ] : this._events = [ [ this.element, {
                click: $.proxy(this.show, this),
                keydown: $.proxy(this.keydown, this)
            } ] ], this._events.push([ this.element, "*", {
                blur: $.proxy(function(e) {
                    this._focused_from = e.target;
                }, this)
            } ], [ this.element, {
                blur: $.proxy(function(e) {
                    this._focused_from = e.target;
                }, this)
            } ]), this.o.immediateUpdates && this._events.push([ this.element, {
                "changeYear changeMonth": $.proxy(function(e) {
                    this.update(e.date);
                }, this)
            } ]), this._secondaryEvents = [ [ this.picker, {
                click: $.proxy(this.click, this)
            } ], [ $(window), {
                resize: $.proxy(this.place, this)
            } ], [ $(document), {
                mousedown: $.proxy(function(e) {
                    this.element.is(e.target) || this.element.find(e.target).length || this.picker.is(e.target) || this.picker.find(e.target).length || this.isInline || this.hide();
                }, this)
            } ] ];
        },
        _attachEvents: function() {
            this._detachEvents(), this._applyEvents(this._events);
        },
        _detachEvents: function() {
            this._unapplyEvents(this._events);
        },
        _attachSecondaryEvents: function() {
            this._detachSecondaryEvents(), this._applyEvents(this._secondaryEvents);
        },
        _detachSecondaryEvents: function() {
            this._unapplyEvents(this._secondaryEvents);
        },
        _trigger: function(event, altdate) {
            var date = altdate || this.dates.get(-1), local_date = this._utc_to_local(date);
            this.element.trigger({
                type: event,
                date: local_date,
                dates: $.map(this.dates, this._utc_to_local),
                format: $.proxy(function(ix, format) {
                    0 === arguments.length ? (ix = this.dates.length - 1, format = this.o.format) : "string" == typeof ix && (format = ix, 
                    ix = this.dates.length - 1), format = format || this.o.format;
                    var date = this.dates.get(ix);
                    return DPGlobal.formatDate(date, format, this.o.language);
                }, this)
            });
        },
        show: function() {
            if (!(this.inputField.prop("disabled") || this.inputField.prop("readonly") && this.o.enableOnReadonly === !1)) return this.isInline || this.picker.appendTo(this.o.container), 
            this.place(), this.picker.show(), this._attachSecondaryEvents(), this._trigger("show"), 
            (window.navigator.msMaxTouchPoints || "ontouchstart" in document) && this.o.disableTouchKeyboard && $(this.element).blur(), 
            this;
        },
        hide: function() {
            return this.isInline || !this.picker.is(":visible") ? this : (this.focusDate = null, 
            this.picker.hide().detach(), this._detachSecondaryEvents(), this.viewMode = this.o.startView, 
            this.showMode(), this.o.forceParse && this.inputField.val() && this.setValue(), 
            this._trigger("hide"), this);
        },
        destroy: function() {
            return this.hide(), this._detachEvents(), this._detachSecondaryEvents(), this.picker.remove(), 
            delete this.element.data().datepicker, this.isInput || delete this.element.data().date, 
            this;
        },
        paste: function(evt) {
            var dateString;
            if (evt.originalEvent.clipboardData && evt.originalEvent.clipboardData.types && $.inArray("text/plain", evt.originalEvent.clipboardData.types) !== -1) dateString = evt.originalEvent.clipboardData.getData("text/plain"); else {
                if (!window.clipboardData) return;
                dateString = window.clipboardData.getData("Text");
            }
            this.setDate(dateString), this.update(), evt.preventDefault();
        },
        _utc_to_local: function(utc) {
            return utc && new Date(utc.getTime() + 6e4 * utc.getTimezoneOffset());
        },
        _local_to_utc: function(local) {
            return local && new Date(local.getTime() - 6e4 * local.getTimezoneOffset());
        },
        _zero_time: function(local) {
            return local && new Date(local.getFullYear(), local.getMonth(), local.getDate());
        },
        _zero_utc_time: function(utc) {
            return utc && new Date(Date.UTC(utc.getUTCFullYear(), utc.getUTCMonth(), utc.getUTCDate()));
        },
        getDates: function() {
            return $.map(this.dates, this._utc_to_local);
        },
        getUTCDates: function() {
            return $.map(this.dates, function(d) {
                return new Date(d);
            });
        },
        getDate: function() {
            return this._utc_to_local(this.getUTCDate());
        },
        getUTCDate: function() {
            var selected_date = this.dates.get(-1);
            return "undefined" != typeof selected_date ? new Date(selected_date) : null;
        },
        clearDates: function() {
            this.inputField && this.inputField.val(""), this.update(), this._trigger("changeDate"), 
            this.o.autoclose && this.hide();
        },
        setDates: function() {
            var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
            return this.update.apply(this, args), this._trigger("changeDate"), this.setValue(), 
            this;
        },
        setUTCDates: function() {
            var args = $.isArray(arguments[0]) ? arguments[0] : arguments;
            return this.update.apply(this, $.map(args, this._utc_to_local)), this._trigger("changeDate"), 
            this.setValue(), this;
        },
        setDate: alias("setDates"),
        setUTCDate: alias("setUTCDates"),
        remove: alias("destroy"),
        setValue: function() {
            var formatted = this.getFormattedDate();
            return this.inputField.val(formatted), this;
        },
        getFormattedDate: function(format) {
            format === undefined && (format = this.o.format);
            var lang = this.o.language;
            return $.map(this.dates, function(d) {
                return DPGlobal.formatDate(d, format, lang);
            }).join(this.o.multidateSeparator);
        },
        getStartDate: function() {
            return this.o.startDate;
        },
        setStartDate: function(startDate) {
            return this._process_options({
                startDate: startDate
            }), this.update(), this.updateNavArrows(), this;
        },
        getEndDate: function() {
            return this.o.endDate;
        },
        setEndDate: function(endDate) {
            return this._process_options({
                endDate: endDate
            }), this.update(), this.updateNavArrows(), this;
        },
        setDaysOfWeekDisabled: function(daysOfWeekDisabled) {
            return this._process_options({
                daysOfWeekDisabled: daysOfWeekDisabled
            }), this.update(), this.updateNavArrows(), this;
        },
        setDaysOfWeekHighlighted: function(daysOfWeekHighlighted) {
            return this._process_options({
                daysOfWeekHighlighted: daysOfWeekHighlighted
            }), this.update(), this;
        },
        setDatesDisabled: function(datesDisabled) {
            this._process_options({
                datesDisabled: datesDisabled
            }), this.update(), this.updateNavArrows();
        },
        place: function() {
            if (this.isInline) return this;
            var calendarWidth = this.picker.outerWidth(), calendarHeight = this.picker.outerHeight(), visualPadding = 10, container = $(this.o.container), windowWidth = container.width(), scrollTop = "body" === this.o.container ? $(document).scrollTop() : container.scrollTop(), appendOffset = container.offset(), parentsZindex = [];
            this.element.parents().each(function() {
                var itemZIndex = $(this).css("z-index");
                "auto" !== itemZIndex && 0 !== itemZIndex && parentsZindex.push(parseInt(itemZIndex));
            });
            var zIndex = Math.max.apply(Math, parentsZindex) + this.o.zIndexOffset, offset = this.component ? this.component.parent().offset() : this.element.offset(), height = this.component ? this.component.outerHeight(!0) : this.element.outerHeight(!1), width = this.component ? this.component.outerWidth(!0) : this.element.outerWidth(!1), left = offset.left - appendOffset.left, top = offset.top - appendOffset.top;
            "body" !== this.o.container && (top += scrollTop), this.picker.removeClass("datepicker-orient-top datepicker-orient-bottom datepicker-orient-right datepicker-orient-left"), 
            "auto" !== this.o.orientation.x ? (this.picker.addClass("datepicker-orient-" + this.o.orientation.x), 
            "right" === this.o.orientation.x && (left -= calendarWidth - width)) : offset.left < 0 ? (this.picker.addClass("datepicker-orient-left"), 
            left -= offset.left - visualPadding) : left + calendarWidth > windowWidth ? (this.picker.addClass("datepicker-orient-right"), 
            left += width - calendarWidth) : this.picker.addClass("datepicker-orient-left");
            var top_overflow, yorient = this.o.orientation.y;
            if ("auto" === yorient && (top_overflow = -scrollTop + top - calendarHeight, yorient = top_overflow < 0 ? "bottom" : "top"), 
            this.picker.addClass("datepicker-orient-" + yorient), "top" === yorient ? top -= calendarHeight + parseInt(this.picker.css("padding-top")) : top += height, 
            this.o.rtl) {
                var right = windowWidth - (left + width);
                this.picker.css({
                    top: top,
                    right: right,
                    zIndex: zIndex
                });
            } else this.picker.css({
                top: top,
                left: left,
                zIndex: zIndex
            });
            return this;
        },
        _allow_update: !0,
        update: function() {
            if (!this._allow_update) return this;
            var oldDates = this.dates.copy(), dates = [], fromArgs = !1;
            return arguments.length ? ($.each(arguments, $.proxy(function(i, date) {
                date instanceof Date && (date = this._local_to_utc(date)), dates.push(date);
            }, this)), fromArgs = !0) : (dates = this.isInput ? this.element.val() : this.element.data("date") || this.inputField.val(), 
            dates = dates && this.o.multidate ? dates.split(this.o.multidateSeparator) : [ dates ], 
            delete this.element.data().date), dates = $.map(dates, $.proxy(function(date) {
                return DPGlobal.parseDate(date, this.o.format, this.o.language, this.o.assumeNearbyYear);
            }, this)), dates = $.grep(dates, $.proxy(function(date) {
                return !this.dateWithinRange(date) || !date;
            }, this), !0), this.dates.replace(dates), this.dates.length ? this.viewDate = new Date(this.dates.get(-1)) : this.viewDate < this.o.startDate ? this.viewDate = new Date(this.o.startDate) : this.viewDate > this.o.endDate ? this.viewDate = new Date(this.o.endDate) : this.viewDate = this.o.defaultViewDate, 
            fromArgs ? this.setValue() : dates.length && String(oldDates) !== String(this.dates) && this._trigger("changeDate"), 
            !this.dates.length && oldDates.length && this._trigger("clearDate"), this.fill(), 
            this.element.change(), this;
        },
        fillDow: function() {
            var dowCnt = this.o.weekStart, html = "<tr>";
            for (this.o.calendarWeeks && (this.picker.find(".datepicker-days .datepicker-switch").attr("colspan", function(i, val) {
                return parseInt(val) + 1;
            }), html += '<th class="cw">&#160;</th>'); dowCnt < this.o.weekStart + 7; ) html += '<th class="dow', 
            $.inArray(dowCnt, this.o.daysOfWeekDisabled) > -1 && (html += " disabled"), html += '">' + dates[this.o.language].daysMin[dowCnt++ % 7] + "</th>";
            html += "</tr>", this.picker.find(".datepicker-days thead").append(html);
        },
        fillMonths: function() {
            for (var localDate = this._utc_to_local(this.viewDate), html = "", i = 0; i < 12; ) {
                var focused = localDate && localDate.getMonth() === i ? " focused" : "";
                html += '<span class="month' + focused + '">' + dates[this.o.language].monthsShort[i++] + "</span>";
            }
            this.picker.find(".datepicker-months td").html(html);
        },
        setRange: function(range) {
            range && range.length ? this.range = $.map(range, function(d) {
                return d.valueOf();
            }) : delete this.range, this.fill();
        },
        getClassNames: function(date) {
            var cls = [], year = this.viewDate.getUTCFullYear(), month = this.viewDate.getUTCMonth(), today = new Date();
            return date.getUTCFullYear() < year || date.getUTCFullYear() === year && date.getUTCMonth() < month ? cls.push("old") : (date.getUTCFullYear() > year || date.getUTCFullYear() === year && date.getUTCMonth() > month) && cls.push("new"), 
            this.focusDate && date.valueOf() === this.focusDate.valueOf() && cls.push("focused"), 
            this.o.todayHighlight && date.getUTCFullYear() === today.getFullYear() && date.getUTCMonth() === today.getMonth() && date.getUTCDate() === today.getDate() && cls.push("today"), 
            this.dates.contains(date) !== -1 && cls.push("active"), this.dateWithinRange(date) || cls.push("disabled"), 
            this.dateIsDisabled(date) && cls.push("disabled", "disabled-date"), $.inArray(date.getUTCDay(), this.o.daysOfWeekHighlighted) !== -1 && cls.push("highlighted"), 
            this.range && (date > this.range[0] && date < this.range[this.range.length - 1] && cls.push("range"), 
            $.inArray(date.valueOf(), this.range) !== -1 && cls.push("selected"), date.valueOf() === this.range[0] && cls.push("range-start"), 
            date.valueOf() === this.range[this.range.length - 1] && cls.push("range-end")), 
            cls;
        },
        _fill_yearsView: function(selector, cssClass, factor, step, currentYear, startYear, endYear, callback) {
            var html, view, year, steps, startStep, endStep, thisYear, i, classes, tooltip, before;
            for (html = "", view = this.picker.find(selector), year = parseInt(currentYear / factor, 10) * factor, 
            startStep = parseInt(startYear / step, 10) * step, endStep = parseInt(endYear / step, 10) * step, 
            steps = $.map(this.dates, function(d) {
                return parseInt(d.getUTCFullYear() / step, 10) * step;
            }), view.find(".datepicker-switch").text(year + "-" + (year + 9 * step)), thisYear = year - step, 
            i = -1; i < 11; i += 1) classes = [ cssClass ], tooltip = null, i === -1 ? classes.push("old") : 10 === i && classes.push("new"), 
            $.inArray(thisYear, steps) !== -1 && classes.push("active"), (thisYear < startStep || thisYear > endStep) && classes.push("disabled"), 
            thisYear === this.viewDate.getFullYear() && classes.push("focused"), callback !== $.noop && (before = callback(new Date(thisYear, 0, 1)), 
            before === undefined ? before = {} : "boolean" == typeof before ? before = {
                enabled: before
            } : "string" == typeof before && (before = {
                classes: before
            }), before.enabled === !1 && classes.push("disabled"), before.classes && (classes = classes.concat(before.classes.split(/\s+/))), 
            before.tooltip && (tooltip = before.tooltip)), html += '<span class="' + classes.join(" ") + '"' + (tooltip ? ' title="' + tooltip + '"' : "") + ">" + thisYear + "</span>", 
            thisYear += step;
            view.find("td").html(html);
        },
        fill: function() {
            var tooltip, before, d = new Date(this.viewDate), year = d.getUTCFullYear(), month = d.getUTCMonth(), startYear = this.o.startDate !== -(1 / 0) ? this.o.startDate.getUTCFullYear() : -(1 / 0), startMonth = this.o.startDate !== -(1 / 0) ? this.o.startDate.getUTCMonth() : -(1 / 0), endYear = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCFullYear() : 1 / 0, endMonth = this.o.endDate !== 1 / 0 ? this.o.endDate.getUTCMonth() : 1 / 0, todaytxt = dates[this.o.language].today || dates.en.today || "", cleartxt = dates[this.o.language].clear || dates.en.clear || "", titleFormat = dates[this.o.language].titleFormat || dates.en.titleFormat;
            if (!isNaN(year) && !isNaN(month)) {
                this.picker.find(".datepicker-days .datepicker-switch").text(DPGlobal.formatDate(d, titleFormat, this.o.language)), 
                this.picker.find("tfoot .today").text(todaytxt).toggle(this.o.todayBtn !== !1), 
                this.picker.find("tfoot .clear").text(cleartxt).toggle(this.o.clearBtn !== !1), 
                this.picker.find("thead .datepicker-title").text(this.o.title).toggle("" !== this.o.title), 
                this.updateNavArrows(), this.fillMonths();
                var prevMonth = UTCDate(year, month - 1, 28), day = DPGlobal.getDaysInMonth(prevMonth.getUTCFullYear(), prevMonth.getUTCMonth());
                prevMonth.setUTCDate(day), prevMonth.setUTCDate(day - (prevMonth.getUTCDay() - this.o.weekStart + 7) % 7);
                var nextMonth = new Date(prevMonth);
                prevMonth.getUTCFullYear() < 100 && nextMonth.setUTCFullYear(prevMonth.getUTCFullYear()), 
                nextMonth.setUTCDate(nextMonth.getUTCDate() + 42), nextMonth = nextMonth.valueOf();
                for (var clsName, html = []; prevMonth.valueOf() < nextMonth; ) {
                    if (prevMonth.getUTCDay() === this.o.weekStart && (html.push("<tr>"), this.o.calendarWeeks)) {
                        var ws = new Date(+prevMonth + (this.o.weekStart - prevMonth.getUTCDay() - 7) % 7 * 864e5), th = new Date(Number(ws) + (11 - ws.getUTCDay()) % 7 * 864e5), yth = new Date(Number(yth = UTCDate(th.getUTCFullYear(), 0, 1)) + (11 - yth.getUTCDay()) % 7 * 864e5), calWeek = (th - yth) / 864e5 / 7 + 1;
                        html.push('<td class="cw">' + calWeek + "</td>");
                    }
                    clsName = this.getClassNames(prevMonth), clsName.push("day"), this.o.beforeShowDay !== $.noop && (before = this.o.beforeShowDay(this._utc_to_local(prevMonth)), 
                    before === undefined ? before = {} : "boolean" == typeof before ? before = {
                        enabled: before
                    } : "string" == typeof before && (before = {
                        classes: before
                    }), before.enabled === !1 && clsName.push("disabled"), before.classes && (clsName = clsName.concat(before.classes.split(/\s+/))), 
                    before.tooltip && (tooltip = before.tooltip)), clsName = $.isFunction($.uniqueSort) ? $.uniqueSort(clsName) : $.unique(clsName), 
                    html.push('<td class="' + clsName.join(" ") + '"' + (tooltip ? ' title="' + tooltip + '"' : "") + ">" + prevMonth.getUTCDate() + "</td>"), 
                    tooltip = null, prevMonth.getUTCDay() === this.o.weekEnd && html.push("</tr>"), 
                    prevMonth.setUTCDate(prevMonth.getUTCDate() + 1);
                }
                this.picker.find(".datepicker-days tbody").empty().append(html.join(""));
                var monthsTitle = dates[this.o.language].monthsTitle || dates.en.monthsTitle || "Months", months = this.picker.find(".datepicker-months").find(".datepicker-switch").text(this.o.maxViewMode < 2 ? monthsTitle : year).end().find("span").removeClass("active");
                if ($.each(this.dates, function(i, d) {
                    d.getUTCFullYear() === year && months.eq(d.getUTCMonth()).addClass("active");
                }), (year < startYear || year > endYear) && months.addClass("disabled"), year === startYear && months.slice(0, startMonth).addClass("disabled"), 
                year === endYear && months.slice(endMonth + 1).addClass("disabled"), this.o.beforeShowMonth !== $.noop) {
                    var that = this;
                    $.each(months, function(i, month) {
                        var moDate = new Date(year, i, 1), before = that.o.beforeShowMonth(moDate);
                        before === undefined ? before = {} : "boolean" == typeof before ? before = {
                            enabled: before
                        } : "string" == typeof before && (before = {
                            classes: before
                        }), before.enabled !== !1 || $(month).hasClass("disabled") || $(month).addClass("disabled"), 
                        before.classes && $(month).addClass(before.classes), before.tooltip && $(month).prop("title", before.tooltip);
                    });
                }
                this._fill_yearsView(".datepicker-years", "year", 10, 1, year, startYear, endYear, this.o.beforeShowYear), 
                this._fill_yearsView(".datepicker-decades", "decade", 100, 10, year, startYear, endYear, this.o.beforeShowDecade), 
                this._fill_yearsView(".datepicker-centuries", "century", 1e3, 100, year, startYear, endYear, this.o.beforeShowCentury);
            }
        },
        updateNavArrows: function() {
            if (this._allow_update) {
                var d = new Date(this.viewDate), year = d.getUTCFullYear(), month = d.getUTCMonth();
                switch (this.viewMode) {
                  case 0:
                    this.o.startDate !== -(1 / 0) && year <= this.o.startDate.getUTCFullYear() && month <= this.o.startDate.getUTCMonth() ? this.picker.find(".prev").css({
                        visibility: "hidden"
                    }) : this.picker.find(".prev").css({
                        visibility: "visible"
                    }), this.o.endDate !== 1 / 0 && year >= this.o.endDate.getUTCFullYear() && month >= this.o.endDate.getUTCMonth() ? this.picker.find(".next").css({
                        visibility: "hidden"
                    }) : this.picker.find(".next").css({
                        visibility: "visible"
                    });
                    break;

                  case 1:
                  case 2:
                  case 3:
                  case 4:
                    this.o.startDate !== -(1 / 0) && year <= this.o.startDate.getUTCFullYear() || this.o.maxViewMode < 2 ? this.picker.find(".prev").css({
                        visibility: "hidden"
                    }) : this.picker.find(".prev").css({
                        visibility: "visible"
                    }), this.o.endDate !== 1 / 0 && year >= this.o.endDate.getUTCFullYear() || this.o.maxViewMode < 2 ? this.picker.find(".next").css({
                        visibility: "hidden"
                    }) : this.picker.find(".next").css({
                        visibility: "visible"
                    });
                }
            }
        },
        click: function(e) {
            e.preventDefault(), e.stopPropagation();
            var target, dir, day, year, month, monthChanged, yearChanged;
            target = $(e.target), target.hasClass("datepicker-switch") && this.showMode(1);
            var navArrow = target.closest(".prev, .next");
            navArrow.length > 0 && (dir = DPGlobal.modes[this.viewMode].navStep * (navArrow.hasClass("prev") ? -1 : 1), 
            0 === this.viewMode ? (this.viewDate = this.moveMonth(this.viewDate, dir), this._trigger("changeMonth", this.viewDate)) : (this.viewDate = this.moveYear(this.viewDate, dir), 
            1 === this.viewMode && this._trigger("changeYear", this.viewDate)), this.fill()), 
            target.hasClass("today") && !target.hasClass("day") && (this.showMode(-2), this._setDate(UTCToday(), "linked" === this.o.todayBtn ? null : "view")), 
            target.hasClass("clear") && this.clearDates(), target.hasClass("disabled") || (target.hasClass("day") && (day = parseInt(target.text(), 10) || 1, 
            year = this.viewDate.getUTCFullYear(), month = this.viewDate.getUTCMonth(), target.hasClass("old") && (0 === month ? (month = 11, 
            year -= 1, monthChanged = !0, yearChanged = !0) : (month -= 1, monthChanged = !0)), 
            target.hasClass("new") && (11 === month ? (month = 0, year += 1, monthChanged = !0, 
            yearChanged = !0) : (month += 1, monthChanged = !0)), this._setDate(UTCDate(year, month, day)), 
            yearChanged && this._trigger("changeYear", this.viewDate), monthChanged && this._trigger("changeMonth", this.viewDate)), 
            target.hasClass("month") && (this.viewDate.setUTCDate(1), day = 1, month = target.parent().find("span").index(target), 
            year = this.viewDate.getUTCFullYear(), this.viewDate.setUTCMonth(month), this._trigger("changeMonth", this.viewDate), 
            1 === this.o.minViewMode ? (this._setDate(UTCDate(year, month, day)), this.showMode()) : this.showMode(-1), 
            this.fill()), (target.hasClass("year") || target.hasClass("decade") || target.hasClass("century")) && (this.viewDate.setUTCDate(1), 
            day = 1, month = 0, year = parseInt(target.text(), 10) || 0, this.viewDate.setUTCFullYear(year), 
            target.hasClass("year") && (this._trigger("changeYear", this.viewDate), 2 === this.o.minViewMode && this._setDate(UTCDate(year, month, day))), 
            target.hasClass("decade") && (this._trigger("changeDecade", this.viewDate), 3 === this.o.minViewMode && this._setDate(UTCDate(year, month, day))), 
            target.hasClass("century") && (this._trigger("changeCentury", this.viewDate), 4 === this.o.minViewMode && this._setDate(UTCDate(year, month, day))), 
            this.showMode(-1), this.fill())), this.picker.is(":visible") && this._focused_from && $(this._focused_from).focus(), 
            delete this._focused_from;
        },
        _toggle_multidate: function(date) {
            var ix = this.dates.contains(date);
            if (date || this.dates.clear(), ix !== -1 ? (this.o.multidate === !0 || this.o.multidate > 1 || this.o.toggleActive) && this.dates.remove(ix) : this.o.multidate === !1 ? (this.dates.clear(), 
            this.dates.push(date)) : this.dates.push(date), "number" == typeof this.o.multidate) for (;this.dates.length > this.o.multidate; ) this.dates.remove(0);
        },
        _setDate: function(date, which) {
            which && "date" !== which || this._toggle_multidate(date && new Date(date)), which && "view" !== which || (this.viewDate = date && new Date(date)), 
            this.fill(), this.setValue(), which && "view" === which || this._trigger("changeDate"), 
            this.inputField && this.inputField.change(), !this.o.autoclose || which && "date" !== which || this.hide();
        },
        moveDay: function(date, dir) {
            var newDate = new Date(date);
            return newDate.setUTCDate(date.getUTCDate() + dir), newDate;
        },
        moveWeek: function(date, dir) {
            return this.moveDay(date, 7 * dir);
        },
        moveMonth: function(date, dir) {
            if (!isValidDate(date)) return this.o.defaultViewDate;
            if (!dir) return date;
            var new_month, test, new_date = new Date(date.valueOf()), day = new_date.getUTCDate(), month = new_date.getUTCMonth(), mag = Math.abs(dir);
            if (dir = dir > 0 ? 1 : -1, 1 === mag) test = dir === -1 ? function() {
                return new_date.getUTCMonth() === month;
            } : function() {
                return new_date.getUTCMonth() !== new_month;
            }, new_month = month + dir, new_date.setUTCMonth(new_month), (new_month < 0 || new_month > 11) && (new_month = (new_month + 12) % 12); else {
                for (var i = 0; i < mag; i++) new_date = this.moveMonth(new_date, dir);
                new_month = new_date.getUTCMonth(), new_date.setUTCDate(day), test = function() {
                    return new_month !== new_date.getUTCMonth();
                };
            }
            for (;test(); ) new_date.setUTCDate(--day), new_date.setUTCMonth(new_month);
            return new_date;
        },
        moveYear: function(date, dir) {
            return this.moveMonth(date, 12 * dir);
        },
        moveAvailableDate: function(date, dir, fn) {
            do {
                if (date = this[fn](date, dir), !this.dateWithinRange(date)) return !1;
                fn = "moveDay";
            } while (this.dateIsDisabled(date));
            return date;
        },
        weekOfDateIsDisabled: function(date) {
            return $.inArray(date.getUTCDay(), this.o.daysOfWeekDisabled) !== -1;
        },
        dateIsDisabled: function(date) {
            return this.weekOfDateIsDisabled(date) || $.grep(this.o.datesDisabled, function(d) {
                return isUTCEquals(date, d);
            }).length > 0;
        },
        dateWithinRange: function(date) {
            return date >= this.o.startDate && date <= this.o.endDate;
        },
        keydown: function(e) {
            if (!this.picker.is(":visible")) return void (40 !== e.keyCode && 27 !== e.keyCode || (this.show(), 
            e.stopPropagation()));
            var dir, newViewDate, dateChanged = !1, focusDate = this.focusDate || this.viewDate;
            switch (e.keyCode) {
              case 27:
                this.focusDate ? (this.focusDate = null, this.viewDate = this.dates.get(-1) || this.viewDate, 
                this.fill()) : this.hide(), e.preventDefault(), e.stopPropagation();
                break;

              case 37:
              case 38:
              case 39:
              case 40:
                if (!this.o.keyboardNavigation || 7 === this.o.daysOfWeekDisabled.length) break;
                dir = 37 === e.keyCode || 38 === e.keyCode ? -1 : 1, 0 === this.viewMode ? e.ctrlKey ? (newViewDate = this.moveAvailableDate(focusDate, dir, "moveYear"), 
                newViewDate && this._trigger("changeYear", this.viewDate)) : e.shiftKey ? (newViewDate = this.moveAvailableDate(focusDate, dir, "moveMonth"), 
                newViewDate && this._trigger("changeMonth", this.viewDate)) : 37 === e.keyCode || 39 === e.keyCode ? newViewDate = this.moveAvailableDate(focusDate, dir, "moveDay") : this.weekOfDateIsDisabled(focusDate) || (newViewDate = this.moveAvailableDate(focusDate, dir, "moveWeek")) : 1 === this.viewMode ? (38 !== e.keyCode && 40 !== e.keyCode || (dir *= 4), 
                newViewDate = this.moveAvailableDate(focusDate, dir, "moveMonth")) : 2 === this.viewMode && (38 !== e.keyCode && 40 !== e.keyCode || (dir *= 4), 
                newViewDate = this.moveAvailableDate(focusDate, dir, "moveYear")), newViewDate && (this.focusDate = this.viewDate = newViewDate, 
                this.setValue(), this.fill(), e.preventDefault());
                break;

              case 13:
                if (!this.o.forceParse) break;
                focusDate = this.focusDate || this.dates.get(-1) || this.viewDate, this.o.keyboardNavigation && (this._toggle_multidate(focusDate), 
                dateChanged = !0), this.focusDate = null, this.viewDate = this.dates.get(-1) || this.viewDate, 
                this.setValue(), this.fill(), this.picker.is(":visible") && (e.preventDefault(), 
                e.stopPropagation(), this.o.autoclose && this.hide());
                break;

              case 9:
                this.focusDate = null, this.viewDate = this.dates.get(-1) || this.viewDate, this.fill(), 
                this.hide();
            }
            dateChanged && (this.dates.length ? this._trigger("changeDate") : this._trigger("clearDate"), 
            this.inputField && this.inputField.change());
        },
        showMode: function(dir) {
            dir && (this.viewMode = Math.max(this.o.minViewMode, Math.min(this.o.maxViewMode, this.viewMode + dir))), 
            this.picker.children("div").hide().filter(".datepicker-" + DPGlobal.modes[this.viewMode].clsName).show(), 
            this.updateNavArrows();
        }
    };
    var DateRangePicker = function(element, options) {
        $(element).data("datepicker", this), this.element = $(element), this.inputs = $.map(options.inputs, function(i) {
            return i.jquery ? i[0] : i;
        }), delete options.inputs, datepickerPlugin.call($(this.inputs), options).on("changeDate", $.proxy(this.dateUpdated, this)), 
        this.pickers = $.map(this.inputs, function(i) {
            return $(i).data("datepicker");
        }), this.updateDates();
    };
    DateRangePicker.prototype = {
        updateDates: function() {
            this.dates = $.map(this.pickers, function(i) {
                return i.getUTCDate();
            }), this.updateRanges();
        },
        updateRanges: function() {
            var range = $.map(this.dates, function(d) {
                return d.valueOf();
            });
            $.each(this.pickers, function(i, p) {
                p.setRange(range);
            });
        },
        dateUpdated: function(e) {
            if (!this.updating) {
                this.updating = !0;
                var dp = $(e.target).data("datepicker");
                if ("undefined" != typeof dp) {
                    var new_date = dp.getUTCDate(), i = $.inArray(e.target, this.inputs), j = i - 1, k = i + 1, l = this.inputs.length;
                    if (i !== -1) {
                        if ($.each(this.pickers, function(i, p) {
                            p.getUTCDate() || p.setUTCDate(new_date);
                        }), new_date < this.dates[j]) for (;j >= 0 && new_date < this.dates[j]; ) this.pickers[j--].setUTCDate(new_date); else if (new_date > this.dates[k]) for (;k < l && new_date > this.dates[k]; ) this.pickers[k++].setUTCDate(new_date);
                        this.updateDates(), delete this.updating;
                    }
                }
            }
        },
        remove: function() {
            $.map(this.pickers, function(p) {
                p.remove();
            }), delete this.element.data().datepicker;
        }
    };
    var old = $.fn.datepicker, datepickerPlugin = function(option) {
        var args = Array.apply(null, arguments);
        args.shift();
        var internal_return;
        if (this.each(function() {
            var $this = $(this), data = $this.data("datepicker"), options = "object" == typeof option && option;
            if (!data) {
                var elopts = opts_from_el(this, "date"), xopts = $.extend({}, defaults, elopts, options), locopts = opts_from_locale(xopts.language), opts = $.extend({}, defaults, locopts, elopts, options);
                $this.hasClass("input-daterange") || opts.inputs ? ($.extend(opts, {
                    inputs: opts.inputs || $this.find("input").toArray()
                }), data = new DateRangePicker(this, opts)) : data = new Datepicker(this, opts), 
                $this.data("datepicker", data);
            }
            "string" == typeof option && "function" == typeof data[option] && (internal_return = data[option].apply(data, args));
        }), internal_return === undefined || internal_return instanceof Datepicker || internal_return instanceof DateRangePicker) return this;
        if (this.length > 1) throw new Error("Using only allowed for the collection of a single element (" + option + " function)");
        return internal_return;
    };
    $.fn.datepicker = datepickerPlugin;
    var defaults = $.fn.datepicker.defaults = {
        assumeNearbyYear: !1,
        autoclose: !1,
        beforeShowDay: $.noop,
        beforeShowMonth: $.noop,
        beforeShowYear: $.noop,
        beforeShowDecade: $.noop,
        beforeShowCentury: $.noop,
        calendarWeeks: !1,
        clearBtn: !1,
        toggleActive: !1,
        daysOfWeekDisabled: [],
        daysOfWeekHighlighted: [],
        datesDisabled: [],
        endDate: 1 / 0,
        forceParse: !0,
        format: "mm/dd/yyyy",
        keyboardNavigation: !0,
        language: "en",
        minViewMode: 0,
        maxViewMode: 4,
        multidate: !1,
        multidateSeparator: ",",
        orientation: "auto",
        rtl: !1,
        startDate: -(1 / 0),
        startView: 0,
        todayBtn: !1,
        todayHighlight: !1,
        weekStart: 0,
        disableTouchKeyboard: !1,
        enableOnReadonly: !0,
        showOnFocus: !0,
        zIndexOffset: 10,
        container: "body",
        immediateUpdates: !1,
        title: "",
        templates: {
            leftArrow: "&laquo;",
            rightArrow: "&raquo;"
        }
    }, locale_opts = $.fn.datepicker.locale_opts = [ "format", "rtl", "weekStart" ];
    $.fn.datepicker.Constructor = Datepicker;
    var dates = $.fn.datepicker.dates = {
        en: {
            days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            daysShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
            daysMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ],
            months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            monthsShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            today: "Today",
            clear: "Clear",
            titleFormat: "MM yyyy"
        }
    }, DPGlobal = {
        modes: [ {
            clsName: "days",
            navFnc: "Month",
            navStep: 1
        }, {
            clsName: "months",
            navFnc: "FullYear",
            navStep: 1
        }, {
            clsName: "years",
            navFnc: "FullYear",
            navStep: 10
        }, {
            clsName: "decades",
            navFnc: "FullDecade",
            navStep: 100
        }, {
            clsName: "centuries",
            navFnc: "FullCentury",
            navStep: 1e3
        } ],
        isLeapYear: function(year) {
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
        },
        getDaysInMonth: function(year, month) {
            return [ 31, DPGlobal.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ][month];
        },
        validParts: /dd?|DD?|mm?|MM?|yy(?:yy)?/g,
        nonpunctuation: /[^ -\/:-@\u5e74\u6708\u65e5\[-`{-~\t\n\r]+/g,
        parseFormat: function(format) {
            if ("function" == typeof format.toValue && "function" == typeof format.toDisplay) return format;
            var separators = format.replace(this.validParts, "\0").split("\0"), parts = format.match(this.validParts);
            if (!separators || !separators.length || !parts || 0 === parts.length) throw new Error("Invalid date format.");
            return {
                separators: separators,
                parts: parts
            };
        },
        parseDate: function(date, format, language, assumeNearby) {
            function applyNearbyYear(year, threshold) {
                return threshold === !0 && (threshold = 10), year < 100 && (year += 2e3, year > new Date().getFullYear() + threshold && (year -= 100)), 
                year;
            }
            function match_part() {
                var m = this.slice(0, parts[i].length), p = parts[i].slice(0, m.length);
                return m.toLowerCase() === p.toLowerCase();
            }
            if (!date) return undefined;
            if (date instanceof Date) return date;
            if ("string" == typeof format && (format = DPGlobal.parseFormat(format)), format.toValue) return format.toValue(date, format, language);
            var part, dir, i, fn, part_re = /([\-+]\d+)([dmwy])/, parts = date.match(/([\-+]\d+)([dmwy])/g), fn_map = {
                d: "moveDay",
                m: "moveMonth",
                w: "moveWeek",
                y: "moveYear"
            }, dateAliases = {
                yesterday: "-1d",
                today: "+0d",
                tomorrow: "+1d"
            };
            if (/^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date)) {
                for (date = new Date(), i = 0; i < parts.length; i++) part = part_re.exec(parts[i]), 
                dir = parseInt(part[1]), fn = fn_map[part[2]], date = Datepicker.prototype[fn](date, dir);
                return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
            }
            if ("undefined" != typeof dateAliases[date] && (date = dateAliases[date], parts = date.match(/([\-+]\d+)([dmwy])/g), 
            /^[\-+]\d+[dmwy]([\s,]+[\-+]\d+[dmwy])*$/.test(date))) {
                for (date = new Date(), i = 0; i < parts.length; i++) part = part_re.exec(parts[i]), 
                dir = parseInt(part[1]), fn = fn_map[part[2]], date = Datepicker.prototype[fn](date, dir);
                return UTCDate(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
            }
            parts = date && date.match(this.nonpunctuation) || [], date = new Date();
            var val, filtered, parsed = {}, setters_order = [ "yyyy", "yy", "M", "MM", "m", "mm", "d", "dd" ], setters_map = {
                yyyy: function(d, v) {
                    return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
                },
                yy: function(d, v) {
                    return d.setUTCFullYear(assumeNearby ? applyNearbyYear(v, assumeNearby) : v);
                },
                m: function(d, v) {
                    if (isNaN(d)) return d;
                    for (v -= 1; v < 0; ) v += 12;
                    for (v %= 12, d.setUTCMonth(v); d.getUTCMonth() !== v; ) d.setUTCDate(d.getUTCDate() - 1);
                    return d;
                },
                d: function(d, v) {
                    return d.setUTCDate(v);
                }
            };
            setters_map.M = setters_map.MM = setters_map.mm = setters_map.m, setters_map.dd = setters_map.d, 
            date = UTCToday();
            var fparts = format.parts.slice();
            if (parts.length !== fparts.length && (fparts = $(fparts).filter(function(i, p) {
                return $.inArray(p, setters_order) !== -1;
            }).toArray()), parts.length === fparts.length) {
                var cnt;
                for (i = 0, cnt = fparts.length; i < cnt; i++) {
                    if (val = parseInt(parts[i], 10), part = fparts[i], isNaN(val)) switch (part) {
                      case "MM":
                        filtered = $(dates[language].months).filter(match_part), val = $.inArray(filtered[0], dates[language].months) + 1;
                        break;

                      case "M":
                        filtered = $(dates[language].monthsShort).filter(match_part), val = $.inArray(filtered[0], dates[language].monthsShort) + 1;
                    }
                    parsed[part] = val;
                }
                var _date, s;
                for (i = 0; i < setters_order.length; i++) s = setters_order[i], s in parsed && !isNaN(parsed[s]) && (_date = new Date(date), 
                setters_map[s](_date, parsed[s]), isNaN(_date) || (date = _date));
            }
            return date;
        },
        formatDate: function(date, format, language) {
            if (!date) return "";
            if ("string" == typeof format && (format = DPGlobal.parseFormat(format)), format.toDisplay) return format.toDisplay(date, format, language);
            var val = {
                d: date.getUTCDate(),
                D: dates[language].daysShort[date.getUTCDay()],
                DD: dates[language].days[date.getUTCDay()],
                m: date.getUTCMonth() + 1,
                M: dates[language].monthsShort[date.getUTCMonth()],
                MM: dates[language].months[date.getUTCMonth()],
                yy: date.getUTCFullYear().toString().substring(2),
                yyyy: date.getUTCFullYear()
            };
            val.dd = (val.d < 10 ? "0" : "") + val.d, val.mm = (val.m < 10 ? "0" : "") + val.m, 
            date = [];
            for (var seps = $.extend([], format.separators), i = 0, cnt = format.parts.length; i <= cnt; i++) seps.length && date.push(seps.shift()), 
            date.push(val[format.parts[i]]);
            return date.join("");
        },
        headTemplate: '<thead><tr><th colspan="7" class="datepicker-title"></th></tr><tr><th class="prev">&laquo;</th><th colspan="5" class="datepicker-switch"></th><th class="next">&raquo;</th></tr></thead>',
        contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
        footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr><tr><th colspan="7" class="clear"></th></tr></tfoot>'
    };
    DPGlobal.template = '<div class="datepicker"><div class="datepicker-days"><table class="table-condensed">' + DPGlobal.headTemplate + "<tbody></tbody>" + DPGlobal.footTemplate + '</table></div><div class="datepicker-months"><table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table></div><div class="datepicker-years"><table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table></div><div class="datepicker-decades"><table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + '</table></div><div class="datepicker-centuries"><table class="table-condensed">' + DPGlobal.headTemplate + DPGlobal.contTemplate + DPGlobal.footTemplate + "</table></div></div>", 
    $.fn.datepicker.DPGlobal = DPGlobal, $.fn.datepicker.noConflict = function() {
        return $.fn.datepicker = old, this;
    }, $.fn.datepicker.version = "1.6.4", $(document).on("focus.datepicker.data-api click.datepicker.data-api", '[data-provide="datepicker"]', function(e) {
        var $this = $(this);
        $this.data("datepicker") || (e.preventDefault(), datepickerPlugin.call($this, "show"));
    }), $(function() {
        datepickerPlugin.call($('[data-provide="datepicker-inline"]'));
    });
}), function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : factory("object" == typeof exports ? require("jquery") : jQuery);
}(function($) {
    "use strict";
    var Markdown = function(element, options) {
        var opts = [ "autofocus", "savable", "hideable", "width", "height", "resize", "iconlibrary", "language", "footer", "fullscreen", "hiddenButtons", "disabledButtons" ];
        $.each(opts, function(_, opt) {
            "undefined" != typeof $(element).data(opt) && (options = "object" == typeof options ? options : {}, 
            options[opt] = $(element).data(opt));
        }), this.$ns = "bootstrap-markdown", this.$element = $(element), this.$editable = {
            el: null,
            type: null,
            attrKeys: [],
            attrValues: [],
            content: null
        }, this.$options = $.extend(!0, {}, $.fn.markdown.defaults, options, this.$element.data("options")), 
        this.$oldContent = null, this.$isPreview = !1, this.$isFullscreen = !1, this.$editor = null, 
        this.$textarea = null, this.$handler = [], this.$callback = [], this.$nextTab = [], 
        this.showEditor();
    };
    Markdown.prototype = {
        constructor: Markdown,
        __alterButtons: function(name, alter) {
            var handler = this.$handler, isAll = "all" == name, that = this;
            $.each(handler, function(k, v) {
                var halt = !0;
                halt = !isAll && v.indexOf(name) < 0, halt === !1 && alter(that.$editor.find('button[data-handler="' + v + '"]'));
            });
        },
        __buildButtons: function(buttonsArray, container) {
            var i, ns = this.$ns, handler = this.$handler, callback = this.$callback;
            for (i = 0; i < buttonsArray.length; i++) {
                var y, btnGroups = buttonsArray[i];
                for (y = 0; y < btnGroups.length; y++) {
                    var z, buttons = btnGroups[y].data, btnGroupContainer = $("<div/>", {
                        class: "btn-group"
                    });
                    for (z = 0; z < buttons.length; z++) {
                        var buttonContainer, buttonIconContainer, button = buttons[z], buttonHandler = ns + "-" + button.name, buttonIcon = this.__getIcon(button.icon), btnText = button.btnText ? button.btnText : "", btnClass = button.btnClass ? button.btnClass : "btn", tabIndex = button.tabIndex ? button.tabIndex : "-1", hotkey = "undefined" != typeof button.hotkey ? button.hotkey : "", hotkeyCaption = "undefined" != typeof jQuery.hotkeys && "" !== hotkey ? " (" + hotkey + ")" : "";
                        buttonContainer = $("<button></button>"), buttonContainer.text(" " + this.__localize(btnText)).addClass("btn-default btn-sm").addClass(btnClass), 
                        btnClass.match(/btn\-(primary|success|info|warning|danger|link)/) && buttonContainer.removeClass("btn-default"), 
                        buttonContainer.attr({
                            type: "button",
                            title: this.__localize(button.title) + hotkeyCaption,
                            tabindex: tabIndex,
                            "data-provider": ns,
                            "data-handler": buttonHandler,
                            "data-hotkey": hotkey
                        }), button.toggle === !0 && buttonContainer.attr("data-toggle", "button"), buttonIconContainer = $("<span/>"), 
                        buttonIconContainer.addClass(buttonIcon), buttonIconContainer.prependTo(buttonContainer), 
                        btnGroupContainer.append(buttonContainer), handler.push(buttonHandler), callback.push(button.callback);
                    }
                    container.append(btnGroupContainer);
                }
            }
            return container;
        },
        __setListener: function() {
            var hasRows = "undefined" != typeof this.$textarea.attr("rows"), maxRows = this.$textarea.val().split("\n").length > 5 ? this.$textarea.val().split("\n").length : "5", rowsVal = hasRows ? this.$textarea.attr("rows") : maxRows;
            this.$textarea.attr("rows", rowsVal), this.$options.resize && this.$textarea.css("resize", this.$options.resize), 
            this.$textarea.on({
                focus: $.proxy(this.focus, this),
                keyup: $.proxy(this.keyup, this),
                change: $.proxy(this.change, this),
                select: $.proxy(this.select, this)
            }), this.eventSupported("keydown") && this.$textarea.on("keydown", $.proxy(this.keydown, this)), 
            this.eventSupported("keypress") && this.$textarea.on("keypress", $.proxy(this.keypress, this)), 
            this.$textarea.data("markdown", this);
        },
        __handle: function(e) {
            var target = $(e.currentTarget), handler = this.$handler, callback = this.$callback, handlerName = target.attr("data-handler"), callbackIndex = handler.indexOf(handlerName), callbackHandler = callback[callbackIndex];
            $(e.currentTarget).focus(), callbackHandler(this), this.change(this), handlerName.indexOf("cmdSave") < 0 && this.$textarea.focus(), 
            e.preventDefault();
        },
        __localize: function(string) {
            var messages = $.fn.markdown.messages, language = this.$options.language;
            return "undefined" != typeof messages && "undefined" != typeof messages[language] && "undefined" != typeof messages[language][string] ? messages[language][string] : string;
        },
        __getIcon: function(src) {
            return "object" == typeof src ? src[this.$options.iconlibrary] : src;
        },
        setFullscreen: function(mode) {
            var $editor = this.$editor, $textarea = this.$textarea;
            mode === !0 ? ($editor.addClass("md-fullscreen-mode"), $("body").addClass("md-nooverflow"), 
            this.$options.onFullscreen(this)) : ($editor.removeClass("md-fullscreen-mode"), 
            $("body").removeClass("md-nooverflow"), 1 == this.$isPreview && this.hidePreview().showPreview()), 
            this.$isFullscreen = mode, $textarea.focus();
        },
        showEditor: function() {
            var textarea, instance = this, ns = this.$ns, container = this.$element, editable = (container.css("height"), 
            container.css("width"), this.$editable), handler = this.$handler, callback = this.$callback, options = this.$options, editor = $("<div/>", {
                class: "md-editor",
                click: function() {
                    instance.focus();
                }
            });
            if (null === this.$editor) {
                var editorHeader = $("<div/>", {
                    class: "md-header btn-toolbar"
                }), allBtnGroups = [];
                if (options.buttons.length > 0 && (allBtnGroups = allBtnGroups.concat(options.buttons[0])), 
                options.additionalButtons.length > 0 && $.each(options.additionalButtons[0], function(idx, buttonGroup) {
                    var matchingGroups = $.grep(allBtnGroups, function(allButtonGroup, allIdx) {
                        return allButtonGroup.name === buttonGroup.name;
                    });
                    matchingGroups.length > 0 ? matchingGroups[0].data = matchingGroups[0].data.concat(buttonGroup.data) : allBtnGroups.push(options.additionalButtons[0][idx]);
                }), options.reorderButtonGroups.length > 0 && (allBtnGroups = allBtnGroups.filter(function(btnGroup) {
                    return options.reorderButtonGroups.indexOf(btnGroup.name) > -1;
                }).sort(function(a, b) {
                    return options.reorderButtonGroups.indexOf(a.name) < options.reorderButtonGroups.indexOf(b.name) ? -1 : options.reorderButtonGroups.indexOf(a.name) > options.reorderButtonGroups.indexOf(b.name) ? 1 : 0;
                })), allBtnGroups.length > 0 && (editorHeader = this.__buildButtons([ allBtnGroups ], editorHeader)), 
                options.fullscreen.enable && editorHeader.append('<div class="md-controls"><a class="md-control md-control-fullscreen" href="#"><span class="' + this.__getIcon(options.fullscreen.icons.fullscreenOn) + '"></span></a></div>').on("click", ".md-control-fullscreen", function(e) {
                    e.preventDefault(), instance.setFullscreen(!0);
                }), editor.append(editorHeader), container.is("textarea")) container.before(editor), 
                textarea = container, textarea.addClass("md-input"), editor.append(textarea); else {
                    var rawContent = "function" == typeof toMarkdown ? toMarkdown(container.html()) : container.html(), currentContent = $.trim(rawContent);
                    textarea = $("<textarea/>", {
                        class: "md-input",
                        val: currentContent
                    }), editor.append(textarea), editable.el = container, editable.type = container.prop("tagName").toLowerCase(), 
                    editable.content = container.html(), $(container[0].attributes).each(function() {
                        editable.attrKeys.push(this.nodeName), editable.attrValues.push(this.nodeValue);
                    }), container.replaceWith(editor);
                }
                var editorFooter = $("<div/>", {
                    class: "md-footer"
                }), createFooter = !1, footer = "";
                if (options.savable) {
                    createFooter = !0;
                    var saveHandler = "cmdSave";
                    handler.push(saveHandler), callback.push(options.onSave), editorFooter.append('<button class="btn btn-success" data-provider="' + ns + '" data-handler="' + saveHandler + '"><i class="icon icon-white icon-ok"></i> ' + this.__localize("Save") + "</button>");
                }
                if (footer = "function" == typeof options.footer ? options.footer(this) : options.footer, 
                "" !== $.trim(footer) && (createFooter = !0, editorFooter.append(footer)), createFooter && editor.append(editorFooter), 
                options.width && "inherit" !== options.width && (jQuery.isNumeric(options.width) ? (editor.css("display", "table"), 
                textarea.css("width", options.width + "px")) : editor.addClass(options.width)), 
                options.height && "inherit" !== options.height) if (jQuery.isNumeric(options.height)) {
                    var height = options.height;
                    editorHeader && (height = Math.max(0, height - editorHeader.outerHeight())), editorFooter && (height = Math.max(0, height - editorFooter.outerHeight())), 
                    textarea.css("height", height + "px");
                } else editor.addClass(options.height);
                this.$editor = editor, this.$textarea = textarea, this.$editable = editable, this.$oldContent = this.getContent(), 
                this.__setListener(), this.$editor.attr("id", new Date().getTime()), this.$editor.on("click", '[data-provider="bootstrap-markdown"]', $.proxy(this.__handle, this)), 
                (this.$element.is(":disabled") || this.$element.is("[readonly]")) && (this.$editor.addClass("md-editor-disabled"), 
                this.disableButtons("all")), this.eventSupported("keydown") && "object" == typeof jQuery.hotkeys && editorHeader.find('[data-provider="bootstrap-markdown"]').each(function() {
                    var $button = $(this), hotkey = $button.attr("data-hotkey");
                    "" !== hotkey.toLowerCase() && textarea.bind("keydown", hotkey, function() {
                        return $button.trigger("click"), !1;
                    });
                }), "preview" === options.initialstate ? this.showPreview() : "fullscreen" === options.initialstate && options.fullscreen.enable && this.setFullscreen(!0);
            } else this.$editor.show();
            return options.autofocus && (this.$textarea.focus(), this.$editor.addClass("active")), 
            options.fullscreen.enable && options.fullscreen !== !1 && (this.$editor.append('<div class="md-fullscreen-controls"><a href="#" class="exit-fullscreen" title="Exit fullscreen"><span class="' + this.__getIcon(options.fullscreen.icons.fullscreenOff) + '"></span></a></div>'), 
            this.$editor.on("click", ".exit-fullscreen", function(e) {
                e.preventDefault(), instance.setFullscreen(!1);
            })), this.hideButtons(options.hiddenButtons), this.disableButtons(options.disabledButtons), 
            options.onShow(this), this;
        },
        parseContent: function(val) {
            var content, val = val || this.$textarea.val();
            return content = this.$options.parser ? this.$options.parser(val) : "object" == typeof markdown ? markdown.toHTML(val) : "function" == typeof marked ? marked(val) : val;
        },
        showPreview: function() {
            var content, callbackContent, options = this.$options, container = this.$textarea, afterContainer = container.next(), replacementContainer = $("<div/>", {
                class: "md-preview",
                "data-provider": "markdown-preview"
            });
            return 1 == this.$isPreview ? this : (this.$isPreview = !0, this.disableButtons("all").enableButtons("cmdPreview"), 
            callbackContent = options.onPreview(this), content = "string" == typeof callbackContent ? callbackContent : this.parseContent(), 
            replacementContainer.html(content), afterContainer && "md-footer" == afterContainer.attr("class") ? replacementContainer.insertBefore(afterContainer) : container.parent().append(replacementContainer), 
            replacementContainer.css({
                width: container.outerWidth() + "px",
                height: container.outerHeight() + "px"
            }), this.$options.resize && replacementContainer.css("resize", this.$options.resize), 
            container.hide(), replacementContainer.data("markdown", this), (this.$element.is(":disabled") || this.$element.is("[readonly]")) && (this.$editor.addClass("md-editor-disabled"), 
            this.disableButtons("all")), this);
        },
        hidePreview: function() {
            this.$isPreview = !1;
            var container = this.$editor.find('div[data-provider="markdown-preview"]');
            return container.remove(), this.enableButtons("all"), this.disableButtons(this.$options.disabledButtons), 
            this.$textarea.show(), this.__setListener(), this;
        },
        isDirty: function() {
            return this.$oldContent != this.getContent();
        },
        getContent: function() {
            return this.$textarea.val();
        },
        setContent: function(content) {
            return this.$textarea.val(content), this;
        },
        findSelection: function(chunk) {
            var startChunkPosition, content = this.getContent();
            if (startChunkPosition = content.indexOf(chunk), startChunkPosition >= 0 && chunk.length > 0) {
                var selection, oldSelection = this.getSelection();
                return this.setSelection(startChunkPosition, startChunkPosition + chunk.length), 
                selection = this.getSelection(), this.setSelection(oldSelection.start, oldSelection.end), 
                selection;
            }
            return null;
        },
        getSelection: function() {
            var e = this.$textarea[0];
            return ("selectionStart" in e && function() {
                var l = e.selectionEnd - e.selectionStart;
                return {
                    start: e.selectionStart,
                    end: e.selectionEnd,
                    length: l,
                    text: e.value.substr(e.selectionStart, l)
                };
            } || function() {
                return null;
            })();
        },
        setSelection: function(start, end) {
            var e = this.$textarea[0];
            return ("selectionStart" in e && function() {
                e.selectionStart = start, e.selectionEnd = end;
            } || function() {
                return null;
            })();
        },
        replaceSelection: function(text) {
            var e = this.$textarea[0];
            return ("selectionStart" in e && function() {
                return e.value = e.value.substr(0, e.selectionStart) + text + e.value.substr(e.selectionEnd, e.value.length), 
                e.selectionStart = e.value.length, this;
            } || function() {
                return e.value += text, jQuery(e);
            })();
        },
        getNextTab: function() {
            if (0 === this.$nextTab.length) return null;
            var nextTab, tab = this.$nextTab.shift();
            return "function" == typeof tab ? nextTab = tab() : "object" == typeof tab && tab.length > 0 && (nextTab = tab), 
            nextTab;
        },
        setNextTab: function(start, end) {
            if ("string" == typeof start) {
                var that = this;
                this.$nextTab.push(function() {
                    return that.findSelection(start);
                });
            } else if ("number" == typeof start && "number" == typeof end) {
                var oldSelection = this.getSelection();
                this.setSelection(start, end), this.$nextTab.push(this.getSelection()), this.setSelection(oldSelection.start, oldSelection.end);
            }
        },
        __parseButtonNameParam: function(names) {
            return "string" == typeof names ? names.split(" ") : names;
        },
        enableButtons: function(name) {
            var buttons = this.__parseButtonNameParam(name), that = this;
            return $.each(buttons, function(i, v) {
                that.__alterButtons(buttons[i], function(el) {
                    el.removeAttr("disabled");
                });
            }), this;
        },
        disableButtons: function(name) {
            var buttons = this.__parseButtonNameParam(name), that = this;
            return $.each(buttons, function(i, v) {
                that.__alterButtons(buttons[i], function(el) {
                    el.attr("disabled", "disabled");
                });
            }), this;
        },
        hideButtons: function(name) {
            var buttons = this.__parseButtonNameParam(name), that = this;
            return $.each(buttons, function(i, v) {
                that.__alterButtons(buttons[i], function(el) {
                    el.addClass("hidden");
                });
            }), this;
        },
        showButtons: function(name) {
            var buttons = this.__parseButtonNameParam(name), that = this;
            return $.each(buttons, function(i, v) {
                that.__alterButtons(buttons[i], function(el) {
                    el.removeClass("hidden");
                });
            }), this;
        },
        eventSupported: function(eventName) {
            var isSupported = eventName in this.$element;
            return isSupported || (this.$element.setAttribute(eventName, "return;"), isSupported = "function" == typeof this.$element[eventName]), 
            isSupported;
        },
        keyup: function(e) {
            var blocked = !1;
            switch (e.keyCode) {
              case 40:
              case 38:
              case 16:
              case 17:
              case 18:
                break;

              case 9:
                var nextTab;
                if (nextTab = this.getNextTab(), null !== nextTab) {
                    var that = this;
                    setTimeout(function() {
                        that.setSelection(nextTab.start, nextTab.end);
                    }, 500), blocked = !0;
                } else {
                    var cursor = this.getSelection();
                    cursor.start == cursor.end && cursor.end == this.getContent().length ? blocked = !1 : (this.setSelection(this.getContent().length, this.getContent().length), 
                    blocked = !0);
                }
                break;

              case 13:
                blocked = !1;
                break;

              case 27:
                this.$isFullscreen && this.setFullscreen(!1), blocked = !1;
                break;

              default:
                blocked = !1;
            }
            blocked && (e.stopPropagation(), e.preventDefault()), this.$options.onChange(this);
        },
        change: function(e) {
            return this.$options.onChange(this), this;
        },
        select: function(e) {
            return this.$options.onSelect(this), this;
        },
        focus: function(e) {
            var options = this.$options, editor = (options.hideable, this.$editor);
            return editor.addClass("active"), $(document).find(".md-editor").each(function() {
                if ($(this).attr("id") !== editor.attr("id")) {
                    var attachedMarkdown;
                    attachedMarkdown = $(this).find("textarea").data("markdown"), null === attachedMarkdown && (attachedMarkdown = $(this).find('div[data-provider="markdown-preview"]').data("markdown")), 
                    attachedMarkdown && attachedMarkdown.blur();
                }
            }), options.onFocus(this), this;
        },
        blur: function(e) {
            var options = this.$options, isHideable = options.hideable, editor = this.$editor, editable = this.$editable;
            if (editor.hasClass("active") || 0 === this.$element.parent().length) {
                if (editor.removeClass("active"), isHideable) if (null !== editable.el) {
                    var oldElement = $("<" + editable.type + "/>"), content = this.getContent(), currentContent = this.parseContent(content);
                    $(editable.attrKeys).each(function(k, v) {
                        oldElement.attr(editable.attrKeys[k], editable.attrValues[k]);
                    }), oldElement.html(currentContent), editor.replaceWith(oldElement);
                } else editor.hide();
                options.onBlur(this);
            }
            return this;
        }
    };
    var old = $.fn.markdown;
    $.fn.markdown = function(option) {
        return this.each(function() {
            var $this = $(this), data = $this.data("markdown"), options = "object" == typeof option && option;
            data || $this.data("markdown", data = new Markdown(this, options));
        });
    }, $.fn.markdown.messages = {}, $.fn.markdown.defaults = {
        autofocus: !1,
        hideable: !1,
        savable: !1,
        width: "inherit",
        height: "inherit",
        resize: "none",
        iconlibrary: "glyph",
        language: "en",
        initialstate: "editor",
        parser: null,
        buttons: [ [ {
            name: "groupFont",
            data: [ {
                name: "cmdBold",
                hotkey: "Ctrl+B",
                title: "Bold",
                icon: {
                    glyph: "glyphicon glyphicon-bold",
                    fa: "fa fa-bold",
                    "fa-3": "icon-bold"
                },
                callback: function(e) {
                    var chunk, cursor, selected = e.getSelection(), content = e.getContent();
                    chunk = 0 === selected.length ? e.__localize("strong text") : selected.text, "**" === content.substr(selected.start - 2, 2) && "**" === content.substr(selected.end, 2) ? (e.setSelection(selected.start - 2, selected.end + 2), 
                    e.replaceSelection(chunk), cursor = selected.start - 2) : (e.replaceSelection("**" + chunk + "**"), 
                    cursor = selected.start + 2), e.setSelection(cursor, cursor + chunk.length);
                }
            }, {
                name: "cmdItalic",
                title: "Italic",
                hotkey: "Ctrl+I",
                icon: {
                    glyph: "glyphicon glyphicon-italic",
                    fa: "fa fa-italic",
                    "fa-3": "icon-italic"
                },
                callback: function(e) {
                    var chunk, cursor, selected = e.getSelection(), content = e.getContent();
                    chunk = 0 === selected.length ? e.__localize("emphasized text") : selected.text, 
                    "_" === content.substr(selected.start - 1, 1) && "_" === content.substr(selected.end, 1) ? (e.setSelection(selected.start - 1, selected.end + 1), 
                    e.replaceSelection(chunk), cursor = selected.start - 1) : (e.replaceSelection("_" + chunk + "_"), 
                    cursor = selected.start + 1), e.setSelection(cursor, cursor + chunk.length);
                }
            }, {
                name: "cmdHeading",
                title: "Heading",
                hotkey: "Ctrl+H",
                icon: {
                    glyph: "glyphicon glyphicon-header",
                    fa: "fa fa-header",
                    "fa-3": "icon-font"
                },
                callback: function(e) {
                    var chunk, cursor, pointer, prevChar, selected = e.getSelection(), content = e.getContent();
                    chunk = 0 === selected.length ? e.__localize("heading text") : selected.text + "\n", 
                    pointer = 4, "### " === content.substr(selected.start - pointer, pointer) || (pointer = 3, 
                    "###" === content.substr(selected.start - pointer, pointer)) ? (e.setSelection(selected.start - pointer, selected.end), 
                    e.replaceSelection(chunk), cursor = selected.start - pointer) : selected.start > 0 && (prevChar = content.substr(selected.start - 1, 1), 
                    !!prevChar && "\n" != prevChar) ? (e.replaceSelection("\n\n### " + chunk), cursor = selected.start + 6) : (e.replaceSelection("### " + chunk), 
                    cursor = selected.start + 4), e.setSelection(cursor, cursor + chunk.length);
                }
            } ]
        }, {
            name: "groupLink",
            data: [ {
                name: "cmdUrl",
                title: "URL/Link",
                hotkey: "Ctrl+L",
                icon: {
                    glyph: "glyphicon glyphicon-link",
                    fa: "fa fa-link",
                    "fa-3": "icon-link"
                },
                callback: function(e) {
                    var chunk, cursor, link, selected = e.getSelection();
                    e.getContent();
                    chunk = 0 === selected.length ? e.__localize("enter link description here") : selected.text, 
                    link = prompt(e.__localize("Insert Hyperlink"), "http://");
                    var urlRegex = new RegExp("^((http|https)://|(mailto:)|(//))[a-z0-9]", "i");
                    if (null !== link && "" !== link && "http://" !== link && urlRegex.test(link)) {
                        var sanitizedLink = $("<div>" + link + "</div>").text();
                        e.replaceSelection("[" + chunk + "](" + sanitizedLink + ")"), cursor = selected.start + 1, 
                        e.setSelection(cursor, cursor + chunk.length);
                    }
                }
            }, {
                name: "cmdImage",
                title: "Image",
                hotkey: "Ctrl+G",
                icon: {
                    glyph: "glyphicon glyphicon-picture",
                    fa: "fa fa-picture-o",
                    "fa-3": "icon-picture"
                },
                callback: function(e) {
                    var chunk, cursor, link, selected = e.getSelection();
                    e.getContent();
                    chunk = 0 === selected.length ? e.__localize("enter image description here") : selected.text, 
                    link = prompt(e.__localize("Insert Image Hyperlink"), "http://");
                    var urlRegex = new RegExp("^((http|https)://|(//))[a-z0-9]", "i");
                    if (null !== link && "" !== link && "http://" !== link && urlRegex.test(link)) {
                        var sanitizedLink = $("<div>" + link + "</div>").text();
                        e.replaceSelection("![" + chunk + "](" + sanitizedLink + ' "' + e.__localize("enter image title here") + '")'), 
                        cursor = selected.start + 2, e.setNextTab(e.__localize("enter image title here")), 
                        e.setSelection(cursor, cursor + chunk.length);
                    }
                }
            } ]
        }, {
            name: "groupMisc",
            data: [ {
                name: "cmdList",
                hotkey: "Ctrl+U",
                title: "Unordered List",
                icon: {
                    glyph: "glyphicon glyphicon-list",
                    fa: "fa fa-list",
                    "fa-3": "icon-list-ul"
                },
                callback: function(e) {
                    var chunk, cursor, selected = e.getSelection();
                    e.getContent();
                    if (0 === selected.length) chunk = e.__localize("list text here"), e.replaceSelection("- " + chunk), 
                    cursor = selected.start + 2; else if (selected.text.indexOf("\n") < 0) chunk = selected.text, 
                    e.replaceSelection("- " + chunk), cursor = selected.start + 2; else {
                        var list = [];
                        list = selected.text.split("\n"), chunk = list[0], $.each(list, function(k, v) {
                            list[k] = "- " + v;
                        }), e.replaceSelection("\n\n" + list.join("\n")), cursor = selected.start + 4;
                    }
                    e.setSelection(cursor, cursor + chunk.length);
                }
            }, {
                name: "cmdListO",
                hotkey: "Ctrl+O",
                title: "Ordered List",
                icon: {
                    glyph: "glyphicon glyphicon-th-list",
                    fa: "fa fa-list-ol",
                    "fa-3": "icon-list-ol"
                },
                callback: function(e) {
                    var chunk, cursor, selected = e.getSelection();
                    e.getContent();
                    if (0 === selected.length) chunk = e.__localize("list text here"), e.replaceSelection("1. " + chunk), 
                    cursor = selected.start + 3; else if (selected.text.indexOf("\n") < 0) chunk = selected.text, 
                    e.replaceSelection("1. " + chunk), cursor = selected.start + 3; else {
                        var list = [];
                        list = selected.text.split("\n"), chunk = list[0], $.each(list, function(k, v) {
                            list[k] = "1. " + v;
                        }), e.replaceSelection("\n\n" + list.join("\n")), cursor = selected.start + 5;
                    }
                    e.setSelection(cursor, cursor + chunk.length);
                }
            }, {
                name: "cmdCode",
                hotkey: "Ctrl+K",
                title: "Code",
                icon: {
                    glyph: "glyphicon glyphicon-asterisk",
                    fa: "fa fa-code",
                    "fa-3": "icon-code"
                },
                callback: function(e) {
                    var chunk, cursor, selected = e.getSelection(), content = e.getContent();
                    chunk = 0 === selected.length ? e.__localize("code text here") : selected.text, 
                    "```\n" === content.substr(selected.start - 4, 4) && "\n```" === content.substr(selected.end, 4) ? (e.setSelection(selected.start - 4, selected.end + 4), 
                    e.replaceSelection(chunk), cursor = selected.start - 4) : "`" === content.substr(selected.start - 1, 1) && "`" === content.substr(selected.end, 1) ? (e.setSelection(selected.start - 1, selected.end + 1), 
                    e.replaceSelection(chunk), cursor = selected.start - 1) : content.indexOf("\n") > -1 ? (e.replaceSelection("```\n" + chunk + "\n```"), 
                    cursor = selected.start + 4) : (e.replaceSelection("`" + chunk + "`"), cursor = selected.start + 1), 
                    e.setSelection(cursor, cursor + chunk.length);
                }
            }, {
                name: "cmdQuote",
                hotkey: "Ctrl+Q",
                title: "Quote",
                icon: {
                    glyph: "glyphicon glyphicon-comment",
                    fa: "fa fa-quote-left",
                    "fa-3": "icon-quote-left"
                },
                callback: function(e) {
                    var chunk, cursor, selected = e.getSelection();
                    e.getContent();
                    if (0 === selected.length) chunk = e.__localize("quote here"), e.replaceSelection("> " + chunk), 
                    cursor = selected.start + 2; else if (selected.text.indexOf("\n") < 0) chunk = selected.text, 
                    e.replaceSelection("> " + chunk), cursor = selected.start + 2; else {
                        var list = [];
                        list = selected.text.split("\n"), chunk = list[0], $.each(list, function(k, v) {
                            list[k] = "> " + v;
                        }), e.replaceSelection("\n\n" + list.join("\n")), cursor = selected.start + 4;
                    }
                    e.setSelection(cursor, cursor + chunk.length);
                }
            } ]
        }, {
            name: "groupUtil",
            data: [ {
                name: "cmdPreview",
                toggle: !0,
                hotkey: "Ctrl+P",
                title: "Preview",
                btnText: "Preview",
                btnClass: "btn btn-primary btn-sm",
                icon: {
                    glyph: "glyphicon glyphicon-search",
                    fa: "fa fa-search",
                    "fa-3": "icon-search"
                },
                callback: function(e) {
                    var isPreview = e.$isPreview;
                    isPreview === !1 ? e.showPreview() : e.hidePreview();
                }
            } ]
        } ] ],
        additionalButtons: [],
        reorderButtonGroups: [],
        hiddenButtons: [],
        disabledButtons: [],
        footer: "",
        fullscreen: {
            enable: !0,
            icons: {
                fullscreenOn: {
                    fa: "fa fa-expand",
                    glyph: "glyphicon glyphicon-fullscreen",
                    "fa-3": "icon-resize-full"
                },
                fullscreenOff: {
                    fa: "fa fa-compress",
                    glyph: "glyphicon glyphicon-fullscreen",
                    "fa-3": "icon-resize-small"
                }
            }
        },
        onShow: function(e) {},
        onPreview: function(e) {},
        onSave: function(e) {},
        onBlur: function(e) {},
        onFocus: function(e) {},
        onChange: function(e) {},
        onFullscreen: function(e) {},
        onSelect: function(e) {}
    }, $.fn.markdown.Constructor = Markdown, $.fn.markdown.noConflict = function() {
        return $.fn.markdown = old, this;
    };
    var initMarkdown = function(el) {
        var $this = el;
        return $this.data("markdown") ? void $this.data("markdown").showEditor() : void $this.markdown();
    }, blurNonFocused = function(e) {
        var $activeElement = $(document.activeElement);
        $(document).find(".md-editor").each(function() {
            var $this = $(this), focused = $activeElement.closest(".md-editor")[0] === this, attachedMarkdown = $this.find("textarea").data("markdown") || $this.find('div[data-provider="markdown-preview"]').data("markdown");
            attachedMarkdown && !focused && attachedMarkdown.blur();
        });
    };
    $(document).on("click.markdown.data-api", '[data-provide="markdown-editable"]', function(e) {
        initMarkdown($(this)), e.preventDefault();
    }).on("click focusin", function(e) {
        blurNonFocused(e);
    }).ready(function() {
        $('textarea[data-provide="markdown"]').each(function() {
            initMarkdown($(this));
        });
    });
}), function($) {
    $.fn.markdown.messages.de = {
        Bold: "Fett",
        Italic: "Kursiv",
        Heading: "berschrift",
        "URL/Link": "Link hinzufgen",
        Image: "Bild hinzufgen",
        "Unordered List": "Unnummerierte Liste",
        "Ordered List": "Nummerierte Liste",
        Code: "Quelltext",
        Quote: "Zitat",
        Preview: "Vorschau",
        "strong text": "Sehr betonter Text",
        "emphasized text": "Betonter Text",
        "heading text": "berschrift Text",
        "enter link description here": "Linkbeschreibung",
        "Insert Hyperlink": "URL",
        "enter image description here": "Bildbeschreibung",
        "Insert Image Hyperlink": "Bild-URL",
        "enter image title here": "Titel des Bildes",
        "list text here": "Aufzhlungs-Text"
    };
}(jQuery), function(global, factory) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.moment = factory();
}(this, function() {
    "use strict";
    function hooks() {
        return hookCallback.apply(null, arguments);
    }
    function setHookCallback(callback) {
        hookCallback = callback;
    }
    function isArray(input) {
        return input instanceof Array || "[object Array]" === Object.prototype.toString.call(input);
    }
    function isObject(input) {
        return null != input && "[object Object]" === Object.prototype.toString.call(input);
    }
    function isObjectEmpty(obj) {
        var k;
        for (k in obj) return !1;
        return !0;
    }
    function isNumber(input) {
        return "number" == typeof input || "[object Number]" === Object.prototype.toString.call(input);
    }
    function isDate(input) {
        return input instanceof Date || "[object Date]" === Object.prototype.toString.call(input);
    }
    function map(arr, fn) {
        var i, res = [];
        for (i = 0; i < arr.length; ++i) res.push(fn(arr[i], i));
        return res;
    }
    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }
    function extend(a, b) {
        for (var i in b) hasOwnProp(b, i) && (a[i] = b[i]);
        return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), 
        a;
    }
    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, !0).utc();
    }
    function defaultParsingFlags() {
        return {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1,
            parsedDateParts: [],
            meridiem: null
        };
    }
    function getParsingFlags(m) {
        return null == m._pf && (m._pf = defaultParsingFlags()), m._pf;
    }
    function isValid(m) {
        if (null == m._isValid) {
            var flags = getParsingFlags(m), parsedParts = some$1.call(flags.parsedDateParts, function(i) {
                return null != i;
            }), isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
            if (m._strict && (isNowValid = isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour), 
            null != Object.isFrozen && Object.isFrozen(m)) return isNowValid;
            m._isValid = isNowValid;
        }
        return m._isValid;
    }
    function createInvalid(flags) {
        var m = createUTC(NaN);
        return null != flags ? extend(getParsingFlags(m), flags) : getParsingFlags(m).userInvalidated = !0, 
        m;
    }
    function isUndefined(input) {
        return void 0 === input;
    }
    function copyConfig(to, from) {
        var i, prop, val;
        if (isUndefined(from._isAMomentObject) || (to._isAMomentObject = from._isAMomentObject), 
        isUndefined(from._i) || (to._i = from._i), isUndefined(from._f) || (to._f = from._f), 
        isUndefined(from._l) || (to._l = from._l), isUndefined(from._strict) || (to._strict = from._strict), 
        isUndefined(from._tzm) || (to._tzm = from._tzm), isUndefined(from._isUTC) || (to._isUTC = from._isUTC), 
        isUndefined(from._offset) || (to._offset = from._offset), isUndefined(from._pf) || (to._pf = getParsingFlags(from)), 
        isUndefined(from._locale) || (to._locale = from._locale), momentProperties.length > 0) for (i in momentProperties) prop = momentProperties[i], 
        val = from[prop], isUndefined(val) || (to[prop] = val);
        return to;
    }
    function Moment(config) {
        copyConfig(this, config), this._d = new Date(null != config._d ? config._d.getTime() : NaN), 
        this.isValid() || (this._d = new Date(NaN)), updateInProgress === !1 && (updateInProgress = !0, 
        hooks.updateOffset(this), updateInProgress = !1);
    }
    function isMoment(obj) {
        return obj instanceof Moment || null != obj && null != obj._isAMomentObject;
    }
    function absFloor(number) {
        return number < 0 ? Math.ceil(number) || 0 : Math.floor(number);
    }
    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        return 0 !== coercedNumber && isFinite(coercedNumber) && (value = absFloor(coercedNumber)), 
        value;
    }
    function compareArrays(array1, array2, dontConvert) {
        var i, len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0;
        for (i = 0; i < len; i++) (dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) && diffs++;
        return diffs + lengthDiff;
    }
    function warn(msg) {
        hooks.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + msg);
    }
    function deprecate(msg, fn) {
        var firstTime = !0;
        return extend(function() {
            if (null != hooks.deprecationHandler && hooks.deprecationHandler(null, msg), firstTime) {
                for (var arg, args = [], i = 0; i < arguments.length; i++) {
                    if (arg = "", "object" == typeof arguments[i]) {
                        arg += "\n[" + i + "] ";
                        for (var key in arguments[0]) arg += key + ": " + arguments[0][key] + ", ";
                        arg = arg.slice(0, -2);
                    } else arg = arguments[i];
                    args.push(arg);
                }
                warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack), 
                firstTime = !1;
            }
            return fn.apply(this, arguments);
        }, fn);
    }
    function deprecateSimple(name, msg) {
        null != hooks.deprecationHandler && hooks.deprecationHandler(name, msg), deprecations[name] || (warn(msg), 
        deprecations[name] = !0);
    }
    function isFunction(input) {
        return input instanceof Function || "[object Function]" === Object.prototype.toString.call(input);
    }
    function set(config) {
        var prop, i;
        for (i in config) prop = config[i], isFunction(prop) ? this[i] = prop : this["_" + i] = prop;
        this._config = config, this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source);
    }
    function mergeConfigs(parentConfig, childConfig) {
        var prop, res = extend({}, parentConfig);
        for (prop in childConfig) hasOwnProp(childConfig, prop) && (isObject(parentConfig[prop]) && isObject(childConfig[prop]) ? (res[prop] = {}, 
        extend(res[prop], parentConfig[prop]), extend(res[prop], childConfig[prop])) : null != childConfig[prop] ? res[prop] = childConfig[prop] : delete res[prop]);
        for (prop in parentConfig) hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop]) && (res[prop] = extend({}, res[prop]));
        return res;
    }
    function Locale(config) {
        null != config && this.set(config);
    }
    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar.sameElse;
        return isFunction(output) ? output.call(mom, now) : output;
    }
    function longDateFormat(key) {
        var format = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
        return format || !formatUpper ? format : (this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
            return val.slice(1);
        }), this._longDateFormat[key]);
    }
    function invalidDate() {
        return this._invalidDate;
    }
    function ordinal(number) {
        return this._ordinal.replace("%d", number);
    }
    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }
    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? "future" : "past"];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }
    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
    }
    function normalizeUnits(units) {
        return "string" == typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0;
    }
    function normalizeObjectUnits(inputObject) {
        var normalizedProp, prop, normalizedInput = {};
        for (prop in inputObject) hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop), 
        normalizedProp && (normalizedInput[normalizedProp] = inputObject[prop]));
        return normalizedInput;
    }
    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }
    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) units.push({
            unit: u,
            priority: priorities[u]
        });
        return units.sort(function(a, b) {
            return a.priority - b.priority;
        }), units;
    }
    function makeGetSet(unit, keepTime) {
        return function(value) {
            return null != value ? (set$1(this, unit, value), hooks.updateOffset(this, keepTime), 
            this) : get(this, unit);
        };
    }
    function get(mom, unit) {
        return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
    }
    function set$1(mom, unit, value) {
        mom.isValid() && mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
    function stringGet(units) {
        return units = normalizeUnits(units), isFunction(this[units]) ? this[units]() : this;
    }
    function stringSet(units, value) {
        if ("object" == typeof units) {
            units = normalizeObjectUnits(units);
            for (var prioritized = getPrioritizedUnits(units), i = 0; i < prioritized.length; i++) this[prioritized[i].unit](units[prioritized[i].unit]);
        } else if (units = normalizeUnits(units), isFunction(this[units])) return this[units](value);
        return this;
    }
    function zeroFill(number, targetLength, forceSign) {
        var absNumber = "" + Math.abs(number), zerosToFill = targetLength - absNumber.length, sign = number >= 0;
        return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        "string" == typeof callback && (func = function() {
            return this[callback]();
        }), token && (formatTokenFunctions[token] = func), padded && (formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        }), ordinal && (formatTokenFunctions[ordinal] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        });
    }
    function removeFormattingTokens(input) {
        return input.match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "");
    }
    function makeFormatFunction(format) {
        var i, length, array = format.match(formattingTokens);
        for (i = 0, length = array.length; i < length; i++) formatTokenFunctions[array[i]] ? array[i] = formatTokenFunctions[array[i]] : array[i] = removeFormattingTokens(array[i]);
        return function(mom) {
            var i, output = "";
            for (i = 0; i < length; i++) output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            return output;
        };
    }
    function formatMoment(m, format) {
        return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format), 
        formatFunctions[format](m)) : m.localeData().invalidDate();
    }
    function expandFormat(format, locale) {
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }
        var i = 5;
        for (localFormattingTokens.lastIndex = 0; i >= 0 && localFormattingTokens.test(format); ) format = format.replace(localFormattingTokens, replaceLongDateFormatTokens), 
        localFormattingTokens.lastIndex = 0, i -= 1;
        return format;
    }
    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
            return isStrict && strictRegex ? strictRegex : regex;
        };
    }
    function getParseRegexForToken(token, config) {
        return hasOwnProp(regexes, token) ? regexes[token](config._strict, config._locale) : new RegExp(unescapeFormat(token));
    }
    function unescapeFormat(s) {
        return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }
    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    function addParseToken(token, callback) {
        var i, func = callback;
        for ("string" == typeof token && (token = [ token ]), isNumber(callback) && (func = function(input, array) {
            array[callback] = toInt(input);
        }), i = 0; i < token.length; i++) tokens[token[i]] = func;
    }
    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {}, callback(input, config._w, config, token);
        });
    }
    function addTimeToArrayFromToken(token, input, config) {
        null != input && hasOwnProp(tokens, token) && tokens[token](input, config._a, config, token);
    }
    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
    }
    function localeMonths(m, format) {
        return m ? isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()] : this._months;
    }
    function localeMonthsShort(m, format) {
        return m ? isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()] : this._monthsShort;
    }
    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) for (this._monthsParse = [], this._longMonthsParse = [], 
        this._shortMonthsParse = [], i = 0; i < 12; ++i) mom = createUTC([ 2e3, i ]), this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase(), 
        this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
        return strict ? "MMM" === format ? (ii = indexOf$1.call(this._shortMonthsParse, llc), 
        ii !== -1 ? ii : null) : (ii = indexOf$1.call(this._longMonthsParse, llc), ii !== -1 ? ii : null) : "MMM" === format ? (ii = indexOf$1.call(this._shortMonthsParse, llc), 
        ii !== -1 ? ii : (ii = indexOf$1.call(this._longMonthsParse, llc), ii !== -1 ? ii : null)) : (ii = indexOf$1.call(this._longMonthsParse, llc), 
        ii !== -1 ? ii : (ii = indexOf$1.call(this._shortMonthsParse, llc), ii !== -1 ? ii : null));
    }
    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;
        if (this._monthsParseExact) return handleStrictParse.call(this, monthName, format, strict);
        for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), 
        i = 0; i < 12; i++) {
            if (mom = createUTC([ 2e3, i ]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i"), 
            this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")), 
            strict || this._monthsParse[i] || (regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), 
            this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) return i;
            if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) return i;
            if (!strict && this._monthsParse[i].test(monthName)) return i;
        }
    }
    function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) return mom;
        if ("string" == typeof value) if (/^\d+$/.test(value)) value = toInt(value); else if (value = mom.localeData().monthsParse(value), 
        !isNumber(value)) return mom;
        return dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value)), mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth), 
        mom;
    }
    function getSetMonth(value) {
        return null != value ? (setMonth(this, value), hooks.updateOffset(this, !0), this) : get(this, "Month");
    }
    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }
    function monthsShortRegex(isStrict) {
        return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
        isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = defaultMonthsShortRegex), 
        this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex);
    }
    function monthsRegex(isStrict) {
        return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), 
        isStrict ? this._monthsStrictRegex : this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), 
        this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex);
    }
    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var i, mom, shortPieces = [], longPieces = [], mixedPieces = [];
        for (i = 0; i < 12; i++) mom = createUTC([ 2e3, i ]), shortPieces.push(this.monthsShort(mom, "")), 
        longPieces.push(this.months(mom, "")), mixedPieces.push(this.months(mom, "")), mixedPieces.push(this.monthsShort(mom, ""));
        for (shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), 
        i = 0; i < 12; i++) shortPieces[i] = regexEscape(shortPieces[i]), longPieces[i] = regexEscape(longPieces[i]);
        for (i = 0; i < 24; i++) mixedPieces[i] = regexEscape(mixedPieces[i]);
        this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, 
        this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i");
    }
    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }
    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
    function getIsLeapYear() {
        return isLeapYear(this.year());
    }
    function createDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        return y < 100 && y >= 0 && isFinite(date.getFullYear()) && date.setFullYear(y), 
        date;
    }
    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        return y < 100 && y >= 0 && isFinite(date.getUTCFullYear()) && date.setUTCFullYear(y), 
        date;
    }
    function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
    }
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var resYear, resDayOfYear, localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset;
        return dayOfYear <= 0 ? (resYear = year - 1, resDayOfYear = daysInYear(resYear) + dayOfYear) : dayOfYear > daysInYear(year) ? (resYear = year + 1, 
        resDayOfYear = dayOfYear - daysInYear(year)) : (resYear = year, resDayOfYear = dayOfYear), 
        {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }
    function weekOfYear(mom, dow, doy) {
        var resWeek, resYear, weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1;
        return week < 1 ? (resYear = mom.year() - 1, resWeek = week + weeksInYear(resYear, dow, doy)) : week > weeksInYear(mom.year(), dow, doy) ? (resWeek = week - weeksInYear(mom.year(), dow, doy), 
        resYear = mom.year() + 1) : (resYear = mom.year(), resWeek = week), {
            week: resWeek,
            year: resYear
        };
    }
    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }
    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }
    function localeFirstDayOfWeek() {
        return this._week.dow;
    }
    function localeFirstDayOfYear() {
        return this._week.doy;
    }
    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return null == input ? week : this.add(7 * (input - week), "d");
    }
    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return null == input ? week : this.add(7 * (input - week), "d");
    }
    function parseWeekday(input, locale) {
        return "string" != typeof input ? input : isNaN(input) ? (input = locale.weekdaysParse(input), 
        "number" == typeof input ? input : null) : parseInt(input, 10);
    }
    function parseIsoWeekday(input, locale) {
        return "string" == typeof input ? locale.weekdaysParse(input) % 7 || 7 : isNaN(input) ? null : input;
    }
    function localeWeekdays(m, format) {
        return m ? isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? "format" : "standalone"][m.day()] : this._weekdays;
    }
    function localeWeekdaysShort(m) {
        return m ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }
    function localeWeekdaysMin(m) {
        return m ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }
    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) for (this._weekdaysParse = [], this._shortWeekdaysParse = [], 
        this._minWeekdaysParse = [], i = 0; i < 7; ++i) mom = createUTC([ 2e3, 1 ]).day(i), 
        this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase(), 
        this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
        return strict ? "dddd" === format ? (ii = indexOf$1.call(this._weekdaysParse, llc), 
        ii !== -1 ? ii : null) : "ddd" === format ? (ii = indexOf$1.call(this._shortWeekdaysParse, llc), 
        ii !== -1 ? ii : null) : (ii = indexOf$1.call(this._minWeekdaysParse, llc), ii !== -1 ? ii : null) : "dddd" === format ? (ii = indexOf$1.call(this._weekdaysParse, llc), 
        ii !== -1 ? ii : (ii = indexOf$1.call(this._shortWeekdaysParse, llc), ii !== -1 ? ii : (ii = indexOf$1.call(this._minWeekdaysParse, llc), 
        ii !== -1 ? ii : null))) : "ddd" === format ? (ii = indexOf$1.call(this._shortWeekdaysParse, llc), 
        ii !== -1 ? ii : (ii = indexOf$1.call(this._weekdaysParse, llc), ii !== -1 ? ii : (ii = indexOf$1.call(this._minWeekdaysParse, llc), 
        ii !== -1 ? ii : null))) : (ii = indexOf$1.call(this._minWeekdaysParse, llc), ii !== -1 ? ii : (ii = indexOf$1.call(this._weekdaysParse, llc), 
        ii !== -1 ? ii : (ii = indexOf$1.call(this._shortWeekdaysParse, llc), ii !== -1 ? ii : null)));
    }
    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;
        if (this._weekdaysParseExact) return handleStrictParse$1.call(this, weekdayName, format, strict);
        for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], 
        this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
            if (mom = createUTC([ 2e3, 1 ]).day(i), strict && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", ".?") + "$", "i"), 
            this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", ".?") + "$", "i"), 
            this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", ".?") + "$", "i")), 
            this._weekdaysParse[i] || (regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, ""), 
            this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "dddd" === format && this._fullWeekdaysParse[i].test(weekdayName)) return i;
            if (strict && "ddd" === format && this._shortWeekdaysParse[i].test(weekdayName)) return i;
            if (strict && "dd" === format && this._minWeekdaysParse[i].test(weekdayName)) return i;
            if (!strict && this._weekdaysParse[i].test(weekdayName)) return i;
        }
    }
    function getSetDayOfWeek(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        return null != input ? (input = parseWeekday(input, this.localeData()), this.add(input - day, "d")) : day;
    }
    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return null == input ? weekday : this.add(input - weekday, "d");
    }
    function getSetISODayOfWeek(input) {
        if (!this.isValid()) return null != input ? this : NaN;
        if (null != input) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        }
        return this.day() || 7;
    }
    function weekdaysRegex(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex), 
        this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex);
    }
    function weekdaysShortRegex(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = defaultWeekdaysShortRegex), 
        this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
    }
    function weekdaysMinRegex(isStrict) {
        return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), 
        isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = defaultWeekdaysMinRegex), 
        this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
    }
    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }
        var i, mom, minp, shortp, longp, minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [];
        for (i = 0; i < 7; i++) mom = createUTC([ 2e3, 1 ]).day(i), minp = this.weekdaysMin(mom, ""), 
        shortp = this.weekdaysShort(mom, ""), longp = this.weekdays(mom, ""), minPieces.push(minp), 
        shortPieces.push(shortp), longPieces.push(longp), mixedPieces.push(minp), mixedPieces.push(shortp), 
        mixedPieces.push(longp);
        for (minPieces.sort(cmpLenRev), shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), 
        mixedPieces.sort(cmpLenRev), i = 0; i < 7; i++) shortPieces[i] = regexEscape(shortPieces[i]), 
        longPieces[i] = regexEscape(longPieces[i]), mixedPieces[i] = regexEscape(mixedPieces[i]);
        this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, 
        this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), 
        this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i"), 
        this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i");
    }
    function hFormat() {
        return this.hours() % 12 || 12;
    }
    function kFormat() {
        return this.hours() || 24;
    }
    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }
    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }
    function localeIsPM(input) {
        return "p" === (input + "").toLowerCase().charAt(0);
    }
    function localeMeridiem(hours, minutes, isLower) {
        return hours > 11 ? isLower ? "pm" : "PM" : isLower ? "am" : "AM";
    }
    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key;
    }
    function chooseLocale(names) {
        for (var j, next, locale, split, i = 0; i < names.length; ) {
            for (split = normalizeLocale(names[i]).split("-"), j = split.length, next = normalizeLocale(names[i + 1]), 
            next = next ? next.split("-") : null; j > 0; ) {
                if (locale = loadLocale(split.slice(0, j).join("-"))) return locale;
                if (next && next.length >= j && compareArrays(split, next, !0) >= j - 1) break;
                j--;
            }
            i++;
        }
        return null;
    }
    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && "undefined" != typeof module && module && module.exports) try {
            oldLocale = globalLocale._abbr, require("./locale/" + name), getSetGlobalLocale(oldLocale);
        } catch (e) {}
        return locales[name];
    }
    function getSetGlobalLocale(key, values) {
        var data;
        return key && (data = isUndefined(values) ? getLocale(key) : defineLocale(key, values), 
        data && (globalLocale = data)), globalLocale._abbr;
    }
    function defineLocale(name, config) {
        if (null !== config) {
            var parentConfig = baseConfig;
            if (config.abbr = name, null != locales[name]) deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), 
            parentConfig = locales[name]._config; else if (null != config.parentLocale) {
                if (null == locales[config.parentLocale]) return localeFamilies[config.parentLocale] || (localeFamilies[config.parentLocale] = []), 
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                }), null;
                parentConfig = locales[config.parentLocale]._config;
            }
            return locales[name] = new Locale(mergeConfigs(parentConfig, config)), localeFamilies[name] && localeFamilies[name].forEach(function(x) {
                defineLocale(x.name, x.config);
            }), getSetGlobalLocale(name), locales[name];
        }
        return delete locales[name], null;
    }
    function updateLocale(name, config) {
        if (null != config) {
            var locale, parentConfig = baseConfig;
            null != locales[name] && (parentConfig = locales[name]._config), config = mergeConfigs(parentConfig, config), 
            locale = new Locale(config), locale.parentLocale = locales[name], locales[name] = locale, 
            getSetGlobalLocale(name);
        } else null != locales[name] && (null != locales[name].parentLocale ? locales[name] = locales[name].parentLocale : null != locales[name] && delete locales[name]);
        return locales[name];
    }
    function getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key) return globalLocale;
        if (!isArray(key)) {
            if (locale = loadLocale(key)) return locale;
            key = [ key ];
        }
        return chooseLocale(key);
    }
    function listLocales() {
        return keys$1(locales);
    }
    function checkOverflow(m) {
        var overflow, a = m._a;
        return a && getParsingFlags(m).overflow === -2 && (overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || 24 === a[HOUR] && (0 !== a[MINUTE] || 0 !== a[SECOND] || 0 !== a[MILLISECOND]) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1, 
        getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE) && (overflow = DATE), 
        getParsingFlags(m)._overflowWeeks && overflow === -1 && (overflow = WEEK), getParsingFlags(m)._overflowWeekday && overflow === -1 && (overflow = WEEKDAY), 
        getParsingFlags(m).overflow = overflow), m;
    }
    function configFromISO(config) {
        var i, l, allowTime, dateFormat, timeFormat, tzFormat, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string);
        if (match) {
            for (getParsingFlags(config).iso = !0, i = 0, l = isoDates.length; i < l; i++) if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0], allowTime = isoDates[i][2] !== !1;
                break;
            }
            if (null == dateFormat) return void (config._isValid = !1);
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) if (isoTimes[i][1].exec(match[3])) {
                    timeFormat = (match[2] || " ") + isoTimes[i][0];
                    break;
                }
                if (null == timeFormat) return void (config._isValid = !1);
            }
            if (!allowTime && null != timeFormat) return void (config._isValid = !1);
            if (match[4]) {
                if (!tzRegex.exec(match[4])) return void (config._isValid = !1);
                tzFormat = "Z";
            }
            config._f = dateFormat + (timeFormat || "") + (tzFormat || ""), configFromStringAndFormat(config);
        } else config._isValid = !1;
    }
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        return null !== matched ? void (config._d = new Date(+matched[1])) : (configFromISO(config), 
        void (config._isValid === !1 && (delete config._isValid, hooks.createFromInputFallback(config))));
    }
    function defaults(a, b, c) {
        return null != a ? a : null != b ? b : c;
    }
    function currentDateArray(config) {
        var nowValue = new Date(hooks.now());
        return config._useUTC ? [ nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate() ] : [ nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate() ];
    }
    function configFromArray(config) {
        var i, date, currentDate, yearToUse, input = [];
        if (!config._d) {
            for (currentDate = currentDateArray(config), config._w && null == config._a[DATE] && null == config._a[MONTH] && dayOfYearFromWeekInfo(config), 
            config._dayOfYear && (yearToUse = defaults(config._a[YEAR], currentDate[YEAR]), 
            config._dayOfYear > daysInYear(yearToUse) && (getParsingFlags(config)._overflowDayOfYear = !0), 
            date = createUTCDate(yearToUse, 0, config._dayOfYear), config._a[MONTH] = date.getUTCMonth(), 
            config._a[DATE] = date.getUTCDate()), i = 0; i < 3 && null == config._a[i]; ++i) config._a[i] = input[i] = currentDate[i];
            for (;i < 7; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
            24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND] && (config._nextDay = !0, 
            config._a[HOUR] = 0), config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input), 
            null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), 
            config._nextDay && (config._a[HOUR] = 24);
        }
    }
    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
        if (w = config._w, null != w.GG || null != w.W || null != w.E) dow = 1, doy = 4, 
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year), 
        week = defaults(w.W, 1), weekday = defaults(w.E, 1), (weekday < 1 || weekday > 7) && (weekdayOverflow = !0); else {
            dow = config._locale._week.dow, doy = config._locale._week.doy;
            var curWeek = weekOfYear(createLocal(), dow, doy);
            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year), week = defaults(w.w, curWeek.week), 
            null != w.d ? (weekday = w.d, (weekday < 0 || weekday > 6) && (weekdayOverflow = !0)) : null != w.e ? (weekday = w.e + dow, 
            (w.e < 0 || w.e > 6) && (weekdayOverflow = !0)) : weekday = dow;
        }
        week < 1 || week > weeksInYear(weekYear, dow, doy) ? getParsingFlags(config)._overflowWeeks = !0 : null != weekdayOverflow ? getParsingFlags(config)._overflowWeekday = !0 : (temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), 
        config._a[YEAR] = temp.year, config._dayOfYear = temp.dayOfYear);
    }
    function configFromStringAndFormat(config) {
        if (config._f === hooks.ISO_8601) return void configFromISO(config);
        config._a = [], getParsingFlags(config).empty = !0;
        var i, parsedInput, tokens, token, skipped, string = "" + config._i, stringLength = string.length, totalParsedInputLength = 0;
        for (tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [], 
        i = 0; i < tokens.length; i++) token = tokens[i], parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0], 
        parsedInput && (skipped = string.substr(0, string.indexOf(parsedInput)), skipped.length > 0 && getParsingFlags(config).unusedInput.push(skipped), 
        string = string.slice(string.indexOf(parsedInput) + parsedInput.length), totalParsedInputLength += parsedInput.length), 
        formatTokenFunctions[token] ? (parsedInput ? getParsingFlags(config).empty = !1 : getParsingFlags(config).unusedTokens.push(token), 
        addTimeToArrayFromToken(token, parsedInput, config)) : config._strict && !parsedInput && getParsingFlags(config).unusedTokens.push(token);
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength, string.length > 0 && getParsingFlags(config).unusedInput.push(string), 
        config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === !0 && config._a[HOUR] > 0 && (getParsingFlags(config).bigHour = void 0), 
        getParsingFlags(config).parsedDateParts = config._a.slice(0), getParsingFlags(config).meridiem = config._meridiem, 
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem), 
        configFromArray(config), checkOverflow(config);
    }
    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        return null == meridiem ? hour : null != locale.meridiemHour ? locale.meridiemHour(hour, meridiem) : null != locale.isPM ? (isPm = locale.isPM(meridiem), 
        isPm && hour < 12 && (hour += 12), isPm || 12 !== hour || (hour = 0), hour) : hour;
    }
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (0 === config._f.length) return getParsingFlags(config).invalidFormat = !0, void (config._d = new Date(NaN));
        for (i = 0; i < config._f.length; i++) currentScore = 0, tempConfig = copyConfig({}, config), 
        null != config._useUTC && (tempConfig._useUTC = config._useUTC), tempConfig._f = config._f[i], 
        configFromStringAndFormat(tempConfig), isValid(tempConfig) && (currentScore += getParsingFlags(tempConfig).charsLeftOver, 
        currentScore += 10 * getParsingFlags(tempConfig).unusedTokens.length, getParsingFlags(tempConfig).score = currentScore, 
        (null == scoreToBeat || currentScore < scoreToBeat) && (scoreToBeat = currentScore, 
        bestMoment = tempConfig));
        extend(config, bestMoment || tempConfig);
    }
    function configFromObject(config) {
        if (!config._d) {
            var i = normalizeObjectUnits(config._i);
            config._a = map([ i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond ], function(obj) {
                return obj && parseInt(obj, 10);
            }), configFromArray(config);
        }
    }
    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        return res._nextDay && (res.add(1, "d"), res._nextDay = void 0), res;
    }
    function prepareConfig(config) {
        var input = config._i, format = config._f;
        return config._locale = config._locale || getLocale(config._l), null === input || void 0 === format && "" === input ? createInvalid({
            nullInput: !0
        }) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), 
        isMoment(input) ? new Moment(checkOverflow(input)) : (isDate(input) ? config._d = input : isArray(format) ? configFromStringAndArray(config) : format ? configFromStringAndFormat(config) : configFromInput(config), 
        isValid(config) || (config._d = null), config));
    }
    function configFromInput(config) {
        var input = config._i;
        void 0 === input ? config._d = new Date(hooks.now()) : isDate(input) ? config._d = new Date(input.valueOf()) : "string" == typeof input ? configFromString(config) : isArray(input) ? (config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
        }), configFromArray(config)) : "object" == typeof input ? configFromObject(config) : isNumber(input) ? config._d = new Date(input) : hooks.createFromInputFallback(config);
    }
    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        return locale !== !0 && locale !== !1 || (strict = locale, locale = void 0), (isObject(input) && isObjectEmpty(input) || isArray(input) && 0 === input.length) && (input = void 0), 
        c._isAMomentObject = !0, c._useUTC = c._isUTC = isUTC, c._l = locale, c._i = input, 
        c._f = format, c._strict = strict, createFromConfig(c);
    }
    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, !1);
    }
    function pickBy(fn, moments) {
        var res, i;
        if (1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length) return createLocal();
        for (res = moments[0], i = 1; i < moments.length; ++i) moments[i].isValid() && !moments[i][fn](res) || (res = moments[i]);
        return res;
    }
    function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args);
    }
    function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args);
    }
    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 1e3 * hours * 60 * 60, 
        this._days = +days + 7 * weeks, this._months = +months + 3 * quarters + 12 * years, 
        this._data = {}, this._locale = getLocale(), this._bubble();
    }
    function isDuration(obj) {
        return obj instanceof Duration;
    }
    function absRound(number) {
        return number < 0 ? Math.round(-1 * number) * -1 : Math.round(number);
    }
    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset(), sign = "+";
            return offset < 0 && (offset = -offset, sign = "-"), sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2);
        });
    }
    function offsetFromString(matcher, string) {
        var matches = (string || "").match(matcher);
        if (null === matches) return null;
        var chunk = matches[matches.length - 1] || [], parts = (chunk + "").match(chunkOffset) || [ "-", 0, 0 ], minutes = +(60 * parts[1]) + toInt(parts[2]);
        return 0 === minutes ? 0 : "+" === parts[0] ? minutes : -minutes;
    }
    function cloneWithOffset(input, model) {
        var res, diff;
        return model._isUTC ? (res = model.clone(), diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(), 
        res._d.setTime(res._d.valueOf() + diff), hooks.updateOffset(res, !1), res) : createLocal(input).local();
    }
    function getDateOffset(m) {
        return 15 * -Math.round(m._d.getTimezoneOffset() / 15);
    }
    function getSetOffset(input, keepLocalTime) {
        var localAdjust, offset = this._offset || 0;
        if (!this.isValid()) return null != input ? this : NaN;
        if (null != input) {
            if ("string" == typeof input) {
                if (input = offsetFromString(matchShortOffset, input), null === input) return this;
            } else Math.abs(input) < 16 && (input *= 60);
            return !this._isUTC && keepLocalTime && (localAdjust = getDateOffset(this)), this._offset = input, 
            this._isUTC = !0, null != localAdjust && this.add(localAdjust, "m"), offset !== input && (!keepLocalTime || this._changeInProgress ? addSubtract(this, createDuration(input - offset, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, 
            hooks.updateOffset(this, !0), this._changeInProgress = null)), this;
        }
        return this._isUTC ? offset : getDateOffset(this);
    }
    function getSetZone(input, keepLocalTime) {
        return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), 
        this) : -this.utcOffset();
    }
    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }
    function setOffsetToLocal(keepLocalTime) {
        return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = !1, keepLocalTime && this.subtract(getDateOffset(this), "m")), 
        this;
    }
    function setOffsetToParsedOffset() {
        if (null != this._tzm) this.utcOffset(this._tzm); else if ("string" == typeof this._i) {
            var tZone = offsetFromString(matchOffset, this._i);
            null != tZone ? this.utcOffset(tZone) : this.utcOffset(0, !0);
        }
        return this;
    }
    function hasAlignedHourOffset(input) {
        return !!this.isValid() && (input = input ? createLocal(input).utcOffset() : 0, 
        (this.utcOffset() - input) % 60 === 0);
    }
    function isDaylightSavingTime() {
        return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }
    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) return this._isDSTShifted;
        var c = {};
        if (copyConfig(c, this), c = prepareConfig(c), c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else this._isDSTShifted = !1;
        return this._isDSTShifted;
    }
    function isLocal() {
        return !!this.isValid() && !this._isUTC;
    }
    function isUtcOffset() {
        return !!this.isValid() && this._isUTC;
    }
    function isUtc() {
        return !!this.isValid() && (this._isUTC && 0 === this._offset);
    }
    function createDuration(input, key) {
        var sign, ret, diffRes, duration = input, match = null;
        return isDuration(input) ? duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
        } : isNumber(input) ? (duration = {}, key ? duration[key] = input : duration.milliseconds = input) : (match = aspNetRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, 
        duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(absRound(1e3 * match[MILLISECOND])) * sign
        }) : (match = isoRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign)
        }) : null == duration ? duration = {} : "object" == typeof duration && ("from" in duration || "to" in duration) && (diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to)), 
        duration = {}, duration.ms = diffRes.milliseconds, duration.M = diffRes.months), 
        ret = new Duration(duration), isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), 
        ret;
    }
    function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(",", "."));
        return (isNaN(res) ? 0 : res) * sign;
    }
    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };
        return res.months = other.month() - base.month() + 12 * (other.year() - base.year()), 
        base.clone().add(res.months, "M").isAfter(other) && --res.months, res.milliseconds = +other - +base.clone().add(res.months, "M"), 
        res;
    }
    function momentsDifference(base, other) {
        var res;
        return base.isValid() && other.isValid() ? (other = cloneWithOffset(other, base), 
        base.isBefore(other) ? res = positiveMomentsDifference(base, other) : (res = positiveMomentsDifference(other, base), 
        res.milliseconds = -res.milliseconds, res.months = -res.months), res) : {
            milliseconds: 0,
            months: 0
        };
    }
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            return null === period || isNaN(+period) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), 
            tmp = val, val = period, period = tmp), val = "string" == typeof val ? +val : val, 
            dur = createDuration(val, period), addSubtract(this, dur, direction), this;
        };
    }
    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = absRound(duration._days), months = absRound(duration._months);
        mom.isValid() && (updateOffset = null == updateOffset || updateOffset, milliseconds && mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding), 
        days && set$1(mom, "Date", get(mom, "Date") + days * isAdding), months && setMonth(mom, get(mom, "Month") + months * isAdding), 
        updateOffset && hooks.updateOffset(mom, days || months));
    }
    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, "days", !0);
        return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse";
    }
    function calendar$1(time, formats) {
        var now = time || createLocal(), sod = cloneWithOffset(now, this).startOf("day"), format = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }
    function clone() {
        return new Moment(this);
    }
    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        return !(!this.isValid() || !localInput.isValid()) && (units = normalizeUnits(isUndefined(units) ? "millisecond" : units), 
        "millisecond" === units ? this.valueOf() > localInput.valueOf() : localInput.valueOf() < this.clone().startOf(units).valueOf());
    }
    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        return !(!this.isValid() || !localInput.isValid()) && (units = normalizeUnits(isUndefined(units) ? "millisecond" : units), 
        "millisecond" === units ? this.valueOf() < localInput.valueOf() : this.clone().endOf(units).valueOf() < localInput.valueOf());
    }
    function isBetween(from, to, units, inclusivity) {
        return inclusivity = inclusivity || "()", ("(" === inclusivity[0] ? this.isAfter(from, units) : !this.isBefore(from, units)) && (")" === inclusivity[1] ? this.isBefore(to, units) : !this.isAfter(to, units));
    }
    function isSame(input, units) {
        var inputMs, localInput = isMoment(input) ? input : createLocal(input);
        return !(!this.isValid() || !localInput.isValid()) && (units = normalizeUnits(units || "millisecond"), 
        "millisecond" === units ? this.valueOf() === localInput.valueOf() : (inputMs = localInput.valueOf(), 
        this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf()));
    }
    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }
    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }
    function diff(input, units, asFloat) {
        var that, zoneDelta, delta, output;
        return this.isValid() ? (that = cloneWithOffset(input, this), that.isValid() ? (zoneDelta = 6e4 * (that.utcOffset() - this.utcOffset()), 
        units = normalizeUnits(units), "year" === units || "month" === units || "quarter" === units ? (output = monthDiff(this, that), 
        "quarter" === units ? output /= 3 : "year" === units && (output /= 12)) : (delta = this - that, 
        output = "second" === units ? delta / 1e3 : "minute" === units ? delta / 6e4 : "hour" === units ? delta / 36e5 : "day" === units ? (delta - zoneDelta) / 864e5 : "week" === units ? (delta - zoneDelta) / 6048e5 : delta), 
        asFloat ? output : absFloor(output)) : NaN) : NaN;
    }
    function monthDiff(a, b) {
        var anchor2, adjust, wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months");
        return b - anchor < 0 ? (anchor2 = a.clone().add(wholeMonthDiff - 1, "months"), 
        adjust = (b - anchor) / (anchor - anchor2)) : (anchor2 = a.clone().add(wholeMonthDiff + 1, "months"), 
        adjust = (b - anchor) / (anchor2 - anchor)), -(wholeMonthDiff + adjust) || 0;
    }
    function toString() {
        return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }
    function toISOString() {
        var m = this.clone().utc();
        return 0 < m.year() && m.year() <= 9999 ? isFunction(Date.prototype.toISOString) ? this.toDate().toISOString() : formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]");
    }
    function inspect() {
        if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
        var func = "moment", zone = "";
        this.isLocal() || (func = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", 
        zone = "Z");
        var prefix = "[" + func + '("]', year = 0 < this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", datetime = "-MM-DD[T]HH:mm:ss.SSS", suffix = zone + '[")]';
        return this.format(prefix + year + datetime + suffix);
    }
    function format(inputString) {
        inputString || (inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }
    function from(time, withoutSuffix) {
        return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
            to: this,
            from: time
        }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }
    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }
    function to(time, withoutSuffix) {
        return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
            from: this,
            to: time
        }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate();
    }
    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }
    function locale(key) {
        var newLocaleData;
        return void 0 === key ? this._locale._abbr : (newLocaleData = getLocale(key), null != newLocaleData && (this._locale = newLocaleData), 
        this);
    }
    function localeData() {
        return this._locale;
    }
    function startOf(units) {
        switch (units = normalizeUnits(units)) {
          case "year":
            this.month(0);

          case "quarter":
          case "month":
            this.date(1);

          case "week":
          case "isoWeek":
          case "day":
          case "date":
            this.hours(0);

          case "hour":
            this.minutes(0);

          case "minute":
            this.seconds(0);

          case "second":
            this.milliseconds(0);
        }
        return "week" === units && this.weekday(0), "isoWeek" === units && this.isoWeekday(1), 
        "quarter" === units && this.month(3 * Math.floor(this.month() / 3)), this;
    }
    function endOf(units) {
        return units = normalizeUnits(units), void 0 === units || "millisecond" === units ? this : ("date" === units && (units = "day"), 
        this.startOf(units).add(1, "isoWeek" === units ? "week" : units).subtract(1, "ms"));
    }
    function valueOf() {
        return this._d.valueOf() - 6e4 * (this._offset || 0);
    }
    function unix() {
        return Math.floor(this.valueOf() / 1e3);
    }
    function toDate() {
        return new Date(this.valueOf());
    }
    function toArray() {
        var m = this;
        return [ m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond() ];
    }
    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }
    function toJSON() {
        return this.isValid() ? this.toISOString() : null;
    }
    function isValid$1() {
        return isValid(this);
    }
    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }
    function invalidAt() {
        return getParsingFlags(this).overflow;
    }
    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }
    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [ token, token.length ], 0, getter);
    }
    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }
    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }
    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }
    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }
    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        return null == input ? weekOfYear(this, dow, doy).year : (weeksTarget = weeksInYear(input, dow, doy), 
        week > weeksTarget && (week = weeksTarget), setWeekAll.call(this, input, week, weekday, dow, doy));
    }
    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        return this.year(date.getUTCFullYear()), this.month(date.getUTCMonth()), this.date(date.getUTCDate()), 
        this;
    }
    function getSetQuarter(input) {
        return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3);
    }
    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
        return null == input ? dayOfYear : this.add(input - dayOfYear, "d");
    }
    function parseMs(input, array) {
        array[MILLISECOND] = toInt(1e3 * ("0." + input));
    }
    function getZoneAbbr() {
        return this._isUTC ? "UTC" : "";
    }
    function getZoneName() {
        return this._isUTC ? "Coordinated Universal Time" : "";
    }
    function createUnix(input) {
        return createLocal(1e3 * input);
    }
    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }
    function preParsePostFormat(string) {
        return string;
    }
    function get$1(format, index, field, setter) {
        var locale = getLocale(), utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }
    function listMonthsImpl(format, index, field) {
        if (isNumber(format) && (index = format, format = void 0), format = format || "", 
        null != index) return get$1(format, index, field, "month");
        var i, out = [];
        for (i = 0; i < 12; i++) out[i] = get$1(format, i, field, "month");
        return out;
    }
    function listWeekdaysImpl(localeSorted, format, index, field) {
        "boolean" == typeof localeSorted ? (isNumber(format) && (index = format, format = void 0), 
        format = format || "") : (format = localeSorted, index = format, localeSorted = !1, 
        isNumber(format) && (index = format, format = void 0), format = format || "");
        var locale = getLocale(), shift = localeSorted ? locale._week.dow : 0;
        if (null != index) return get$1(format, (index + shift) % 7, field, "day");
        var i, out = [];
        for (i = 0; i < 7; i++) out[i] = get$1(format, (i + shift) % 7, field, "day");
        return out;
    }
    function listMonths(format, index) {
        return listMonthsImpl(format, index, "months");
    }
    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, "monthsShort");
    }
    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdays");
    }
    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort");
    }
    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin");
    }
    function abs() {
        var data = this._data;
        return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), 
        this._months = mathAbs(this._months), data.milliseconds = mathAbs(data.milliseconds), 
        data.seconds = mathAbs(data.seconds), data.minutes = mathAbs(data.minutes), data.hours = mathAbs(data.hours), 
        data.months = mathAbs(data.months), data.years = mathAbs(data.years), this;
    }
    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);
        return duration._milliseconds += direction * other._milliseconds, duration._days += direction * other._days, 
        duration._months += direction * other._months, duration._bubble();
    }
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }
    function absCeil(number) {
        return number < 0 ? Math.floor(number) : Math.ceil(number);
    }
    function bubble() {
        var seconds, minutes, hours, years, monthsFromDays, milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data;
        return milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0 || (milliseconds += 864e5 * absCeil(monthsToDays(months) + days), 
        days = 0, months = 0), data.milliseconds = milliseconds % 1e3, seconds = absFloor(milliseconds / 1e3), 
        data.seconds = seconds % 60, minutes = absFloor(seconds / 60), data.minutes = minutes % 60, 
        hours = absFloor(minutes / 60), data.hours = hours % 24, days += absFloor(hours / 24), 
        monthsFromDays = absFloor(daysToMonths(days)), months += monthsFromDays, days -= absCeil(monthsToDays(monthsFromDays)), 
        years = absFloor(months / 12), months %= 12, data.days = days, data.months = months, 
        data.years = years, this;
    }
    function daysToMonths(days) {
        return 4800 * days / 146097;
    }
    function monthsToDays(months) {
        return 146097 * months / 4800;
    }
    function as(units) {
        var days, months, milliseconds = this._milliseconds;
        if (units = normalizeUnits(units), "month" === units || "year" === units) return days = this._days + milliseconds / 864e5, 
        months = this._months + daysToMonths(days), "month" === units ? months : months / 12;
        switch (days = this._days + Math.round(monthsToDays(this._months)), units) {
          case "week":
            return days / 7 + milliseconds / 6048e5;

          case "day":
            return days + milliseconds / 864e5;

          case "hour":
            return 24 * days + milliseconds / 36e5;

          case "minute":
            return 1440 * days + milliseconds / 6e4;

          case "second":
            return 86400 * days + milliseconds / 1e3;

          case "millisecond":
            return Math.floor(864e5 * days) + milliseconds;

          default:
            throw new Error("Unknown unit " + units);
        }
    }
    function valueOf$1() {
        return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12);
    }
    function makeAs(alias) {
        return function() {
            return this.as(alias);
        };
    }
    function get$2(units) {
        return units = normalizeUnits(units), this[units + "s"]();
    }
    function makeGetter(name) {
        return function() {
            return this._data[name];
        };
    }
    function weeks() {
        return absFloor(this.days() / 7);
    }
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }
    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), a = seconds < thresholds.s && [ "s", seconds ] || minutes <= 1 && [ "m" ] || minutes < thresholds.m && [ "mm", minutes ] || hours <= 1 && [ "h" ] || hours < thresholds.h && [ "hh", hours ] || days <= 1 && [ "d" ] || days < thresholds.d && [ "dd", days ] || months <= 1 && [ "M" ] || months < thresholds.M && [ "MM", months ] || years <= 1 && [ "y" ] || [ "yy", years ];
        return a[2] = withoutSuffix, a[3] = +posNegDuration > 0, a[4] = locale, substituteTimeAgo.apply(null, a);
    }
    function getSetRelativeTimeRounding(roundingFunction) {
        return void 0 === roundingFunction ? round : "function" == typeof roundingFunction && (round = roundingFunction, 
        !0);
    }
    function getSetRelativeTimeThreshold(threshold, limit) {
        return void 0 !== thresholds[threshold] && (void 0 === limit ? thresholds[threshold] : (thresholds[threshold] = limit, 
        !0));
    }
    function humanize(withSuffix) {
        var locale = this.localeData(), output = relativeTime$1(this, !withSuffix, locale);
        return withSuffix && (output = locale.pastFuture(+this, output)), locale.postformat(output);
    }
    function toISOString$1() {
        var minutes, hours, years, seconds = abs$1(this._milliseconds) / 1e3, days = abs$1(this._days), months = abs$1(this._months);
        minutes = absFloor(seconds / 60), hours = absFloor(minutes / 60), seconds %= 60, 
        minutes %= 60, years = absFloor(months / 12), months %= 12;
        var Y = years, M = months, D = days, h = hours, m = minutes, s = seconds, total = this.asSeconds();
        return total ? (total < 0 ? "-" : "") + "P" + (Y ? Y + "Y" : "") + (M ? M + "M" : "") + (D ? D + "D" : "") + (h || m || s ? "T" : "") + (h ? h + "H" : "") + (m ? m + "M" : "") + (s ? s + "S" : "") : "P0D";
    }
    var hookCallback, some;
    some = Array.prototype.some ? Array.prototype.some : function(fun) {
        for (var t = Object(this), len = t.length >>> 0, i = 0; i < len; i++) if (i in t && fun.call(this, t[i], i, t)) return !0;
        return !1;
    };
    var some$1 = some, momentProperties = hooks.momentProperties = [], updateInProgress = !1, deprecations = {};
    hooks.suppressDeprecationWarnings = !1, hooks.deprecationHandler = null;
    var keys;
    keys = Object.keys ? Object.keys : function(obj) {
        var i, res = [];
        for (i in obj) hasOwnProp(obj, i) && res.push(i);
        return res;
    };
    var indexOf, keys$1 = keys, defaultCalendar = {
        sameDay: "[Today at] LT",
        nextDay: "[Tomorrow at] LT",
        nextWeek: "dddd [at] LT",
        lastDay: "[Yesterday at] LT",
        lastWeek: "[Last] dddd [at] LT",
        sameElse: "L"
    }, defaultLongDateFormat = {
        LTS: "h:mm:ss A",
        LT: "h:mm A",
        L: "MM/DD/YYYY",
        LL: "MMMM D, YYYY",
        LLL: "MMMM D, YYYY h:mm A",
        LLLL: "dddd, MMMM D, YYYY h:mm A"
    }, defaultInvalidDate = "Invalid date", defaultOrdinal = "%d", defaultOrdinalParse = /\d{1,2}/, defaultRelativeTime = {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        m: "a minute",
        mm: "%d minutes",
        h: "an hour",
        hh: "%d hours",
        d: "a day",
        dd: "%d days",
        M: "a month",
        MM: "%d months",
        y: "a year",
        yy: "%d years"
    }, aliases = {}, priorities = {}, formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, formatFunctions = {}, formatTokenFunctions = {}, match1 = /\d/, match2 = /\d\d/, match3 = /\d{3}/, match4 = /\d{4}/, match6 = /[+-]?\d{6}/, match1to2 = /\d\d?/, match3to4 = /\d\d\d\d?/, match5to6 = /\d\d\d\d\d\d?/, match1to3 = /\d{1,3}/, match1to4 = /\d{1,4}/, match1to6 = /[+-]?\d{1,6}/, matchUnsigned = /\d+/, matchSigned = /[+-]?\d+/, matchOffset = /Z|[+-]\d\d:?\d\d/gi, matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, regexes = {}, tokens = {}, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, WEEK = 7, WEEKDAY = 8;
    indexOf = Array.prototype.indexOf ? Array.prototype.indexOf : function(o) {
        var i;
        for (i = 0; i < this.length; ++i) if (this[i] === o) return i;
        return -1;
    };
    var indexOf$1 = indexOf;
    addFormatToken("M", [ "MM", 2 ], "Mo", function() {
        return this.month() + 1;
    }), addFormatToken("MMM", 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    }), addFormatToken("MMMM", 0, 0, function(format) {
        return this.localeData().months(this, format);
    }), addUnitAlias("month", "M"), addUnitPriority("month", 8), addRegexToken("M", match1to2), 
    addRegexToken("MM", match1to2, match2), addRegexToken("MMM", function(isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    }), addRegexToken("MMMM", function(isStrict, locale) {
        return locale.monthsRegex(isStrict);
    }), addParseToken([ "M", "MM" ], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    }), addParseToken([ "MMM", "MMMM" ], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        null != month ? array[MONTH] = month : getParsingFlags(config).invalidMonth = input;
    });
    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), defaultMonthsShortRegex = matchWord, defaultMonthsRegex = matchWord;
    addFormatToken("Y", 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? "" + y : "+" + y;
    }), addFormatToken(0, [ "YY", 2 ], 0, function() {
        return this.year() % 100;
    }), addFormatToken(0, [ "YYYY", 4 ], 0, "year"), addFormatToken(0, [ "YYYYY", 5 ], 0, "year"), 
    addFormatToken(0, [ "YYYYYY", 6, !0 ], 0, "year"), addUnitAlias("year", "y"), addUnitPriority("year", 1), 
    addRegexToken("Y", matchSigned), addRegexToken("YY", match1to2, match2), addRegexToken("YYYY", match1to4, match4), 
    addRegexToken("YYYYY", match1to6, match6), addRegexToken("YYYYYY", match1to6, match6), 
    addParseToken([ "YYYYY", "YYYYYY" ], YEAR), addParseToken("YYYY", function(input, array) {
        array[YEAR] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input);
    }), addParseToken("YY", function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    }), addParseToken("Y", function(input, array) {
        array[YEAR] = parseInt(input, 10);
    }), hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
    };
    var getSetYear = makeGetSet("FullYear", !0);
    addFormatToken("w", [ "ww", 2 ], "wo", "week"), addFormatToken("W", [ "WW", 2 ], "Wo", "isoWeek"), 
    addUnitAlias("week", "w"), addUnitAlias("isoWeek", "W"), addUnitPriority("week", 5), 
    addUnitPriority("isoWeek", 5), addRegexToken("w", match1to2), addRegexToken("ww", match1to2, match2), 
    addRegexToken("W", match1to2), addRegexToken("WW", match1to2, match2), addWeekParseToken([ "w", "ww", "W", "WW" ], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });
    var defaultLocaleWeek = {
        dow: 0,
        doy: 6
    };
    addFormatToken("d", 0, "do", "day"), addFormatToken("dd", 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    }), addFormatToken("ddd", 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    }), addFormatToken("dddd", 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    }), addFormatToken("e", 0, 0, "weekday"), addFormatToken("E", 0, 0, "isoWeekday"), 
    addUnitAlias("day", "d"), addUnitAlias("weekday", "e"), addUnitAlias("isoWeekday", "E"), 
    addUnitPriority("day", 11), addUnitPriority("weekday", 11), addUnitPriority("isoWeekday", 11), 
    addRegexToken("d", match1to2), addRegexToken("e", match1to2), addRegexToken("E", match1to2), 
    addRegexToken("dd", function(isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    }), addRegexToken("ddd", function(isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    }), addRegexToken("dddd", function(isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    }), addWeekParseToken([ "dd", "ddd", "dddd" ], function(input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        null != weekday ? week.d = weekday : getParsingFlags(config).invalidWeekday = input;
    }), addWeekParseToken([ "d", "e", "E" ], function(input, week, config, token) {
        week[token] = toInt(input);
    });
    var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), defaultWeekdaysRegex = matchWord, defaultWeekdaysShortRegex = matchWord, defaultWeekdaysMinRegex = matchWord;
    addFormatToken("H", [ "HH", 2 ], 0, "hour"), addFormatToken("h", [ "hh", 2 ], 0, hFormat), 
    addFormatToken("k", [ "kk", 2 ], 0, kFormat), addFormatToken("hmm", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    }), addFormatToken("hmmss", 0, 0, function() {
        return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    }), addFormatToken("Hmm", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2);
    }), addFormatToken("Hmmss", 0, 0, function() {
        return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    }), meridiem("a", !0), meridiem("A", !1), addUnitAlias("hour", "h"), addUnitPriority("hour", 13), 
    addRegexToken("a", matchMeridiem), addRegexToken("A", matchMeridiem), addRegexToken("H", match1to2), 
    addRegexToken("h", match1to2), addRegexToken("HH", match1to2, match2), addRegexToken("hh", match1to2, match2), 
    addRegexToken("hmm", match3to4), addRegexToken("hmmss", match5to6), addRegexToken("Hmm", match3to4), 
    addRegexToken("Hmmss", match5to6), addParseToken([ "H", "HH" ], HOUR), addParseToken([ "a", "A" ], function(input, array, config) {
        config._isPm = config._locale.isPM(input), config._meridiem = input;
    }), addParseToken([ "h", "hh" ], function(input, array, config) {
        array[HOUR] = toInt(input), getParsingFlags(config).bigHour = !0;
    }), addParseToken("hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos)), 
        getParsingFlags(config).bigHour = !0;
    }), addParseToken("hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
        array[SECOND] = toInt(input.substr(pos2)), getParsingFlags(config).bigHour = !0;
    }), addParseToken("Hmm", function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos));
    }), addParseToken("Hmmss", function(input, array, config) {
        var pos1 = input.length - 4, pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), 
        array[SECOND] = toInt(input.substr(pos2));
    });
    var globalLocale, defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i, getSetHour = makeGetSet("Hours", !0), baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        ordinalParse: defaultOrdinalParse,
        relativeTime: defaultRelativeTime,
        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,
        week: defaultLocaleWeek,
        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,
        meridiemParse: defaultLocaleMeridiemParse
    }, locales = {}, localeFamilies = {}, extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, tzRegex = /Z|[+-]\d\d(?::?\d\d)?/, isoDates = [ [ "YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/ ], [ "YYYY-MM-DD", /\d{4}-\d\d-\d\d/ ], [ "GGGG-[W]WW-E", /\d{4}-W\d\d-\d/ ], [ "GGGG-[W]WW", /\d{4}-W\d\d/, !1 ], [ "YYYY-DDD", /\d{4}-\d{3}/ ], [ "YYYY-MM", /\d{4}-\d\d/, !1 ], [ "YYYYYYMMDD", /[+-]\d{10}/ ], [ "YYYYMMDD", /\d{8}/ ], [ "GGGG[W]WWE", /\d{4}W\d{3}/ ], [ "GGGG[W]WW", /\d{4}W\d{2}/, !1 ], [ "YYYYDDD", /\d{7}/ ] ], isoTimes = [ [ "HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/ ], [ "HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/ ], [ "HH:mm:ss", /\d\d:\d\d:\d\d/ ], [ "HH:mm", /\d\d:\d\d/ ], [ "HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/ ], [ "HHmmss,SSSS", /\d\d\d\d\d\d,\d+/ ], [ "HHmmss", /\d\d\d\d\d\d/ ], [ "HHmm", /\d\d\d\d/ ], [ "HH", /\d\d/ ] ], aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
    hooks.createFromInputFallback = deprecate("value provided is not in a recognized ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""));
    }), hooks.ISO_8601 = function() {};
    var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        return this.isValid() && other.isValid() ? other < this ? this : other : createInvalid();
    }), prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
        var other = createLocal.apply(null, arguments);
        return this.isValid() && other.isValid() ? other > this ? this : other : createInvalid();
    }), now = function() {
        return Date.now ? Date.now() : +new Date();
    };
    offset("Z", ":"), offset("ZZ", ""), addRegexToken("Z", matchShortOffset), addRegexToken("ZZ", matchShortOffset), 
    addParseToken([ "Z", "ZZ" ], function(input, array, config) {
        config._useUTC = !0, config._tzm = offsetFromString(matchShortOffset, input);
    });
    var chunkOffset = /([\+\-]|\d\d)/gi;
    hooks.updateOffset = function() {};
    var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/, isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
    createDuration.fn = Duration.prototype;
    var add = createAdder(1, "add"), subtract = createAdder(-1, "subtract");
    hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
        return void 0 === key ? this.localeData() : this.locale(key);
    });
    addFormatToken(0, [ "gg", 2 ], 0, function() {
        return this.weekYear() % 100;
    }), addFormatToken(0, [ "GG", 2 ], 0, function() {
        return this.isoWeekYear() % 100;
    }), addWeekYearFormatToken("gggg", "weekYear"), addWeekYearFormatToken("ggggg", "weekYear"), 
    addWeekYearFormatToken("GGGG", "isoWeekYear"), addWeekYearFormatToken("GGGGG", "isoWeekYear"), 
    addUnitAlias("weekYear", "gg"), addUnitAlias("isoWeekYear", "GG"), addUnitPriority("weekYear", 1), 
    addUnitPriority("isoWeekYear", 1), addRegexToken("G", matchSigned), addRegexToken("g", matchSigned), 
    addRegexToken("GG", match1to2, match2), addRegexToken("gg", match1to2, match2), 
    addRegexToken("GGGG", match1to4, match4), addRegexToken("gggg", match1to4, match4), 
    addRegexToken("GGGGG", match1to6, match6), addRegexToken("ggggg", match1to6, match6), 
    addWeekParseToken([ "gggg", "ggggg", "GGGG", "GGGGG" ], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    }), addWeekParseToken([ "gg", "GG" ], function(input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    }), addFormatToken("Q", 0, "Qo", "quarter"), addUnitAlias("quarter", "Q"), addUnitPriority("quarter", 7), 
    addRegexToken("Q", match1), addParseToken("Q", function(input, array) {
        array[MONTH] = 3 * (toInt(input) - 1);
    }), addFormatToken("D", [ "DD", 2 ], "Do", "date"), addUnitAlias("date", "D"), addUnitPriority("date", 9), 
    addRegexToken("D", match1to2), addRegexToken("DD", match1to2, match2), addRegexToken("Do", function(isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
    }), addParseToken([ "D", "DD" ], DATE), addParseToken("Do", function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
    });
    var getSetDayOfMonth = makeGetSet("Date", !0);
    addFormatToken("DDD", [ "DDDD", 3 ], "DDDo", "dayOfYear"), addUnitAlias("dayOfYear", "DDD"), 
    addUnitPriority("dayOfYear", 4), addRegexToken("DDD", match1to3), addRegexToken("DDDD", match3), 
    addParseToken([ "DDD", "DDDD" ], function(input, array, config) {
        config._dayOfYear = toInt(input);
    }), addFormatToken("m", [ "mm", 2 ], 0, "minute"), addUnitAlias("minute", "m"), 
    addUnitPriority("minute", 14), addRegexToken("m", match1to2), addRegexToken("mm", match1to2, match2), 
    addParseToken([ "m", "mm" ], MINUTE);
    var getSetMinute = makeGetSet("Minutes", !1);
    addFormatToken("s", [ "ss", 2 ], 0, "second"), addUnitAlias("second", "s"), addUnitPriority("second", 15), 
    addRegexToken("s", match1to2), addRegexToken("ss", match1to2, match2), addParseToken([ "s", "ss" ], SECOND);
    var getSetSecond = makeGetSet("Seconds", !1);
    addFormatToken("S", 0, 0, function() {
        return ~~(this.millisecond() / 100);
    }), addFormatToken(0, [ "SS", 2 ], 0, function() {
        return ~~(this.millisecond() / 10);
    }), addFormatToken(0, [ "SSS", 3 ], 0, "millisecond"), addFormatToken(0, [ "SSSS", 4 ], 0, function() {
        return 10 * this.millisecond();
    }), addFormatToken(0, [ "SSSSS", 5 ], 0, function() {
        return 100 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSS", 6 ], 0, function() {
        return 1e3 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSS", 7 ], 0, function() {
        return 1e4 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSSS", 8 ], 0, function() {
        return 1e5 * this.millisecond();
    }), addFormatToken(0, [ "SSSSSSSSS", 9 ], 0, function() {
        return 1e6 * this.millisecond();
    }), addUnitAlias("millisecond", "ms"), addUnitPriority("millisecond", 16), addRegexToken("S", match1to3, match1), 
    addRegexToken("SS", match1to3, match2), addRegexToken("SSS", match1to3, match3);
    var token;
    for (token = "SSSS"; token.length <= 9; token += "S") addRegexToken(token, matchUnsigned);
    for (token = "S"; token.length <= 9; token += "S") addParseToken(token, parseMs);
    var getSetMillisecond = makeGetSet("Milliseconds", !1);
    addFormatToken("z", 0, 0, "zoneAbbr"), addFormatToken("zz", 0, 0, "zoneName");
    var proto = Moment.prototype;
    proto.add = add, proto.calendar = calendar$1, proto.clone = clone, proto.diff = diff, 
    proto.endOf = endOf, proto.format = format, proto.from = from, proto.fromNow = fromNow, 
    proto.to = to, proto.toNow = toNow, proto.get = stringGet, proto.invalidAt = invalidAt, 
    proto.isAfter = isAfter, proto.isBefore = isBefore, proto.isBetween = isBetween, 
    proto.isSame = isSame, proto.isSameOrAfter = isSameOrAfter, proto.isSameOrBefore = isSameOrBefore, 
    proto.isValid = isValid$1, proto.lang = lang, proto.locale = locale, proto.localeData = localeData, 
    proto.max = prototypeMax, proto.min = prototypeMin, proto.parsingFlags = parsingFlags, 
    proto.set = stringSet, proto.startOf = startOf, proto.subtract = subtract, proto.toArray = toArray, 
    proto.toObject = toObject, proto.toDate = toDate, proto.toISOString = toISOString, 
    proto.inspect = inspect, proto.toJSON = toJSON, proto.toString = toString, proto.unix = unix, 
    proto.valueOf = valueOf, proto.creationData = creationData, proto.year = getSetYear, 
    proto.isLeapYear = getIsLeapYear, proto.weekYear = getSetWeekYear, proto.isoWeekYear = getSetISOWeekYear, 
    proto.quarter = proto.quarters = getSetQuarter, proto.month = getSetMonth, proto.daysInMonth = getDaysInMonth, 
    proto.week = proto.weeks = getSetWeek, proto.isoWeek = proto.isoWeeks = getSetISOWeek, 
    proto.weeksInYear = getWeeksInYear, proto.isoWeeksInYear = getISOWeeksInYear, proto.date = getSetDayOfMonth, 
    proto.day = proto.days = getSetDayOfWeek, proto.weekday = getSetLocaleDayOfWeek, 
    proto.isoWeekday = getSetISODayOfWeek, proto.dayOfYear = getSetDayOfYear, proto.hour = proto.hours = getSetHour, 
    proto.minute = proto.minutes = getSetMinute, proto.second = proto.seconds = getSetSecond, 
    proto.millisecond = proto.milliseconds = getSetMillisecond, proto.utcOffset = getSetOffset, 
    proto.utc = setOffsetToUTC, proto.local = setOffsetToLocal, proto.parseZone = setOffsetToParsedOffset, 
    proto.hasAlignedHourOffset = hasAlignedHourOffset, proto.isDST = isDaylightSavingTime, 
    proto.isLocal = isLocal, proto.isUtcOffset = isUtcOffset, proto.isUtc = isUtc, proto.isUTC = isUtc, 
    proto.zoneAbbr = getZoneAbbr, proto.zoneName = getZoneName, proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth), 
    proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth), 
    proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear), 
    proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone), 
    proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
    var proto$1 = Locale.prototype;
    proto$1.calendar = calendar, proto$1.longDateFormat = longDateFormat, proto$1.invalidDate = invalidDate, 
    proto$1.ordinal = ordinal, proto$1.preparse = preParsePostFormat, proto$1.postformat = preParsePostFormat, 
    proto$1.relativeTime = relativeTime, proto$1.pastFuture = pastFuture, proto$1.set = set, 
    proto$1.months = localeMonths, proto$1.monthsShort = localeMonthsShort, proto$1.monthsParse = localeMonthsParse, 
    proto$1.monthsRegex = monthsRegex, proto$1.monthsShortRegex = monthsShortRegex, 
    proto$1.week = localeWeek, proto$1.firstDayOfYear = localeFirstDayOfYear, proto$1.firstDayOfWeek = localeFirstDayOfWeek, 
    proto$1.weekdays = localeWeekdays, proto$1.weekdaysMin = localeWeekdaysMin, proto$1.weekdaysShort = localeWeekdaysShort, 
    proto$1.weekdaysParse = localeWeekdaysParse, proto$1.weekdaysRegex = weekdaysRegex, 
    proto$1.weekdaysShortRegex = weekdaysShortRegex, proto$1.weekdaysMinRegex = weekdaysMinRegex, 
    proto$1.isPM = localeIsPM, proto$1.meridiem = localeMeridiem, getSetGlobalLocale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10, output = 1 === toInt(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
            return number + output;
        }
    }), hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale), 
    hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
    var mathAbs = Math.abs, asMilliseconds = makeAs("ms"), asSeconds = makeAs("s"), asMinutes = makeAs("m"), asHours = makeAs("h"), asDays = makeAs("d"), asWeeks = makeAs("w"), asMonths = makeAs("M"), asYears = makeAs("y"), milliseconds = makeGetter("milliseconds"), seconds = makeGetter("seconds"), minutes = makeGetter("minutes"), hours = makeGetter("hours"), days = makeGetter("days"), months = makeGetter("months"), years = makeGetter("years"), round = Math.round, thresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    }, abs$1 = Math.abs, proto$2 = Duration.prototype;
    return proto$2.abs = abs, proto$2.add = add$1, proto$2.subtract = subtract$1, proto$2.as = as, 
    proto$2.asMilliseconds = asMilliseconds, proto$2.asSeconds = asSeconds, proto$2.asMinutes = asMinutes, 
    proto$2.asHours = asHours, proto$2.asDays = asDays, proto$2.asWeeks = asWeeks, proto$2.asMonths = asMonths, 
    proto$2.asYears = asYears, proto$2.valueOf = valueOf$1, proto$2._bubble = bubble, 
    proto$2.get = get$2, proto$2.milliseconds = milliseconds, proto$2.seconds = seconds, 
    proto$2.minutes = minutes, proto$2.hours = hours, proto$2.days = days, proto$2.weeks = weeks, 
    proto$2.months = months, proto$2.years = years, proto$2.humanize = humanize, proto$2.toISOString = toISOString$1, 
    proto$2.toString = toISOString$1, proto$2.toJSON = toISOString$1, proto$2.locale = locale, 
    proto$2.localeData = localeData, proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1), 
    proto$2.lang = lang, addFormatToken("X", 0, 0, "unix"), addFormatToken("x", 0, 0, "valueOf"), 
    addRegexToken("x", matchSigned), addRegexToken("X", matchTimestamp), addParseToken("X", function(input, array, config) {
        config._d = new Date(1e3 * parseFloat(input, 10));
    }), addParseToken("x", function(input, array, config) {
        config._d = new Date(toInt(input));
    }), hooks.version = "2.17.1", setHookCallback(createLocal), hooks.fn = proto, hooks.min = min, 
    hooks.max = max, hooks.now = now, hooks.utc = createUTC, hooks.unix = createUnix, 
    hooks.months = listMonths, hooks.isDate = isDate, hooks.locale = getSetGlobalLocale, 
    hooks.invalid = createInvalid, hooks.duration = createDuration, hooks.isMoment = isMoment, 
    hooks.weekdays = listWeekdays, hooks.parseZone = createInZone, hooks.localeData = getLocale, 
    hooks.isDuration = isDuration, hooks.monthsShort = listMonthsShort, hooks.weekdaysMin = listWeekdaysMin, 
    hooks.defineLocale = defineLocale, hooks.updateLocale = updateLocale, hooks.locales = listLocales, 
    hooks.weekdaysShort = listWeekdaysShort, hooks.normalizeUnits = normalizeUnits, 
    hooks.relativeTimeRounding = getSetRelativeTimeRounding, hooks.relativeTimeThreshold = getSetRelativeTimeThreshold, 
    hooks.calendarFormat = getCalendarFormat, hooks.prototype = proto, hooks;
}), function($) {
    function initMouseDetection(disable) {
        var eNS = ".smartmenus_mouse";
        if (mouseDetectionEnabled || disable) mouseDetectionEnabled && disable && ($(document).unbind(eNS), 
        mouseDetectionEnabled = !1); else {
            var firstTime = !0, lastMove = null;
            $(document).bind(getEventsNS([ [ "mousemove", function(e) {
                var thisMove = {
                    x: e.pageX,
                    y: e.pageY,
                    timeStamp: new Date().getTime()
                };
                if (lastMove) {
                    var deltaX = Math.abs(lastMove.x - thisMove.x), deltaY = Math.abs(lastMove.y - thisMove.y);
                    if ((deltaX > 0 || deltaY > 0) && deltaX <= 2 && deltaY <= 2 && thisMove.timeStamp - lastMove.timeStamp <= 300 && (mouse = !0, 
                    firstTime)) {
                        var $a = $(e.target).closest("a");
                        $a.is("a") && $.each(menuTrees, function() {
                            if ($.contains(this.$root[0], $a[0])) return this.itemEnter({
                                currentTarget: $a[0]
                            }), !1;
                        }), firstTime = !1;
                    }
                }
                lastMove = thisMove;
            } ], [ touchEvents() ? "touchstart" : "pointerover pointermove pointerout MSPointerOver MSPointerMove MSPointerOut", function(e) {
                isTouchEvent(e.originalEvent) && (mouse = !1);
            } ] ], eNS)), mouseDetectionEnabled = !0;
        }
    }
    function isTouchEvent(e) {
        return !/^(4|mouse)$/.test(e.pointerType);
    }
    function touchEvents() {
        return "ontouchstart" in window;
    }
    function getEventsNS(defArr, eNS) {
        eNS || (eNS = "");
        var obj = {};
        return $.each(defArr, function(index, value) {
            obj[value[0].split(" ").join(eNS + " ") + eNS] = value[1];
        }), obj;
    }
    var menuTrees = [], IE = !!window.createPopup, mouse = !1, mouseDetectionEnabled = !1;
    $.SmartMenus = function(elm, options) {
        this.$root = $(elm), this.opts = options, this.rootId = "", this.$subArrow = null, 
        this.subMenus = [], this.activatedItems = [], this.visibleSubMenus = [], this.showTimeout = 0, 
        this.hideTimeout = 0, this.scrollTimeout = 0, this.clickActivated = !1, this.zIndexInc = 0, 
        this.$firstLink = null, this.$firstSub = null, this.disabled = !1, this.$disableOverlay = null, 
        this.isTouchScrolling = !1, this.init();
    }, $.extend($.SmartMenus, {
        hideAll: function() {
            $.each(menuTrees, function() {
                this.menuHideAll();
            });
        },
        destroy: function() {
            for (;menuTrees.length; ) menuTrees[0].destroy();
            initMouseDetection(!0);
        },
        prototype: {
            init: function(refresh) {
                var self = this;
                if (!refresh) {
                    menuTrees.push(this), this.rootId = (new Date().getTime() + Math.random() + "").replace(/\D/g, ""), 
                    this.$root.hasClass("sm-rtl") && (this.opts.rightToLeftSubMenus = !0);
                    var eNS = ".smartmenus";
                    this.$root.data("smartmenus", this).attr("data-smartmenus-id", this.rootId).dataSM("level", 1).bind(getEventsNS([ [ "mouseover focusin", $.proxy(this.rootOver, this) ], [ "mouseout focusout", $.proxy(this.rootOut, this) ] ], eNS)).delegate("a", getEventsNS([ [ "mouseenter", $.proxy(this.itemEnter, this) ], [ "mouseleave", $.proxy(this.itemLeave, this) ], [ "mousedown", $.proxy(this.itemDown, this) ], [ "focus", $.proxy(this.itemFocus, this) ], [ "blur", $.proxy(this.itemBlur, this) ], [ "click", $.proxy(this.itemClick, this) ], [ "touchend", $.proxy(this.itemTouchEnd, this) ] ], eNS)), 
                    eNS += this.rootId, this.opts.hideOnClick && $(document).bind(getEventsNS([ [ "touchstart", $.proxy(this.docTouchStart, this) ], [ "touchmove", $.proxy(this.docTouchMove, this) ], [ "touchend", $.proxy(this.docTouchEnd, this) ], [ "click", $.proxy(this.docClick, this) ] ], eNS)), 
                    $(window).bind(getEventsNS([ [ "resize orientationchange", $.proxy(this.winResize, this) ] ], eNS)), 
                    this.opts.subIndicators && (this.$subArrow = $("<span/>").addClass("sub-arrow"), 
                    this.opts.subIndicatorsText && this.$subArrow.html(this.opts.subIndicatorsText)), 
                    initMouseDetection();
                }
                if (this.$firstSub = this.$root.find("ul").each(function() {
                    self.menuInit($(this));
                }).eq(0), this.$firstLink = this.$root.find("a").eq(0), this.opts.markCurrentItem) {
                    var reDefaultDoc = /(index|default)\.[^#\?\/]*/i, reHash = /#.*/, locHref = window.location.href.replace(reDefaultDoc, ""), locHrefNoHash = locHref.replace(reHash, "");
                    this.$root.find("a").each(function() {
                        var href = this.href.replace(reDefaultDoc, ""), $this = $(this);
                        href != locHref && href != locHrefNoHash || ($this.addClass("current"), self.opts.markCurrentTree && $this.parent().parentsUntil("[data-smartmenus-id]", "li").children("a").addClass("current"));
                    });
                }
            },
            destroy: function() {
                this.menuHideAll();
                var eNS = ".smartmenus";
                this.$root.removeData("smartmenus").removeAttr("data-smartmenus-id").removeDataSM("level").unbind(eNS).undelegate(eNS), 
                eNS += this.rootId, $(document).unbind(eNS), $(window).unbind(eNS), this.opts.subIndicators && (this.$subArrow = null);
                var self = this;
                $.each(this.subMenus, function() {
                    this.hasClass("mega-menu") && this.find("ul").removeDataSM("in-mega"), this.dataSM("shown-before") && ((self.opts.subMenusMinWidth || self.opts.subMenusMaxWidth) && this.css({
                        width: "",
                        minWidth: "",
                        maxWidth: ""
                    }).removeClass("sm-nowrap"), this.dataSM("scroll-arrows") && this.dataSM("scroll-arrows").remove(), 
                    this.css({
                        zIndex: "",
                        top: "",
                        left: "",
                        marginLeft: "",
                        marginTop: "",
                        display: ""
                    })), self.opts.subIndicators && this.dataSM("parent-a").removeClass("has-submenu").children("span.sub-arrow").remove(), 
                    this.removeDataSM("shown-before").removeDataSM("ie-shim").removeDataSM("scroll-arrows").removeDataSM("parent-a").removeDataSM("level").removeDataSM("beforefirstshowfired").parent().removeDataSM("sub");
                }), this.opts.markCurrentItem && this.$root.find("a.current").removeClass("current"), 
                this.$root = null, this.$firstLink = null, this.$firstSub = null, this.$disableOverlay && (this.$disableOverlay.remove(), 
                this.$disableOverlay = null), menuTrees.splice($.inArray(this, menuTrees), 1);
            },
            disable: function(noOverlay) {
                if (!this.disabled) {
                    if (this.menuHideAll(), !noOverlay && !this.opts.isPopup && this.$root.is(":visible")) {
                        var pos = this.$root.offset();
                        this.$disableOverlay = $('<div class="sm-jquery-disable-overlay"/>').css({
                            position: "absolute",
                            top: pos.top,
                            left: pos.left,
                            width: this.$root.outerWidth(),
                            height: this.$root.outerHeight(),
                            zIndex: this.getStartZIndex(!0),
                            opacity: 0
                        }).appendTo(document.body);
                    }
                    this.disabled = !0;
                }
            },
            docClick: function(e) {
                return this.isTouchScrolling ? void (this.isTouchScrolling = !1) : void ((this.visibleSubMenus.length && !$.contains(this.$root[0], e.target) || $(e.target).is("a")) && this.menuHideAll());
            },
            docTouchEnd: function(e) {
                if (this.lastTouch) {
                    if (this.visibleSubMenus.length && (void 0 === this.lastTouch.x2 || this.lastTouch.x1 == this.lastTouch.x2) && (void 0 === this.lastTouch.y2 || this.lastTouch.y1 == this.lastTouch.y2) && (!this.lastTouch.target || !$.contains(this.$root[0], this.lastTouch.target))) {
                        this.hideTimeout && (clearTimeout(this.hideTimeout), this.hideTimeout = 0);
                        var self = this;
                        this.hideTimeout = setTimeout(function() {
                            self.menuHideAll();
                        }, 350);
                    }
                    this.lastTouch = null;
                }
            },
            docTouchMove: function(e) {
                if (this.lastTouch) {
                    var touchPoint = e.originalEvent.touches[0];
                    this.lastTouch.x2 = touchPoint.pageX, this.lastTouch.y2 = touchPoint.pageY;
                }
            },
            docTouchStart: function(e) {
                var touchPoint = e.originalEvent.touches[0];
                this.lastTouch = {
                    x1: touchPoint.pageX,
                    y1: touchPoint.pageY,
                    target: touchPoint.target
                };
            },
            enable: function() {
                this.disabled && (this.$disableOverlay && (this.$disableOverlay.remove(), this.$disableOverlay = null), 
                this.disabled = !1);
            },
            getClosestMenu: function(elm) {
                for (var $closestMenu = $(elm).closest("ul"); $closestMenu.dataSM("in-mega"); ) $closestMenu = $closestMenu.parent().closest("ul");
                return $closestMenu[0] || null;
            },
            getHeight: function($elm) {
                return this.getOffset($elm, !0);
            },
            getOffset: function($elm, height) {
                var old;
                "none" == $elm.css("display") && (old = {
                    position: $elm[0].style.position,
                    visibility: $elm[0].style.visibility
                }, $elm.css({
                    position: "absolute",
                    visibility: "hidden"
                }).show());
                var box = $elm[0].getBoundingClientRect && $elm[0].getBoundingClientRect(), val = box && (height ? box.height || box.bottom - box.top : box.width || box.right - box.left);
                return val || 0 === val || (val = height ? $elm[0].offsetHeight : $elm[0].offsetWidth), 
                old && $elm.hide().css(old), val;
            },
            getStartZIndex: function(root) {
                var zIndex = parseInt(this[root ? "$root" : "$firstSub"].css("z-index"));
                return !root && isNaN(zIndex) && (zIndex = parseInt(this.$root.css("z-index"))), 
                isNaN(zIndex) ? 1 : zIndex;
            },
            getTouchPoint: function(e) {
                return e.touches && e.touches[0] || e.changedTouches && e.changedTouches[0] || e;
            },
            getViewport: function(height) {
                var name = height ? "Height" : "Width", val = document.documentElement["client" + name], val2 = window["inner" + name];
                return val2 && (val = Math.min(val, val2)), val;
            },
            getViewportHeight: function() {
                return this.getViewport(!0);
            },
            getViewportWidth: function() {
                return this.getViewport();
            },
            getWidth: function($elm) {
                return this.getOffset($elm);
            },
            handleEvents: function() {
                return !this.disabled && this.isCSSOn();
            },
            handleItemEvents: function($a) {
                return this.handleEvents() && !this.isLinkInMegaMenu($a);
            },
            isCollapsible: function() {
                return "static" == this.$firstSub.css("position");
            },
            isCSSOn: function() {
                return "block" == this.$firstLink.css("display");
            },
            isFixed: function() {
                var isFixed = "fixed" == this.$root.css("position");
                return isFixed || this.$root.parentsUntil("body").each(function() {
                    if ("fixed" == $(this).css("position")) return isFixed = !0, !1;
                }), isFixed;
            },
            isLinkInMegaMenu: function($a) {
                return !$a.parent().parent().dataSM("level");
            },
            isTouchMode: function() {
                return !mouse || this.isCollapsible();
            },
            itemActivate: function($a) {
                var $li = $a.parent(), $ul = $li.parent(), level = $ul.dataSM("level");
                if (level > 1 && (!this.activatedItems[level - 2] || this.activatedItems[level - 2][0] != $ul.dataSM("parent-a")[0])) {
                    var self = this;
                    $($ul.parentsUntil("[data-smartmenus-id]", "ul").get().reverse()).add($ul).each(function() {
                        self.itemActivate($(this).dataSM("parent-a"));
                    });
                }
                if (this.visibleSubMenus.length > level && this.menuHideSubMenus(this.activatedItems[level - 1] && this.activatedItems[level - 1][0] == $a[0] ? level : level - 1), 
                this.activatedItems[level - 1] = $a, this.visibleSubMenus[level - 1] = $ul, this.$root.triggerHandler("activate.smapi", $a[0]) !== !1) {
                    var $sub = $li.dataSM("sub");
                    $sub && (this.isTouchMode() || !this.opts.showOnClick || this.clickActivated) && this.menuShow($sub);
                }
            },
            itemBlur: function(e) {
                var $a = $(e.currentTarget);
                this.handleItemEvents($a) && this.$root.triggerHandler("blur.smapi", $a[0]);
            },
            itemClick: function(e) {
                if (this.isTouchScrolling) return this.isTouchScrolling = !1, e.stopPropagation(), 
                !1;
                var $a = $(e.currentTarget);
                if (this.handleItemEvents($a)) {
                    if ($a.removeDataSM("mousedown"), this.$root.triggerHandler("click.smapi", $a[0]) === !1) return !1;
                    var $sub = $a.parent().dataSM("sub");
                    if (this.isTouchMode()) {
                        if ($a.dataSM("href") && $a.attr("href", $a.dataSM("href")).removeDataSM("href"), 
                        $sub && (!$sub.dataSM("shown-before") || !$sub.is(":visible")) && (this.itemActivate($a), 
                        $sub.is(":visible"))) return !1;
                    } else if (this.opts.showOnClick && 1 == $a.parent().parent().dataSM("level") && $sub) return this.clickActivated = !0, 
                    this.menuShow($sub), !1;
                    return !$a.hasClass("disabled") && (this.$root.triggerHandler("select.smapi", $a[0]) !== !1 && void 0);
                }
            },
            itemDown: function(e) {
                var $a = $(e.currentTarget);
                this.handleItemEvents($a) && $a.dataSM("mousedown", !0);
            },
            itemEnter: function(e) {
                var $a = $(e.currentTarget);
                if (this.handleItemEvents($a)) {
                    if (!this.isTouchMode()) {
                        this.showTimeout && (clearTimeout(this.showTimeout), this.showTimeout = 0);
                        var self = this;
                        this.showTimeout = setTimeout(function() {
                            self.itemActivate($a);
                        }, this.opts.showOnClick && 1 == $a.parent().parent().dataSM("level") ? 1 : this.opts.showTimeout);
                    }
                    this.$root.triggerHandler("mouseenter.smapi", $a[0]);
                }
            },
            itemFocus: function(e) {
                var $a = $(e.currentTarget);
                this.handleItemEvents($a) && (this.isTouchMode() && $a.dataSM("mousedown") || this.activatedItems.length && this.activatedItems[this.activatedItems.length - 1][0] == $a[0] || this.itemActivate($a), 
                this.$root.triggerHandler("focus.smapi", $a[0]));
            },
            itemLeave: function(e) {
                var $a = $(e.currentTarget);
                this.handleItemEvents($a) && (this.isTouchMode() || ($a[0].blur && $a[0].blur(), 
                this.showTimeout && (clearTimeout(this.showTimeout), this.showTimeout = 0)), $a.removeDataSM("mousedown"), 
                this.$root.triggerHandler("mouseleave.smapi", $a[0]));
            },
            itemTouchEnd: function(e) {
                var $a = $(e.currentTarget);
                if (this.handleItemEvents($a)) {
                    var $sub = $a.parent().dataSM("sub");
                    "#" === $a.attr("href").charAt(0) || !$sub || $sub.dataSM("shown-before") && $sub.is(":visible") || ($a.dataSM("href", $a.attr("href")), 
                    $a.attr("href", "#"));
                }
            },
            menuFixLayout: function($ul) {
                $ul.dataSM("shown-before") || $ul.hide().dataSM("shown-before", !0);
            },
            menuHide: function($sub) {
                if (this.$root.triggerHandler("beforehide.smapi", $sub[0]) !== !1 && ($sub.stop(!0, !0), 
                $sub.is(":visible"))) {
                    var complete = function() {
                        $sub.css("z-index", "");
                    };
                    this.isCollapsible() ? this.opts.collapsibleHideFunction ? this.opts.collapsibleHideFunction.call(this, $sub, complete) : $sub.hide(this.opts.collapsibleHideDuration, complete) : this.opts.hideFunction ? this.opts.hideFunction.call(this, $sub, complete) : $sub.hide(this.opts.hideDuration, complete), 
                    $sub.dataSM("ie-shim") && $sub.dataSM("ie-shim").remove(), $sub.dataSM("scroll") && (this.menuScrollStop($sub), 
                    $sub.css({
                        "touch-action": "",
                        "-ms-touch-action": ""
                    }).unbind(".smartmenus_scroll").removeDataSM("scroll").dataSM("scroll-arrows").hide()), 
                    $sub.dataSM("parent-a").removeClass("highlighted");
                    var level = $sub.dataSM("level");
                    this.activatedItems.splice(level - 1, 1), this.visibleSubMenus.splice(level - 1, 1), 
                    this.$root.triggerHandler("hide.smapi", $sub[0]);
                }
            },
            menuHideAll: function() {
                this.showTimeout && (clearTimeout(this.showTimeout), this.showTimeout = 0), this.menuHideSubMenus(), 
                this.opts.isPopup && (this.$root.stop(!0, !0), this.$root.is(":visible") && (this.opts.hideFunction ? this.opts.hideFunction.call(this, this.$root) : this.$root.hide(this.opts.hideDuration), 
                this.$root.dataSM("ie-shim") && this.$root.dataSM("ie-shim").remove())), this.activatedItems = [], 
                this.visibleSubMenus = [], this.clickActivated = !1, this.zIndexInc = 0;
            },
            menuHideSubMenus: function(level) {
                level || (level = 0);
                for (var i = this.visibleSubMenus.length - 1; i > level; i--) this.menuHide(this.visibleSubMenus[i]);
            },
            menuIframeShim: function($ul) {
                IE && this.opts.overlapControlsInIE && !$ul.dataSM("ie-shim") && $ul.dataSM("ie-shim", $("<iframe/>").attr({
                    src: "javascript:0",
                    tabindex: -9
                }).css({
                    position: "absolute",
                    top: "auto",
                    left: "0",
                    opacity: 0,
                    border: "0"
                }));
            },
            menuInit: function($ul) {
                if (!$ul.dataSM("in-mega")) {
                    this.subMenus.push($ul), $ul.hasClass("mega-menu") && $ul.find("ul").dataSM("in-mega", !0);
                    for (var level = 2, par = $ul[0]; (par = par.parentNode.parentNode) != this.$root[0]; ) level++;
                    $ul.dataSM("parent-a", $ul.prevAll("a").eq(-1)).dataSM("level", level).parent().dataSM("sub", $ul), 
                    this.opts.subIndicators && $ul.dataSM("parent-a").addClass("has-submenu")[this.opts.subIndicatorsPos](this.$subArrow.clone());
                }
            },
            menuPosition: function($sub) {
                var x, y, $a = $sub.dataSM("parent-a"), $ul = $sub.parent().parent(), level = $sub.dataSM("level"), subW = this.getWidth($sub), subH = this.getHeight($sub), itemOffset = $a.offset(), itemX = itemOffset.left, itemY = itemOffset.top, itemW = this.getWidth($a), itemH = this.getHeight($a), $win = $(window), winX = $win.scrollLeft(), winY = $win.scrollTop(), winW = this.getViewportWidth(), winH = this.getViewportHeight(), horizontalParent = $ul.hasClass("sm") && !$ul.hasClass("sm-vertical"), subOffsetX = 2 == level ? this.opts.mainMenuSubOffsetX : this.opts.subMenusSubOffsetX, subOffsetY = 2 == level ? this.opts.mainMenuSubOffsetY : this.opts.subMenusSubOffsetY;
                if (horizontalParent ? (x = this.opts.rightToLeftSubMenus ? itemW - subW - subOffsetX : subOffsetX, 
                y = this.opts.bottomToTopSubMenus ? -subH - subOffsetY : itemH + subOffsetY) : (x = this.opts.rightToLeftSubMenus ? subOffsetX - subW : itemW - subOffsetX, 
                y = this.opts.bottomToTopSubMenus ? itemH - subOffsetY - subH : subOffsetY), this.opts.keepInViewport && !this.isCollapsible()) {
                    var absX = itemX + x, absY = itemY + y;
                    if (this.opts.rightToLeftSubMenus && absX < winX ? x = horizontalParent ? winX - absX + x : itemW - subOffsetX : !this.opts.rightToLeftSubMenus && absX + subW > winX + winW && (x = horizontalParent ? winX + winW - subW - absX + x : subOffsetX - subW), 
                    horizontalParent || (subH < winH && absY + subH > winY + winH ? y += winY + winH - subH - absY : (subH >= winH || absY < winY) && (y += winY - absY)), 
                    horizontalParent && (absY + subH > winY + winH + .49 || absY < winY) || !horizontalParent && subH > winH + .49) {
                        var self = this;
                        $sub.dataSM("scroll-arrows") || $sub.dataSM("scroll-arrows", $([ $('<span class="scroll-up"><span class="scroll-up-arrow"></span></span>')[0], $('<span class="scroll-down"><span class="scroll-down-arrow"></span></span>')[0] ]).bind({
                            mouseenter: function() {
                                $sub.dataSM("scroll").up = $(this).hasClass("scroll-up"), self.menuScroll($sub);
                            },
                            mouseleave: function(e) {
                                self.menuScrollStop($sub), self.menuScrollOut($sub, e);
                            },
                            "mousewheel DOMMouseScroll": function(e) {
                                e.preventDefault();
                            }
                        }).insertAfter($sub));
                        var eNS = ".smartmenus_scroll";
                        $sub.dataSM("scroll", {
                            step: 1,
                            itemH: itemH,
                            subH: subH,
                            arrowDownH: this.getHeight($sub.dataSM("scroll-arrows").eq(1))
                        }).bind(getEventsNS([ [ "mouseover", function(e) {
                            self.menuScrollOver($sub, e);
                        } ], [ "mouseout", function(e) {
                            self.menuScrollOut($sub, e);
                        } ], [ "mousewheel DOMMouseScroll", function(e) {
                            self.menuScrollMousewheel($sub, e);
                        } ] ], eNS)).dataSM("scroll-arrows").css({
                            top: "auto",
                            left: "0",
                            marginLeft: x + (parseInt($sub.css("border-left-width")) || 0),
                            width: subW - (parseInt($sub.css("border-left-width")) || 0) - (parseInt($sub.css("border-right-width")) || 0),
                            zIndex: $sub.css("z-index")
                        }).eq(horizontalParent && this.opts.bottomToTopSubMenus ? 0 : 1).show(), this.isFixed() && $sub.css({
                            "touch-action": "none",
                            "-ms-touch-action": "none"
                        }).bind(getEventsNS([ [ touchEvents() ? "touchstart touchmove touchend" : "pointerdown pointermove pointerup MSPointerDown MSPointerMove MSPointerUp", function(e) {
                            self.menuScrollTouch($sub, e);
                        } ] ], eNS));
                    }
                }
                $sub.css({
                    top: "auto",
                    left: "0",
                    marginLeft: x,
                    marginTop: y - itemH
                }), this.menuIframeShim($sub), $sub.dataSM("ie-shim") && $sub.dataSM("ie-shim").css({
                    zIndex: $sub.css("z-index"),
                    width: subW,
                    height: subH,
                    marginLeft: x,
                    marginTop: y - itemH
                });
            },
            menuScroll: function($sub, once, step) {
                var diff, data = $sub.dataSM("scroll"), $arrows = $sub.dataSM("scroll-arrows"), y = parseFloat($sub.css("margin-top")), end = data.up ? data.upEnd : data.downEnd;
                if (!once && data.velocity) {
                    if (data.velocity *= .9, diff = data.velocity, diff < .5) return void this.menuScrollStop($sub);
                } else diff = step || (once || !this.opts.scrollAccelerate ? this.opts.scrollStep : Math.floor(data.step));
                var level = $sub.dataSM("level");
                this.visibleSubMenus.length > level && this.menuHideSubMenus(level - 1);
                var newY = data.up && end <= y || !data.up && end >= y ? y : Math.abs(end - y) > diff ? y + (data.up ? diff : -diff) : end;
                if ($sub.add($sub.dataSM("ie-shim")).css("margin-top", newY), mouse && (data.up && newY > data.downEnd || !data.up && newY < data.upEnd) && $arrows.eq(data.up ? 1 : 0).show(), 
                newY == end) mouse && $arrows.eq(data.up ? 0 : 1).hide(), this.menuScrollStop($sub); else if (!once) {
                    this.opts.scrollAccelerate && data.step < this.opts.scrollStep && (data.step += .5);
                    var self = this;
                    this.scrollTimeout = setTimeout(function() {
                        self.menuScroll($sub);
                    }, this.opts.scrollInterval);
                }
            },
            menuScrollMousewheel: function($sub, e) {
                if (this.getClosestMenu(e.target) == $sub[0]) {
                    e = e.originalEvent;
                    var up = (e.wheelDelta || -e.detail) > 0;
                    $sub.dataSM("scroll-arrows").eq(up ? 0 : 1).is(":visible") && ($sub.dataSM("scroll").up = up, 
                    this.menuScroll($sub, !0));
                }
                e.preventDefault();
            },
            menuScrollOut: function($sub, e) {
                mouse && (/^scroll-(up|down)/.test((e.relatedTarget || "").className) || ($sub[0] == e.relatedTarget || $.contains($sub[0], e.relatedTarget)) && this.getClosestMenu(e.relatedTarget) == $sub[0] || $sub.dataSM("scroll-arrows").css("visibility", "hidden"));
            },
            menuScrollOver: function($sub, e) {
                if (mouse && !/^scroll-(up|down)/.test(e.target.className) && this.getClosestMenu(e.target) == $sub[0]) {
                    this.menuScrollRefreshData($sub);
                    var data = $sub.dataSM("scroll");
                    $sub.dataSM("scroll-arrows").eq(0).css("margin-top", data.upEnd).end().eq(1).css("margin-top", data.downEnd + data.subH - data.arrowDownH).end().css("visibility", "visible");
                }
            },
            menuScrollRefreshData: function($sub) {
                var data = $sub.dataSM("scroll"), $win = $(window), vportY = $win.scrollTop() - $sub.dataSM("parent-a").offset().top - data.itemH;
                $.extend(data, {
                    upEnd: vportY,
                    downEnd: vportY + this.getViewportHeight() - data.subH
                });
            },
            menuScrollStop: function($sub) {
                if (this.scrollTimeout) return clearTimeout(this.scrollTimeout), this.scrollTimeout = 0, 
                $.extend($sub.dataSM("scroll"), {
                    step: 1,
                    velocity: 0
                }), !0;
            },
            menuScrollTouch: function($sub, e) {
                if (e = e.originalEvent, isTouchEvent(e)) {
                    var touchPoint = this.getTouchPoint(e);
                    if (this.getClosestMenu(touchPoint.target) == $sub[0]) {
                        var data = $sub.dataSM("scroll");
                        if (/(start|down)$/i.test(e.type)) this.menuScrollStop($sub) ? (e.preventDefault(), 
                        this.isTouchScrolling = !0) : this.isTouchScrolling = !1, this.menuScrollRefreshData($sub), 
                        $.extend(data, {
                            touchY: touchPoint.pageY,
                            touchTimestamp: e.timeStamp,
                            velocity: 0
                        }); else if (/move$/i.test(e.type)) {
                            var prevY = data.touchY;
                            void 0 !== prevY && prevY != touchPoint.pageY && (this.isTouchScrolling = !0, $.extend(data, {
                                up: prevY < touchPoint.pageY,
                                touchY: touchPoint.pageY,
                                touchTimestamp: e.timeStamp,
                                velocity: data.velocity + .5 * Math.abs(touchPoint.pageY - prevY)
                            }), this.menuScroll($sub, !0, Math.abs(data.touchY - prevY))), e.preventDefault();
                        } else void 0 !== data.touchY && (e.timeStamp - data.touchTimestamp < 120 && data.velocity > 0 && (data.velocity *= .5, 
                        this.menuScrollStop($sub), this.menuScroll($sub), e.preventDefault()), delete data.touchY);
                    }
                }
            },
            menuShow: function($sub) {
                if (($sub.dataSM("beforefirstshowfired") || ($sub.dataSM("beforefirstshowfired", !0), 
                this.$root.triggerHandler("beforefirstshow.smapi", $sub[0]) !== !1)) && this.$root.triggerHandler("beforeshow.smapi", $sub[0]) !== !1 && (this.menuFixLayout($sub), 
                $sub.stop(!0, !0), !$sub.is(":visible"))) {
                    if ($sub.css("z-index", this.zIndexInc = (this.zIndexInc || this.getStartZIndex()) + 1), 
                    (this.opts.keepHighlighted || this.isCollapsible()) && $sub.dataSM("parent-a").addClass("highlighted"), 
                    (this.opts.subMenusMinWidth || this.opts.subMenusMaxWidth) && ($sub.css({
                        width: "auto",
                        minWidth: "",
                        maxWidth: ""
                    }).addClass("sm-nowrap"), this.opts.subMenusMinWidth && $sub.css("min-width", this.opts.subMenusMinWidth), 
                    this.opts.subMenusMaxWidth)) {
                        var noMaxWidth = this.getWidth($sub);
                        $sub.css("max-width", this.opts.subMenusMaxWidth), noMaxWidth > this.getWidth($sub) && $sub.removeClass("sm-nowrap").css("width", this.opts.subMenusMaxWidth);
                    }
                    this.menuPosition($sub), $sub.dataSM("ie-shim") && $sub.dataSM("ie-shim").insertBefore($sub);
                    var complete = function() {
                        $sub.css("overflow", "");
                    };
                    this.isCollapsible() ? this.opts.collapsibleShowFunction ? this.opts.collapsibleShowFunction.call(this, $sub, complete) : $sub.show(this.opts.collapsibleShowDuration, complete) : this.opts.showFunction ? this.opts.showFunction.call(this, $sub, complete) : $sub.show(this.opts.showDuration, complete), 
                    this.visibleSubMenus[$sub.dataSM("level") - 1] = $sub, this.$root.triggerHandler("show.smapi", $sub[0]);
                }
            },
            popupHide: function(noHideTimeout) {
                this.hideTimeout && (clearTimeout(this.hideTimeout), this.hideTimeout = 0);
                var self = this;
                this.hideTimeout = setTimeout(function() {
                    self.menuHideAll();
                }, noHideTimeout ? 1 : this.opts.hideTimeout);
            },
            popupShow: function(left, top) {
                if (!this.opts.isPopup) return void alert('SmartMenus jQuery Error:\n\nIf you want to show this menu via the "popupShow" method, set the isPopup:true option.');
                if (this.hideTimeout && (clearTimeout(this.hideTimeout), this.hideTimeout = 0), 
                this.menuFixLayout(this.$root), this.$root.stop(!0, !0), !this.$root.is(":visible")) {
                    this.$root.css({
                        left: left,
                        top: top
                    }), this.menuIframeShim(this.$root), this.$root.dataSM("ie-shim") && this.$root.dataSM("ie-shim").css({
                        zIndex: this.$root.css("z-index"),
                        width: this.getWidth(this.$root),
                        height: this.getHeight(this.$root),
                        left: left,
                        top: top
                    }).insertBefore(this.$root);
                    var self = this, complete = function() {
                        self.$root.css("overflow", "");
                    };
                    this.opts.showFunction ? this.opts.showFunction.call(this, this.$root, complete) : this.$root.show(this.opts.showDuration, complete), 
                    this.visibleSubMenus[0] = this.$root;
                }
            },
            refresh: function() {
                this.menuHideAll(), this.$root.find("ul").each(function() {
                    var $this = $(this);
                    $this.dataSM("scroll-arrows") && $this.dataSM("scroll-arrows").remove();
                }).removeDataSM("in-mega").removeDataSM("shown-before").removeDataSM("ie-shim").removeDataSM("scroll-arrows").removeDataSM("parent-a").removeDataSM("level").removeDataSM("beforefirstshowfired"), 
                this.$root.find("a.has-submenu").removeClass("has-submenu").parent().removeDataSM("sub"), 
                this.opts.subIndicators && this.$root.find("span.sub-arrow").remove(), this.opts.markCurrentItem && this.$root.find("a.current").removeClass("current"), 
                this.subMenus = [], this.init(!0);
            },
            rootOut: function(e) {
                if (this.handleEvents() && !this.isTouchMode() && e.target != this.$root[0] && (this.hideTimeout && (clearTimeout(this.hideTimeout), 
                this.hideTimeout = 0), !this.opts.showOnClick || !this.opts.hideOnClick)) {
                    var self = this;
                    this.hideTimeout = setTimeout(function() {
                        self.menuHideAll();
                    }, this.opts.hideTimeout);
                }
            },
            rootOver: function(e) {
                this.handleEvents() && !this.isTouchMode() && e.target != this.$root[0] && this.hideTimeout && (clearTimeout(this.hideTimeout), 
                this.hideTimeout = 0);
            },
            winResize: function(e) {
                if (this.handleEvents()) this.isCollapsible() || "onorientationchange" in window && "orientationchange" != e.type || (this.activatedItems.length && this.activatedItems[this.activatedItems.length - 1][0].blur(), 
                this.menuHideAll()); else if (this.$disableOverlay) {
                    var pos = this.$root.offset();
                    this.$disableOverlay.css({
                        top: pos.top,
                        left: pos.left,
                        width: this.$root.outerWidth(),
                        height: this.$root.outerHeight()
                    });
                }
            }
        }
    }), $.fn.dataSM = function(key, val) {
        return val ? this.data(key + "_smartmenus", val) : this.data(key + "_smartmenus");
    }, $.fn.removeDataSM = function(key) {
        return this.removeData(key + "_smartmenus");
    }, $.fn.smartmenus = function(options) {
        if ("string" == typeof options) {
            var args = arguments, method = options;
            return Array.prototype.shift.call(args), this.each(function() {
                var smartmenus = $(this).data("smartmenus");
                smartmenus && smartmenus[method] && smartmenus[method].apply(smartmenus, args);
            });
        }
        var opts = $.extend({}, $.fn.smartmenus.defaults, options);
        return this.each(function() {
            new $.SmartMenus(this, opts);
        });
    }, $.fn.smartmenus.defaults = {
        isPopup: !1,
        mainMenuSubOffsetX: 0,
        mainMenuSubOffsetY: 0,
        subMenusSubOffsetX: 0,
        subMenusSubOffsetY: 0,
        subMenusMinWidth: "10em",
        subMenusMaxWidth: "20em",
        subIndicators: !0,
        subIndicatorsPos: "prepend",
        subIndicatorsText: "+",
        scrollStep: 30,
        scrollInterval: 30,
        scrollAccelerate: !0,
        showTimeout: 250,
        hideTimeout: 500,
        showDuration: 0,
        showFunction: null,
        hideDuration: 0,
        hideFunction: function($ul, complete) {
            $ul.fadeOut(200, complete);
        },
        collapsibleShowDuration: 0,
        collapsibleShowFunction: function($ul, complete) {
            $ul.slideDown(200, complete);
        },
        collapsibleHideDuration: 0,
        collapsibleHideFunction: function($ul, complete) {
            $ul.slideUp(200, complete);
        },
        showOnClick: !1,
        hideOnClick: !0,
        keepInViewport: !0,
        keepHighlighted: !0,
        markCurrentItem: !1,
        markCurrentTree: !0,
        rightToLeftSubMenus: !1,
        bottomToTopSubMenus: !1,
        overlapControlsInIE: !0
    };
}(jQuery), function($) {
    $(function() {
        $("ul.navbar-nav").each(function() {
            var $this = $(this);
            $this.addClass("sm").smartmenus({
                subMenusSubOffsetX: 2,
                subMenusSubOffsetY: -6,
                subIndicatorsPos: "append",
                subIndicatorsText: "...",
                collapsibleShowFunction: null,
                collapsibleHideFunction: null,
                rightToLeftSubMenus: $this.hasClass("navbar-right"),
                bottomToTopSubMenus: $this.closest(".navbar").hasClass("navbar-fixed-bottom"),
                hideOnClick: !1
            }).find("a.current").parent().addClass("active");
        }).bind({
            "show.smapi": function(e, menu) {
                var $menu = $(menu), $scrollArrows = $menu.dataSM("scroll-arrows"), obj = $(this).data("smartmenus");
                $scrollArrows && $scrollArrows.css("background-color", $(document.body).css("background-color")), 
                $menu.parent().addClass("open" + (obj.isCollapsible() ? " collapsible" : ""));
            },
            "hide.smapi": function(e, menu) {
                $(menu).parent().removeClass("open collapsible");
            },
            "click.smapi": function(e, item) {
                var obj = $(this).data("smartmenus");
                if (obj.isCollapsible()) {
                    var $item = $(item), $sub = $item.parent().dataSM("sub");
                    if ($sub && $sub.dataSM("shown-before") && $sub.is(":visible")) return obj.itemActivate($item), 
                    obj.menuHide($sub), !1;
                }
            }
        });
    }), $.SmartMenus.prototype.isCollapsible = function() {
        return "left" != this.$firstLink.parent().css("float");
    };
}(jQuery), function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery" ], factory) : "object" == typeof module && module.exports ? module.exports = factory(require("jquery")) : factory(jQuery);
}(function($) {
    $.extend($.fn, {
        validate: function(options) {
            if (!this.length) return void (options && options.debug && window.console && console.warn("Nothing selected, can't validate, returning nothing."));
            var validator = $.data(this[0], "validator");
            return validator ? validator : (this.attr("novalidate", "novalidate"), validator = new $.validator(options, this[0]), 
            $.data(this[0], "validator", validator), validator.settings.onsubmit && (this.on("click.validate", ":submit", function(event) {
                validator.settings.submitHandler && (validator.submitButton = event.target), $(this).hasClass("cancel") && (validator.cancelSubmit = !0), 
                void 0 !== $(this).attr("formnovalidate") && (validator.cancelSubmit = !0);
            }), this.on("submit.validate", function(event) {
                function handle() {
                    var hidden, result;
                    return !validator.settings.submitHandler || (validator.submitButton && (hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val($(validator.submitButton).val()).appendTo(validator.currentForm)), 
                    result = validator.settings.submitHandler.call(validator, validator.currentForm, event), 
                    validator.submitButton && hidden.remove(), void 0 !== result && result);
                }
                return validator.settings.debug && event.preventDefault(), validator.cancelSubmit ? (validator.cancelSubmit = !1, 
                handle()) : validator.form() ? validator.pendingRequest ? (validator.formSubmitted = !0, 
                !1) : handle() : (validator.focusInvalid(), !1);
            })), validator);
        },
        valid: function() {
            var valid, validator, errorList;
            return $(this[0]).is("form") ? valid = this.validate().form() : (errorList = [], 
            valid = !0, validator = $(this[0].form).validate(), this.each(function() {
                valid = validator.element(this) && valid, valid || (errorList = errorList.concat(validator.errorList));
            }), validator.errorList = errorList), valid;
        },
        rules: function(command, argument) {
            var settings, staticRules, existingRules, data, param, filtered, element = this[0];
            if (null != element && null != element.form) {
                if (command) switch (settings = $.data(element.form, "validator").settings, staticRules = settings.rules, 
                existingRules = $.validator.staticRules(element), command) {
                  case "add":
                    $.extend(existingRules, $.validator.normalizeRule(argument)), delete existingRules.messages, 
                    staticRules[element.name] = existingRules, argument.messages && (settings.messages[element.name] = $.extend(settings.messages[element.name], argument.messages));
                    break;

                  case "remove":
                    return argument ? (filtered = {}, $.each(argument.split(/\s/), function(index, method) {
                        filtered[method] = existingRules[method], delete existingRules[method], "required" === method && $(element).removeAttr("aria-required");
                    }), filtered) : (delete staticRules[element.name], existingRules);
                }
                return data = $.validator.normalizeRules($.extend({}, $.validator.classRules(element), $.validator.attributeRules(element), $.validator.dataRules(element), $.validator.staticRules(element)), element), 
                data.required && (param = data.required, delete data.required, data = $.extend({
                    required: param
                }, data), $(element).attr("aria-required", "true")), data.remote && (param = data.remote, 
                delete data.remote, data = $.extend(data, {
                    remote: param
                })), data;
            }
        }
    }), $.extend($.expr.pseudos || $.expr[":"], {
        blank: function(a) {
            return !$.trim("" + $(a).val());
        },
        filled: function(a) {
            var val = $(a).val();
            return null !== val && !!$.trim("" + val);
        },
        unchecked: function(a) {
            return !$(a).prop("checked");
        }
    }), $.validator = function(options, form) {
        this.settings = $.extend(!0, {}, $.validator.defaults, options), this.currentForm = form, 
        this.init();
    }, $.validator.format = function(source, params) {
        return 1 === arguments.length ? function() {
            var args = $.makeArray(arguments);
            return args.unshift(source), $.validator.format.apply(this, args);
        } : void 0 === params ? source : (arguments.length > 2 && params.constructor !== Array && (params = $.makeArray(arguments).slice(1)), 
        params.constructor !== Array && (params = [ params ]), $.each(params, function(i, n) {
            source = source.replace(new RegExp("\\{" + i + "\\}", "g"), function() {
                return n;
            });
        }), source);
    }, $.extend($.validator, {
        defaults: {
            messages: {},
            groups: {},
            rules: {},
            errorClass: "error",
            pendingClass: "pending",
            validClass: "valid",
            errorElement: "label",
            focusCleanup: !1,
            focusInvalid: !0,
            errorContainer: $([]),
            errorLabelContainer: $([]),
            onsubmit: !0,
            ignore: ":hidden",
            ignoreTitle: !1,
            onfocusin: function(element) {
                this.lastActive = element, this.settings.focusCleanup && (this.settings.unhighlight && this.settings.unhighlight.call(this, element, this.settings.errorClass, this.settings.validClass), 
                this.hideThese(this.errorsFor(element)));
            },
            onfocusout: function(element) {
                this.checkable(element) || !(element.name in this.submitted) && this.optional(element) || this.element(element);
            },
            onkeyup: function(element, event) {
                var excludedKeys = [ 16, 17, 18, 20, 35, 36, 37, 38, 39, 40, 45, 144, 225 ];
                9 === event.which && "" === this.elementValue(element) || $.inArray(event.keyCode, excludedKeys) !== -1 || (element.name in this.submitted || element.name in this.invalid) && this.element(element);
            },
            onclick: function(element) {
                element.name in this.submitted ? this.element(element) : element.parentNode.name in this.submitted && this.element(element.parentNode);
            },
            highlight: function(element, errorClass, validClass) {
                "radio" === element.type ? this.findByName(element.name).addClass(errorClass).removeClass(validClass) : $(element).addClass(errorClass).removeClass(validClass);
            },
            unhighlight: function(element, errorClass, validClass) {
                "radio" === element.type ? this.findByName(element.name).removeClass(errorClass).addClass(validClass) : $(element).removeClass(errorClass).addClass(validClass);
            }
        },
        setDefaults: function(settings) {
            $.extend($.validator.defaults, settings);
        },
        messages: {
            required: "This field is required.",
            remote: "Please fix this field.",
            email: "Please enter a valid email address.",
            url: "Please enter a valid URL.",
            date: "Please enter a valid date.",
            dateISO: "Please enter a valid date (ISO).",
            number: "Please enter a valid number.",
            digits: "Please enter only digits.",
            equalTo: "Please enter the same value again.",
            maxlength: $.validator.format("Please enter no more than {0} characters."),
            minlength: $.validator.format("Please enter at least {0} characters."),
            rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
            range: $.validator.format("Please enter a value between {0} and {1}."),
            max: $.validator.format("Please enter a value less than or equal to {0}."),
            min: $.validator.format("Please enter a value greater than or equal to {0}."),
            step: $.validator.format("Please enter a multiple of {0}.")
        },
        autoCreateRanges: !1,
        prototype: {
            init: function() {
                function delegate(event) {
                    !this.form && this.hasAttribute("contenteditable") && (this.form = $(this).closest("form")[0]);
                    var validator = $.data(this.form, "validator"), eventType = "on" + event.type.replace(/^validate/, ""), settings = validator.settings;
                    settings[eventType] && !$(this).is(settings.ignore) && settings[eventType].call(validator, this, event);
                }
                this.labelContainer = $(this.settings.errorLabelContainer), this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm), 
                this.containers = $(this.settings.errorContainer).add(this.settings.errorLabelContainer), 
                this.submitted = {}, this.valueCache = {}, this.pendingRequest = 0, this.pending = {}, 
                this.invalid = {}, this.reset();
                var rules, groups = this.groups = {};
                $.each(this.settings.groups, function(key, value) {
                    "string" == typeof value && (value = value.split(/\s/)), $.each(value, function(index, name) {
                        groups[name] = key;
                    });
                }), rules = this.settings.rules, $.each(rules, function(key, value) {
                    rules[key] = $.validator.normalizeRule(value);
                }), $(this.currentForm).on("focusin.validate focusout.validate keyup.validate", ":text, [type='password'], [type='file'], select, textarea, [type='number'], [type='search'], [type='tel'], [type='url'], [type='email'], [type='datetime'], [type='date'], [type='month'], [type='week'], [type='time'], [type='datetime-local'], [type='range'], [type='color'], [type='radio'], [type='checkbox'], [contenteditable], [type='button']", delegate).on("click.validate", "select, option, [type='radio'], [type='checkbox']", delegate), 
                this.settings.invalidHandler && $(this.currentForm).on("invalid-form.validate", this.settings.invalidHandler), 
                $(this.currentForm).find("[required], [data-rule-required], .required").attr("aria-required", "true");
            },
            form: function() {
                return this.checkForm(), $.extend(this.submitted, this.errorMap), this.invalid = $.extend({}, this.errorMap), 
                this.valid() || $(this.currentForm).triggerHandler("invalid-form", [ this ]), this.showErrors(), 
                this.valid();
            },
            checkForm: function() {
                this.prepareForm();
                for (var i = 0, elements = this.currentElements = this.elements(); elements[i]; i++) this.check(elements[i]);
                return this.valid();
            },
            element: function(element) {
                var rs, group, cleanElement = this.clean(element), checkElement = this.validationTargetFor(cleanElement), v = this, result = !0;
                return void 0 === checkElement ? delete this.invalid[cleanElement.name] : (this.prepareElement(checkElement), 
                this.currentElements = $(checkElement), group = this.groups[checkElement.name], 
                group && $.each(this.groups, function(name, testgroup) {
                    testgroup === group && name !== checkElement.name && (cleanElement = v.validationTargetFor(v.clean(v.findByName(name))), 
                    cleanElement && cleanElement.name in v.invalid && (v.currentElements.push(cleanElement), 
                    result = v.check(cleanElement) && result));
                }), rs = this.check(checkElement) !== !1, result = result && rs, rs ? this.invalid[checkElement.name] = !1 : this.invalid[checkElement.name] = !0, 
                this.numberOfInvalids() || (this.toHide = this.toHide.add(this.containers)), this.showErrors(), 
                $(element).attr("aria-invalid", !rs)), result;
            },
            showErrors: function(errors) {
                if (errors) {
                    var validator = this;
                    $.extend(this.errorMap, errors), this.errorList = $.map(this.errorMap, function(message, name) {
                        return {
                            message: message,
                            element: validator.findByName(name)[0]
                        };
                    }), this.successList = $.grep(this.successList, function(element) {
                        return !(element.name in errors);
                    });
                }
                this.settings.showErrors ? this.settings.showErrors.call(this, this.errorMap, this.errorList) : this.defaultShowErrors();
            },
            resetForm: function() {
                $.fn.resetForm && $(this.currentForm).resetForm(), this.invalid = {}, this.submitted = {}, 
                this.prepareForm(), this.hideErrors();
                var elements = this.elements().removeData("previousValue").removeAttr("aria-invalid");
                this.resetElements(elements);
            },
            resetElements: function(elements) {
                var i;
                if (this.settings.unhighlight) for (i = 0; elements[i]; i++) this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, ""), 
                this.findByName(elements[i].name).removeClass(this.settings.validClass); else elements.removeClass(this.settings.errorClass).removeClass(this.settings.validClass);
            },
            numberOfInvalids: function() {
                return this.objectLength(this.invalid);
            },
            objectLength: function(obj) {
                var i, count = 0;
                for (i in obj) obj[i] && count++;
                return count;
            },
            hideErrors: function() {
                this.hideThese(this.toHide);
            },
            hideThese: function(errors) {
                errors.not(this.containers).text(""), this.addWrapper(errors).hide();
            },
            valid: function() {
                return 0 === this.size();
            },
            size: function() {
                return this.errorList.length;
            },
            focusInvalid: function() {
                if (this.settings.focusInvalid) try {
                    $(this.findLastActive() || this.errorList.length && this.errorList[0].element || []).filter(":visible").focus().trigger("focusin");
                } catch (e) {}
            },
            findLastActive: function() {
                var lastActive = this.lastActive;
                return lastActive && 1 === $.grep(this.errorList, function(n) {
                    return n.element.name === lastActive.name;
                }).length && lastActive;
            },
            elements: function() {
                var validator = this, rulesCache = {};
                return $(this.currentForm).find("input, select, textarea, [contenteditable]").not(":submit, :reset, :image, :disabled").not(this.settings.ignore).filter(function() {
                    var name = this.name || $(this).attr("name");
                    return !name && validator.settings.debug && window.console && console.error("%o has no name assigned", this), 
                    this.hasAttribute("contenteditable") && (this.form = $(this).closest("form")[0]), 
                    !(name in rulesCache || !validator.objectLength($(this).rules())) && (rulesCache[name] = !0, 
                    !0);
                });
            },
            clean: function(selector) {
                return $(selector)[0];
            },
            errors: function() {
                var errorClass = this.settings.errorClass.split(" ").join(".");
                return $(this.settings.errorElement + "." + errorClass, this.errorContext);
            },
            resetInternals: function() {
                this.successList = [], this.errorList = [], this.errorMap = {}, this.toShow = $([]), 
                this.toHide = $([]);
            },
            reset: function() {
                this.resetInternals(), this.currentElements = $([]);
            },
            prepareForm: function() {
                this.reset(), this.toHide = this.errors().add(this.containers);
            },
            prepareElement: function(element) {
                this.reset(), this.toHide = this.errorsFor(element);
            },
            elementValue: function(element) {
                var val, idx, $element = $(element), type = element.type;
                return "radio" === type || "checkbox" === type ? this.findByName(element.name).filter(":checked").val() : "number" === type && "undefined" != typeof element.validity ? element.validity.badInput ? "NaN" : $element.val() : (val = element.hasAttribute("contenteditable") ? $element.text() : $element.val(), 
                "file" === type ? "C:\\fakepath\\" === val.substr(0, 12) ? val.substr(12) : (idx = val.lastIndexOf("/"), 
                idx >= 0 ? val.substr(idx + 1) : (idx = val.lastIndexOf("\\"), idx >= 0 ? val.substr(idx + 1) : val)) : "string" == typeof val ? val.replace(/\r/g, "") : val);
            },
            check: function(element) {
                element = this.validationTargetFor(this.clean(element));
                var result, method, rule, rules = $(element).rules(), rulesCount = $.map(rules, function(n, i) {
                    return i;
                }).length, dependencyMismatch = !1, val = this.elementValue(element);
                if ("function" == typeof rules.normalizer) {
                    if (val = rules.normalizer.call(element, val), "string" != typeof val) throw new TypeError("The normalizer should return a string value.");
                    delete rules.normalizer;
                }
                for (method in rules) {
                    rule = {
                        method: method,
                        parameters: rules[method]
                    };
                    try {
                        if (result = $.validator.methods[method].call(this, val, element, rule.parameters), 
                        "dependency-mismatch" === result && 1 === rulesCount) {
                            dependencyMismatch = !0;
                            continue;
                        }
                        if (dependencyMismatch = !1, "pending" === result) return void (this.toHide = this.toHide.not(this.errorsFor(element)));
                        if (!result) return this.formatAndAdd(element, rule), !1;
                    } catch (e) {
                        throw this.settings.debug && window.console && console.log("Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e), 
                        e instanceof TypeError && (e.message += ".  Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method."), 
                        e;
                    }
                }
                if (!dependencyMismatch) return this.objectLength(rules) && this.successList.push(element), 
                !0;
            },
            customDataMessage: function(element, method) {
                return $(element).data("msg" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase()) || $(element).data("msg");
            },
            customMessage: function(name, method) {
                var m = this.settings.messages[name];
                return m && (m.constructor === String ? m : m[method]);
            },
            findDefined: function() {
                for (var i = 0; i < arguments.length; i++) if (void 0 !== arguments[i]) return arguments[i];
            },
            defaultMessage: function(element, rule) {
                "string" == typeof rule && (rule = {
                    method: rule
                });
                var message = this.findDefined(this.customMessage(element.name, rule.method), this.customDataMessage(element, rule.method), !this.settings.ignoreTitle && element.title || void 0, $.validator.messages[rule.method], "<strong>Warning: No message defined for " + element.name + "</strong>"), theregex = /\$?\{(\d+)\}/g;
                return "function" == typeof message ? message = message.call(this, rule.parameters, element) : theregex.test(message) && (message = $.validator.format(message.replace(theregex, "{$1}"), rule.parameters)), 
                message;
            },
            formatAndAdd: function(element, rule) {
                var message = this.defaultMessage(element, rule);
                this.errorList.push({
                    message: message,
                    element: element,
                    method: rule.method
                }), this.errorMap[element.name] = message, this.submitted[element.name] = message;
            },
            addWrapper: function(toToggle) {
                return this.settings.wrapper && (toToggle = toToggle.add(toToggle.parent(this.settings.wrapper))), 
                toToggle;
            },
            defaultShowErrors: function() {
                var i, elements, error;
                for (i = 0; this.errorList[i]; i++) error = this.errorList[i], this.settings.highlight && this.settings.highlight.call(this, error.element, this.settings.errorClass, this.settings.validClass), 
                this.showLabel(error.element, error.message);
                if (this.errorList.length && (this.toShow = this.toShow.add(this.containers)), this.settings.success) for (i = 0; this.successList[i]; i++) this.showLabel(this.successList[i]);
                if (this.settings.unhighlight) for (i = 0, elements = this.validElements(); elements[i]; i++) this.settings.unhighlight.call(this, elements[i], this.settings.errorClass, this.settings.validClass);
                this.toHide = this.toHide.not(this.toShow), this.hideErrors(), this.addWrapper(this.toShow).show();
            },
            validElements: function() {
                return this.currentElements.not(this.invalidElements());
            },
            invalidElements: function() {
                return $(this.errorList).map(function() {
                    return this.element;
                });
            },
            showLabel: function(element, message) {
                var place, group, errorID, v, error = this.errorsFor(element), elementID = this.idOrName(element), describedBy = $(element).attr("aria-describedby");
                error.length ? (error.removeClass(this.settings.validClass).addClass(this.settings.errorClass), 
                error.html(message)) : (error = $("<" + this.settings.errorElement + ">").attr("id", elementID + "-error").addClass(this.settings.errorClass).html(message || ""), 
                place = error, this.settings.wrapper && (place = error.hide().show().wrap("<" + this.settings.wrapper + "/>").parent()), 
                this.labelContainer.length ? this.labelContainer.append(place) : this.settings.errorPlacement ? this.settings.errorPlacement.call(this, place, $(element)) : place.insertAfter(element), 
                error.is("label") ? error.attr("for", elementID) : 0 === error.parents("label[for='" + this.escapeCssMeta(elementID) + "']").length && (errorID = error.attr("id"), 
                describedBy ? describedBy.match(new RegExp("\\b" + this.escapeCssMeta(errorID) + "\\b")) || (describedBy += " " + errorID) : describedBy = errorID, 
                $(element).attr("aria-describedby", describedBy), group = this.groups[element.name], 
                group && (v = this, $.each(v.groups, function(name, testgroup) {
                    testgroup === group && $("[name='" + v.escapeCssMeta(name) + "']", v.currentForm).attr("aria-describedby", error.attr("id"));
                })))), !message && this.settings.success && (error.text(""), "string" == typeof this.settings.success ? error.addClass(this.settings.success) : this.settings.success(error, element)), 
                this.toShow = this.toShow.add(error);
            },
            errorsFor: function(element) {
                var name = this.escapeCssMeta(this.idOrName(element)), describer = $(element).attr("aria-describedby"), selector = "label[for='" + name + "'], label[for='" + name + "'] *";
                return describer && (selector = selector + ", #" + this.escapeCssMeta(describer).replace(/\s+/g, ", #")), 
                this.errors().filter(selector);
            },
            escapeCssMeta: function(string) {
                return string.replace(/([\\!"#$%&'()*+,.\/:;<=>?@\[\]^`{|}~])/g, "\\$1");
            },
            idOrName: function(element) {
                return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
            },
            validationTargetFor: function(element) {
                return this.checkable(element) && (element = this.findByName(element.name)), $(element).not(this.settings.ignore)[0];
            },
            checkable: function(element) {
                return /radio|checkbox/i.test(element.type);
            },
            findByName: function(name) {
                return $(this.currentForm).find("[name='" + this.escapeCssMeta(name) + "']");
            },
            getLength: function(value, element) {
                switch (element.nodeName.toLowerCase()) {
                  case "select":
                    return $("option:selected", element).length;

                  case "input":
                    if (this.checkable(element)) return this.findByName(element.name).filter(":checked").length;
                }
                return value.length;
            },
            depend: function(param, element) {
                return !this.dependTypes[typeof param] || this.dependTypes[typeof param](param, element);
            },
            dependTypes: {
                boolean: function(param) {
                    return param;
                },
                string: function(param, element) {
                    return !!$(param, element.form).length;
                },
                function: function(param, element) {
                    return param(element);
                }
            },
            optional: function(element) {
                var val = this.elementValue(element);
                return !$.validator.methods.required.call(this, val, element) && "dependency-mismatch";
            },
            startRequest: function(element) {
                this.pending[element.name] || (this.pendingRequest++, $(element).addClass(this.settings.pendingClass), 
                this.pending[element.name] = !0);
            },
            stopRequest: function(element, valid) {
                this.pendingRequest--, this.pendingRequest < 0 && (this.pendingRequest = 0), delete this.pending[element.name], 
                $(element).removeClass(this.settings.pendingClass), valid && 0 === this.pendingRequest && this.formSubmitted && this.form() ? ($(this.currentForm).submit(), 
                this.formSubmitted = !1) : !valid && 0 === this.pendingRequest && this.formSubmitted && ($(this.currentForm).triggerHandler("invalid-form", [ this ]), 
                this.formSubmitted = !1);
            },
            previousValue: function(element, method) {
                return method = "string" == typeof method && method || "remote", $.data(element, "previousValue") || $.data(element, "previousValue", {
                    old: null,
                    valid: !0,
                    message: this.defaultMessage(element, {
                        method: method
                    })
                });
            },
            destroy: function() {
                this.resetForm(), $(this.currentForm).off(".validate").removeData("validator").find(".validate-equalTo-blur").off(".validate-equalTo").removeClass("validate-equalTo-blur");
            }
        },
        classRuleSettings: {
            required: {
                required: !0
            },
            email: {
                email: !0
            },
            url: {
                url: !0
            },
            date: {
                date: !0
            },
            dateISO: {
                dateISO: !0
            },
            number: {
                number: !0
            },
            digits: {
                digits: !0
            },
            creditcard: {
                creditcard: !0
            }
        },
        addClassRules: function(className, rules) {
            className.constructor === String ? this.classRuleSettings[className] = rules : $.extend(this.classRuleSettings, className);
        },
        classRules: function(element) {
            var rules = {}, classes = $(element).attr("class");
            return classes && $.each(classes.split(" "), function() {
                this in $.validator.classRuleSettings && $.extend(rules, $.validator.classRuleSettings[this]);
            }), rules;
        },
        normalizeAttributeRule: function(rules, type, method, value) {
            /min|max|step/.test(method) && (null === type || /number|range|text/.test(type)) && (value = Number(value), 
            isNaN(value) && (value = void 0)), value || 0 === value ? rules[method] = value : type === method && "range" !== type && (rules[method] = !0);
        },
        attributeRules: function(element) {
            var method, value, rules = {}, $element = $(element), type = element.getAttribute("type");
            for (method in $.validator.methods) "required" === method ? (value = element.getAttribute(method), 
            "" === value && (value = !0), value = !!value) : value = $element.attr(method), 
            this.normalizeAttributeRule(rules, type, method, value);
            return rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength) && delete rules.maxlength, 
            rules;
        },
        dataRules: function(element) {
            var method, value, rules = {}, $element = $(element), type = element.getAttribute("type");
            for (method in $.validator.methods) value = $element.data("rule" + method.charAt(0).toUpperCase() + method.substring(1).toLowerCase()), 
            this.normalizeAttributeRule(rules, type, method, value);
            return rules;
        },
        staticRules: function(element) {
            var rules = {}, validator = $.data(element.form, "validator");
            return validator.settings.rules && (rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {}), 
            rules;
        },
        normalizeRules: function(rules, element) {
            return $.each(rules, function(prop, val) {
                if (val === !1) return void delete rules[prop];
                if (val.param || val.depends) {
                    var keepRule = !0;
                    switch (typeof val.depends) {
                      case "string":
                        keepRule = !!$(val.depends, element.form).length;
                        break;

                      case "function":
                        keepRule = val.depends.call(element, element);
                    }
                    keepRule ? rules[prop] = void 0 === val.param || val.param : ($.data(element.form, "validator").resetElements($(element)), 
                    delete rules[prop]);
                }
            }), $.each(rules, function(rule, parameter) {
                rules[rule] = $.isFunction(parameter) && "normalizer" !== rule ? parameter(element) : parameter;
            }), $.each([ "minlength", "maxlength" ], function() {
                rules[this] && (rules[this] = Number(rules[this]));
            }), $.each([ "rangelength", "range" ], function() {
                var parts;
                rules[this] && ($.isArray(rules[this]) ? rules[this] = [ Number(rules[this][0]), Number(rules[this][1]) ] : "string" == typeof rules[this] && (parts = rules[this].replace(/[\[\]]/g, "").split(/[\s,]+/), 
                rules[this] = [ Number(parts[0]), Number(parts[1]) ]));
            }), $.validator.autoCreateRanges && (null != rules.min && null != rules.max && (rules.range = [ rules.min, rules.max ], 
            delete rules.min, delete rules.max), null != rules.minlength && null != rules.maxlength && (rules.rangelength = [ rules.minlength, rules.maxlength ], 
            delete rules.minlength, delete rules.maxlength)), rules;
        },
        normalizeRule: function(data) {
            if ("string" == typeof data) {
                var transformed = {};
                $.each(data.split(/\s/), function() {
                    transformed[this] = !0;
                }), data = transformed;
            }
            return data;
        },
        addMethod: function(name, method, message) {
            $.validator.methods[name] = method, $.validator.messages[name] = void 0 !== message ? message : $.validator.messages[name], 
            method.length < 3 && $.validator.addClassRules(name, $.validator.normalizeRule(name));
        },
        methods: {
            required: function(value, element, param) {
                if (!this.depend(param, element)) return "dependency-mismatch";
                if ("select" === element.nodeName.toLowerCase()) {
                    var val = $(element).val();
                    return val && val.length > 0;
                }
                return this.checkable(element) ? this.getLength(value, element) > 0 : value.length > 0;
            },
            email: function(value, element) {
                return this.optional(element) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test(value);
            },
            url: function(value, element) {
                return this.optional(element) || /^(?:(?:(?:https?|ftp):)?\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})).?)(?::\d{2,5})?(?:[\/?#]\S*)?$/i.test(value);
            },
            date: function(value, element) {
                return this.optional(element) || !/Invalid|NaN/.test(new Date(value).toString());
            },
            dateISO: function(value, element) {
                return this.optional(element) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test(value);
            },
            number: function(value, element) {
                return this.optional(element) || /^(?:-?\d+|-?\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value);
            },
            digits: function(value, element) {
                return this.optional(element) || /^\d+$/.test(value);
            },
            minlength: function(value, element, param) {
                var length = $.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || length >= param;
            },
            maxlength: function(value, element, param) {
                var length = $.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || length <= param;
            },
            rangelength: function(value, element, param) {
                var length = $.isArray(value) ? value.length : this.getLength(value, element);
                return this.optional(element) || length >= param[0] && length <= param[1];
            },
            min: function(value, element, param) {
                return this.optional(element) || value >= param;
            },
            max: function(value, element, param) {
                return this.optional(element) || value <= param;
            },
            range: function(value, element, param) {
                return this.optional(element) || value >= param[0] && value <= param[1];
            },
            step: function(value, element, param) {
                var decimals, type = $(element).attr("type"), errorMessage = "Step attribute on input type " + type + " is not supported.", supportedTypes = [ "text", "number", "range" ], re = new RegExp("\\b" + type + "\\b"), notSupported = type && !re.test(supportedTypes.join()), decimalPlaces = function(num) {
                    var match = ("" + num).match(/(?:\.(\d+))?$/);
                    return match && match[1] ? match[1].length : 0;
                }, toInt = function(num) {
                    return Math.round(num * Math.pow(10, decimals));
                }, valid = !0;
                if (notSupported) throw new Error(errorMessage);
                return decimals = decimalPlaces(param), (decimalPlaces(value) > decimals || toInt(value) % toInt(param) !== 0) && (valid = !1), 
                this.optional(element) || valid;
            },
            equalTo: function(value, element, param) {
                var target = $(param);
                return this.settings.onfocusout && target.not(".validate-equalTo-blur").length && target.addClass("validate-equalTo-blur").on("blur.validate-equalTo", function() {
                    $(element).valid();
                }), value === target.val();
            },
            remote: function(value, element, param, method) {
                if (this.optional(element)) return "dependency-mismatch";
                method = "string" == typeof method && method || "remote";
                var validator, data, optionDataString, previous = this.previousValue(element, method);
                return this.settings.messages[element.name] || (this.settings.messages[element.name] = {}), 
                previous.originalMessage = previous.originalMessage || this.settings.messages[element.name][method], 
                this.settings.messages[element.name][method] = previous.message, param = "string" == typeof param && {
                    url: param
                } || param, optionDataString = $.param($.extend({
                    data: value
                }, param.data)), previous.old === optionDataString ? previous.valid : (previous.old = optionDataString, 
                validator = this, this.startRequest(element), data = {}, data[element.name] = value, 
                $.ajax($.extend(!0, {
                    mode: "abort",
                    port: "validate" + element.name,
                    dataType: "json",
                    data: data,
                    context: validator.currentForm,
                    success: function(response) {
                        var errors, message, submitted, valid = response === !0 || "true" === response;
                        validator.settings.messages[element.name][method] = previous.originalMessage, valid ? (submitted = validator.formSubmitted, 
                        validator.resetInternals(), validator.toHide = validator.errorsFor(element), validator.formSubmitted = submitted, 
                        validator.successList.push(element), validator.invalid[element.name] = !1, validator.showErrors()) : (errors = {}, 
                        message = response || validator.defaultMessage(element, {
                            method: method,
                            parameters: value
                        }), errors[element.name] = previous.message = message, validator.invalid[element.name] = !0, 
                        validator.showErrors(errors)), previous.valid = valid, validator.stopRequest(element, valid);
                    }
                }, param)), "pending");
            }
        }
    });
    var ajax, pendingRequests = {};
    return $.ajaxPrefilter ? $.ajaxPrefilter(function(settings, _, xhr) {
        var port = settings.port;
        "abort" === settings.mode && (pendingRequests[port] && pendingRequests[port].abort(), 
        pendingRequests[port] = xhr);
    }) : (ajax = $.ajax, $.ajax = function(settings) {
        var mode = ("mode" in settings ? settings : $.ajaxSettings).mode, port = ("port" in settings ? settings : $.ajaxSettings).port;
        return "abort" === mode ? (pendingRequests[port] && pendingRequests[port].abort(), 
        pendingRequests[port] = ajax.apply(this, arguments), pendingRequests[port]) : ajax.apply(this, arguments);
    }), $;
}), function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery", "./jquery.validate" ], factory) : "object" == typeof module && module.exports ? module.exports = factory(require("jquery")) : factory(jQuery);
}(function($) {
    return function() {
        function stripHtml(value) {
            return value.replace(/<.[^<>]*?>/g, " ").replace(/&nbsp;|&#160;/gi, " ").replace(/[.(),;:!?%#$'\"_+=\/\-]*/g, "");
        }
        $.validator.addMethod("maxWords", function(value, element, params) {
            return this.optional(element) || stripHtml(value).match(/\b\w+\b/g).length <= params;
        }, $.validator.format("Please enter {0} words or less.")), $.validator.addMethod("minWords", function(value, element, params) {
            return this.optional(element) || stripHtml(value).match(/\b\w+\b/g).length >= params;
        }, $.validator.format("Please enter at least {0} words.")), $.validator.addMethod("rangeWords", function(value, element, params) {
            var valueStripped = stripHtml(value), regex = /\b\w+\b/g;
            return this.optional(element) || valueStripped.match(regex).length >= params[0] && valueStripped.match(regex).length <= params[1];
        }, $.validator.format("Please enter between {0} and {1} words."));
    }(), $.validator.addMethod("accept", function(value, element, param) {
        var i, file, regex, typeParam = "string" == typeof param ? param.replace(/\s/g, "") : "image/*", optionalValue = this.optional(element);
        if (optionalValue) return optionalValue;
        if ("file" === $(element).attr("type") && (typeParam = typeParam.replace(/[\-\[\]\/\{\}\(\)\+\?\.\\\^\$\|]/g, "\\$&").replace(/,/g, "|").replace(/\/\*/g, "/.*"), 
        element.files && element.files.length)) for (regex = new RegExp(".?(" + typeParam + ")$", "i"), 
        i = 0; i < element.files.length; i++) if (file = element.files[i], !file.type.match(regex)) return !1;
        return !0;
    }, $.validator.format("Please enter a value with a valid mimetype.")), $.validator.addMethod("alphanumeric", function(value, element) {
        return this.optional(element) || /^\w+$/i.test(value);
    }, "Letters, numbers, and underscores only please"), $.validator.addMethod("bankaccountNL", function(value, element) {
        if (this.optional(element)) return !0;
        if (!/^[0-9]{9}|([0-9]{2} ){3}[0-9]{3}$/.test(value)) return !1;
        var pos, factor, digit, account = value.replace(/ /g, ""), sum = 0, len = account.length;
        for (pos = 0; pos < len; pos++) factor = len - pos, digit = account.substring(pos, pos + 1), 
        sum += factor * digit;
        return sum % 11 === 0;
    }, "Please specify a valid bank account number"), $.validator.addMethod("bankorgiroaccountNL", function(value, element) {
        return this.optional(element) || $.validator.methods.bankaccountNL.call(this, value, element) || $.validator.methods.giroaccountNL.call(this, value, element);
    }, "Please specify a valid bank or giro account number"), $.validator.addMethod("bic", function(value, element) {
        return this.optional(element) || /^([A-Z]{6}[A-Z2-9][A-NP-Z1-9])(X{3}|[A-WY-Z0-9][A-Z0-9]{2})?$/.test(value.toUpperCase());
    }, "Please specify a valid BIC code"), $.validator.addMethod("cifES", function(value) {
        "use strict";
        function isOdd(n) {
            return n % 2 === 0;
        }
        var i, n, control_digit, control_letter, cifRegEx = new RegExp(/^([ABCDEFGHJKLMNPQRSUVW])(\d{7})([0-9A-J])$/gi), letter = value.substring(0, 1), number = value.substring(1, 8), control = value.substring(8, 9), all_sum = 0, even_sum = 0, odd_sum = 0;
        if (9 !== value.length || !cifRegEx.test(value)) return !1;
        for (i = 0; i < number.length; i++) n = parseInt(number[i], 10), isOdd(i) ? (n *= 2, 
        odd_sum += n < 10 ? n : n - 9) : even_sum += n;
        return all_sum = even_sum + odd_sum, control_digit = (10 - all_sum.toString().substr(-1)).toString(), 
        control_digit = parseInt(control_digit, 10) > 9 ? "0" : control_digit, control_letter = "JABCDEFGHI".substr(control_digit, 1).toString(), 
        letter.match(/[ABEH]/) ? control === control_digit : letter.match(/[KPQS]/) ? control === control_letter : control === control_digit || control === control_letter;
    }, "Please specify a valid CIF number."), $.validator.addMethod("cpfBR", function(value) {
        if (value = value.replace(/([~!@#$%^&*()_+=`{}\[\]\-|\\:;'<>,.\/? ])+/g, ""), 11 !== value.length) return !1;
        var firstCN, secondCN, checkResult, i, sum = 0;
        if (firstCN = parseInt(value.substring(9, 10), 10), secondCN = parseInt(value.substring(10, 11), 10), 
        checkResult = function(sum, cn) {
            var result = 10 * sum % 11;
            return 10 !== result && 11 !== result || (result = 0), result === cn;
        }, "" === value || "00000000000" === value || "11111111111" === value || "22222222222" === value || "33333333333" === value || "44444444444" === value || "55555555555" === value || "66666666666" === value || "77777777777" === value || "88888888888" === value || "99999999999" === value) return !1;
        for (i = 1; i <= 9; i++) sum += parseInt(value.substring(i - 1, i), 10) * (11 - i);
        if (checkResult(sum, firstCN)) {
            for (sum = 0, i = 1; i <= 10; i++) sum += parseInt(value.substring(i - 1, i), 10) * (12 - i);
            return checkResult(sum, secondCN);
        }
        return !1;
    }, "Please specify a valid CPF number"), $.validator.addMethod("creditcard", function(value, element) {
        if (this.optional(element)) return "dependency-mismatch";
        if (/[^0-9 \-]+/.test(value)) return !1;
        var n, cDigit, nCheck = 0, nDigit = 0, bEven = !1;
        if (value = value.replace(/\D/g, ""), value.length < 13 || value.length > 19) return !1;
        for (n = value.length - 1; n >= 0; n--) cDigit = value.charAt(n), nDigit = parseInt(cDigit, 10), 
        bEven && (nDigit *= 2) > 9 && (nDigit -= 9), nCheck += nDigit, bEven = !bEven;
        return nCheck % 10 === 0;
    }, "Please enter a valid credit card number."), $.validator.addMethod("creditcardtypes", function(value, element, param) {
        if (/[^0-9\-]+/.test(value)) return !1;
        value = value.replace(/\D/g, "");
        var validTypes = 0;
        return param.mastercard && (validTypes |= 1), param.visa && (validTypes |= 2), param.amex && (validTypes |= 4), 
        param.dinersclub && (validTypes |= 8), param.enroute && (validTypes |= 16), param.discover && (validTypes |= 32), 
        param.jcb && (validTypes |= 64), param.unknown && (validTypes |= 128), param.all && (validTypes = 255), 
        1 & validTypes && /^(5[12345])/.test(value) ? 16 === value.length : 2 & validTypes && /^(4)/.test(value) ? 16 === value.length : 4 & validTypes && /^(3[47])/.test(value) ? 15 === value.length : 8 & validTypes && /^(3(0[012345]|[68]))/.test(value) ? 14 === value.length : 16 & validTypes && /^(2(014|149))/.test(value) ? 15 === value.length : 32 & validTypes && /^(6011)/.test(value) ? 16 === value.length : 64 & validTypes && /^(3)/.test(value) ? 16 === value.length : 64 & validTypes && /^(2131|1800)/.test(value) ? 15 === value.length : !!(128 & validTypes);
    }, "Please enter a valid credit card number."), $.validator.addMethod("currency", function(value, element, param) {
        var regex, isParamString = "string" == typeof param, symbol = isParamString ? param : param[0], soft = !!isParamString || param[1];
        return symbol = symbol.replace(/,/g, ""), symbol = soft ? symbol + "]" : symbol + "]?", 
        regex = "^[" + symbol + "([1-9]{1}[0-9]{0,2}(\\,[0-9]{3})*(\\.[0-9]{0,2})?|[1-9]{1}[0-9]{0,}(\\.[0-9]{0,2})?|0(\\.[0-9]{0,2})?|(\\.[0-9]{1,2})?)$", 
        regex = new RegExp(regex), this.optional(element) || regex.test(value);
    }, "Please specify a valid currency"), $.validator.addMethod("dateFA", function(value, element) {
        return this.optional(element) || /^[1-4]\d{3}\/((0?[1-6]\/((3[0-1])|([1-2][0-9])|(0?[1-9])))|((1[0-2]|(0?[7-9]))\/(30|([1-2][0-9])|(0?[1-9]))))$/.test(value);
    }, $.validator.messages.date), $.validator.addMethod("dateITA", function(value, element) {
        var adata, gg, mm, aaaa, xdata, check = !1, re = /^\d{1,2}\/\d{1,2}\/\d{4}$/;
        return re.test(value) ? (adata = value.split("/"), gg = parseInt(adata[0], 10), 
        mm = parseInt(adata[1], 10), aaaa = parseInt(adata[2], 10), xdata = new Date(Date.UTC(aaaa, mm - 1, gg, 12, 0, 0, 0)), 
        check = xdata.getUTCFullYear() === aaaa && xdata.getUTCMonth() === mm - 1 && xdata.getUTCDate() === gg) : check = !1, 
        this.optional(element) || check;
    }, $.validator.messages.date), $.validator.addMethod("dateNL", function(value, element) {
        return this.optional(element) || /^(0?[1-9]|[12]\d|3[01])[\.\/\-](0?[1-9]|1[012])[\.\/\-]([12]\d)?(\d\d)$/.test(value);
    }, $.validator.messages.date), $.validator.addMethod("extension", function(value, element, param) {
        return param = "string" == typeof param ? param.replace(/,/g, "|") : "png|jpe?g|gif", 
        this.optional(element) || value.match(new RegExp("\\.(" + param + ")$", "i"));
    }, $.validator.format("Please enter a value with a valid extension.")), $.validator.addMethod("giroaccountNL", function(value, element) {
        return this.optional(element) || /^[0-9]{1,7}$/.test(value);
    }, "Please specify a valid giro account number"), $.validator.addMethod("iban", function(value, element) {
        if (this.optional(element)) return !0;
        var countrycode, ibancheck, charAt, cChar, bbanpattern, bbancountrypatterns, ibanregexp, i, p, iban = value.replace(/ /g, "").toUpperCase(), ibancheckdigits = "", leadingZeroes = !0, cRest = "", cOperator = "", minimalIBANlength = 5;
        if (iban.length < minimalIBANlength) return !1;
        if (countrycode = iban.substring(0, 2), bbancountrypatterns = {
            AL: "\\d{8}[\\dA-Z]{16}",
            AD: "\\d{8}[\\dA-Z]{12}",
            AT: "\\d{16}",
            AZ: "[\\dA-Z]{4}\\d{20}",
            BE: "\\d{12}",
            BH: "[A-Z]{4}[\\dA-Z]{14}",
            BA: "\\d{16}",
            BR: "\\d{23}[A-Z][\\dA-Z]",
            BG: "[A-Z]{4}\\d{6}[\\dA-Z]{8}",
            CR: "\\d{17}",
            HR: "\\d{17}",
            CY: "\\d{8}[\\dA-Z]{16}",
            CZ: "\\d{20}",
            DK: "\\d{14}",
            DO: "[A-Z]{4}\\d{20}",
            EE: "\\d{16}",
            FO: "\\d{14}",
            FI: "\\d{14}",
            FR: "\\d{10}[\\dA-Z]{11}\\d{2}",
            GE: "[\\dA-Z]{2}\\d{16}",
            DE: "\\d{18}",
            GI: "[A-Z]{4}[\\dA-Z]{15}",
            GR: "\\d{7}[\\dA-Z]{16}",
            GL: "\\d{14}",
            GT: "[\\dA-Z]{4}[\\dA-Z]{20}",
            HU: "\\d{24}",
            IS: "\\d{22}",
            IE: "[\\dA-Z]{4}\\d{14}",
            IL: "\\d{19}",
            IT: "[A-Z]\\d{10}[\\dA-Z]{12}",
            KZ: "\\d{3}[\\dA-Z]{13}",
            KW: "[A-Z]{4}[\\dA-Z]{22}",
            LV: "[A-Z]{4}[\\dA-Z]{13}",
            LB: "\\d{4}[\\dA-Z]{20}",
            LI: "\\d{5}[\\dA-Z]{12}",
            LT: "\\d{16}",
            LU: "\\d{3}[\\dA-Z]{13}",
            MK: "\\d{3}[\\dA-Z]{10}\\d{2}",
            MT: "[A-Z]{4}\\d{5}[\\dA-Z]{18}",
            MR: "\\d{23}",
            MU: "[A-Z]{4}\\d{19}[A-Z]{3}",
            MC: "\\d{10}[\\dA-Z]{11}\\d{2}",
            MD: "[\\dA-Z]{2}\\d{18}",
            ME: "\\d{18}",
            NL: "[A-Z]{4}\\d{10}",
            NO: "\\d{11}",
            PK: "[\\dA-Z]{4}\\d{16}",
            PS: "[\\dA-Z]{4}\\d{21}",
            PL: "\\d{24}",
            PT: "\\d{21}",
            RO: "[A-Z]{4}[\\dA-Z]{16}",
            SM: "[A-Z]\\d{10}[\\dA-Z]{12}",
            SA: "\\d{2}[\\dA-Z]{18}",
            RS: "\\d{18}",
            SK: "\\d{20}",
            SI: "\\d{15}",
            ES: "\\d{20}",
            SE: "\\d{20}",
            CH: "\\d{5}[\\dA-Z]{12}",
            TN: "\\d{20}",
            TR: "\\d{5}[\\dA-Z]{17}",
            AE: "\\d{3}\\d{16}",
            GB: "[A-Z]{4}\\d{14}",
            VG: "[\\dA-Z]{4}\\d{16}"
        }, bbanpattern = bbancountrypatterns[countrycode], "undefined" != typeof bbanpattern && (ibanregexp = new RegExp("^[A-Z]{2}\\d{2}" + bbanpattern + "$", ""), 
        !ibanregexp.test(iban))) return !1;
        for (ibancheck = iban.substring(4, iban.length) + iban.substring(0, 4), i = 0; i < ibancheck.length; i++) charAt = ibancheck.charAt(i), 
        "0" !== charAt && (leadingZeroes = !1), leadingZeroes || (ibancheckdigits += "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ".indexOf(charAt));
        for (p = 0; p < ibancheckdigits.length; p++) cChar = ibancheckdigits.charAt(p), 
        cOperator = "" + cRest + cChar, cRest = cOperator % 97;
        return 1 === cRest;
    }, "Please specify a valid IBAN"), $.validator.addMethod("integer", function(value, element) {
        return this.optional(element) || /^-?\d+$/.test(value);
    }, "A positive or negative non-decimal number please"), $.validator.addMethod("ipv4", function(value, element) {
        return this.optional(element) || /^(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)$/i.test(value);
    }, "Please enter a valid IP v4 address."), $.validator.addMethod("ipv6", function(value, element) {
        return this.optional(element) || /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test(value);
    }, "Please enter a valid IP v6 address."), $.validator.addMethod("lettersonly", function(value, element) {
        return this.optional(element) || /^[a-z]+$/i.test(value);
    }, "Letters only please"), $.validator.addMethod("letterswithbasicpunc", function(value, element) {
        return this.optional(element) || /^[a-z\-.,()'"\s]+$/i.test(value);
    }, "Letters or punctuation only please"), $.validator.addMethod("mobileNL", function(value, element) {
        return this.optional(element) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)6((\s|\s?\-\s?)?[0-9]){8}$/.test(value);
    }, "Please specify a valid mobile number"), $.validator.addMethod("mobileUK", function(phone_number, element) {
        return phone_number = phone_number.replace(/\(|\)|\s+|-/g, ""), this.optional(element) || phone_number.length > 9 && phone_number.match(/^(?:(?:(?:00\s?|\+)44\s?|0)7(?:[1345789]\d{2}|624)\s?\d{3}\s?\d{3})$/);
    }, "Please specify a valid mobile number"), $.validator.addMethod("nieES", function(value) {
        "use strict";
        var number, nieRegEx = new RegExp(/^[MXYZ]{1}[0-9]{7,8}[TRWAGMYFPDXBNJZSQVHLCKET]{1}$/gi), validChars = "TRWAGMYFPDXBNJZSQVHLCKET", letter = value.substr(value.length - 1).toUpperCase();
        return value = value.toString().toUpperCase(), !(value.length > 10 || value.length < 9 || !nieRegEx.test(value)) && (value = value.replace(/^[X]/, "0").replace(/^[Y]/, "1").replace(/^[Z]/, "2"), 
        number = 9 === value.length ? value.substr(0, 8) : value.substr(0, 9), validChars.charAt(parseInt(number, 10) % 23) === letter);
    }, "Please specify a valid NIE number."), $.validator.addMethod("nifES", function(value) {
        "use strict";
        return value = value.toUpperCase(), !!value.match("((^[A-Z]{1}[0-9]{7}[A-Z0-9]{1}$|^[T]{1}[A-Z0-9]{8}$)|^[0-9]{8}[A-Z]{1}$)") && (/^[0-9]{8}[A-Z]{1}$/.test(value) ? "TRWAGMYFPDXBNJZSQVHLCKE".charAt(value.substring(8, 0) % 23) === value.charAt(8) : !!/^[KLM]{1}/.test(value) && value[8] === String.fromCharCode(64));
    }, "Please specify a valid NIF number."), $.validator.addMethod("notEqualTo", function(value, element, param) {
        return this.optional(element) || !$.validator.methods.equalTo.call(this, value, element, param);
    }, "Please enter a different value, values must not be the same."), $.validator.addMethod("nowhitespace", function(value, element) {
        return this.optional(element) || /^\S+$/i.test(value);
    }, "No white space please"), $.validator.addMethod("pattern", function(value, element, param) {
        return !!this.optional(element) || ("string" == typeof param && (param = new RegExp("^(?:" + param + ")$")), 
        param.test(value));
    }, "Invalid format."), $.validator.addMethod("phoneNL", function(value, element) {
        return this.optional(element) || /^((\+|00(\s|\s?\-\s?)?)31(\s|\s?\-\s?)?(\(0\)[\-\s]?)?|0)[1-9]((\s|\s?\-\s?)?[0-9]){8}$/.test(value);
    }, "Please specify a valid phone number."), $.validator.addMethod("phoneUK", function(phone_number, element) {
        return phone_number = phone_number.replace(/\(|\)|\s+|-/g, ""), this.optional(element) || phone_number.length > 9 && phone_number.match(/^(?:(?:(?:00\s?|\+)44\s?)|(?:\(?0))(?:\d{2}\)?\s?\d{4}\s?\d{4}|\d{3}\)?\s?\d{3}\s?\d{3,4}|\d{4}\)?\s?(?:\d{5}|\d{3}\s?\d{3})|\d{5}\)?\s?\d{4,5})$/);
    }, "Please specify a valid phone number"), $.validator.addMethod("phoneUS", function(phone_number, element) {
        return phone_number = phone_number.replace(/\s+/g, ""), this.optional(element) || phone_number.length > 9 && phone_number.match(/^(\+?1-?)?(\([2-9]([02-9]\d|1[02-9])\)|[2-9]([02-9]\d|1[02-9]))-?[2-9]([02-9]\d|1[02-9])-?\d{4}$/);
    }, "Please specify a valid phone number"), $.validator.addMethod("phonesUK", function(phone_number, element) {
        return phone_number = phone_number.replace(/\(|\)|\s+|-/g, ""), this.optional(element) || phone_number.length > 9 && phone_number.match(/^(?:(?:(?:00\s?|\+)44\s?|0)(?:1\d{8,9}|[23]\d{9}|7(?:[1345789]\d{8}|624\d{6})))$/);
    }, "Please specify a valid uk phone number"), $.validator.addMethod("postalCodeCA", function(value, element) {
        return this.optional(element) || /^[ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ] *\d[ABCEGHJKLMNPRSTVWXYZ]\d$/i.test(value);
    }, "Please specify a valid postal code"), $.validator.addMethod("postalcodeBR", function(cep_value, element) {
        return this.optional(element) || /^\d{2}.\d{3}-\d{3}?$|^\d{5}-?\d{3}?$/.test(cep_value);
    }, "Informe um CEP vlido."), $.validator.addMethod("postalcodeIT", function(value, element) {
        return this.optional(element) || /^\d{5}$/.test(value);
    }, "Please specify a valid postal code"), $.validator.addMethod("postalcodeNL", function(value, element) {
        return this.optional(element) || /^[1-9][0-9]{3}\s?[a-zA-Z]{2}$/.test(value);
    }, "Please specify a valid postal code"), $.validator.addMethod("postcodeUK", function(value, element) {
        return this.optional(element) || /^((([A-PR-UWYZ][0-9])|([A-PR-UWYZ][0-9][0-9])|([A-PR-UWYZ][A-HK-Y][0-9])|([A-PR-UWYZ][A-HK-Y][0-9][0-9])|([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))\s?([0-9][ABD-HJLNP-UW-Z]{2})|(GIR)\s?(0AA))$/i.test(value);
    }, "Please specify a valid UK postcode"), $.validator.addMethod("require_from_group", function(value, element, options) {
        var $fields = $(options[1], element.form), $fieldsFirst = $fields.eq(0), validator = $fieldsFirst.data("valid_req_grp") ? $fieldsFirst.data("valid_req_grp") : $.extend({}, this), isValid = $fields.filter(function() {
            return validator.elementValue(this);
        }).length >= options[0];
        return $fieldsFirst.data("valid_req_grp", validator), $(element).data("being_validated") || ($fields.data("being_validated", !0), 
        $fields.each(function() {
            validator.element(this);
        }), $fields.data("being_validated", !1)), isValid;
    }, $.validator.format("Please fill at least {0} of these fields.")), $.validator.addMethod("skip_or_fill_minimum", function(value, element, options) {
        var $fields = $(options[1], element.form), $fieldsFirst = $fields.eq(0), validator = $fieldsFirst.data("valid_skip") ? $fieldsFirst.data("valid_skip") : $.extend({}, this), numberFilled = $fields.filter(function() {
            return validator.elementValue(this);
        }).length, isValid = 0 === numberFilled || numberFilled >= options[0];
        return $fieldsFirst.data("valid_skip", validator), $(element).data("being_validated") || ($fields.data("being_validated", !0), 
        $fields.each(function() {
            validator.element(this);
        }), $fields.data("being_validated", !1)), isValid;
    }, $.validator.format("Please either skip these fields or fill at least {0} of them.")), 
    $.validator.addMethod("stateUS", function(value, element, options) {
        var regex, isDefault = "undefined" == typeof options, caseSensitive = !isDefault && "undefined" != typeof options.caseSensitive && options.caseSensitive, includeTerritories = !isDefault && "undefined" != typeof options.includeTerritories && options.includeTerritories, includeMilitary = !isDefault && "undefined" != typeof options.includeMilitary && options.includeMilitary;
        return regex = includeTerritories || includeMilitary ? includeTerritories && includeMilitary ? "^(A[AEKLPRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$" : includeTerritories ? "^(A[KLRSZ]|C[AOT]|D[CE]|FL|G[AU]|HI|I[ADLN]|K[SY]|LA|M[ADEINOPST]|N[CDEHJMVY]|O[HKR]|P[AR]|RI|S[CD]|T[NX]|UT|V[AIT]|W[AIVY])$" : "^(A[AEKLPRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$" : "^(A[KLRZ]|C[AOT]|D[CE]|FL|GA|HI|I[ADLN]|K[SY]|LA|M[ADEINOST]|N[CDEHJMVY]|O[HKR]|PA|RI|S[CD]|T[NX]|UT|V[AT]|W[AIVY])$", 
        regex = caseSensitive ? new RegExp(regex) : new RegExp(regex, "i"), this.optional(element) || regex.test(value);
    }, "Please specify a valid state"), $.validator.addMethod("strippedminlength", function(value, element, param) {
        return $(value).text().length >= param;
    }, $.validator.format("Please enter at least {0} characters")), $.validator.addMethod("time", function(value, element) {
        return this.optional(element) || /^([01]\d|2[0-3]|[0-9])(:[0-5]\d){1,2}$/.test(value);
    }, "Please enter a valid time, between 00:00 and 23:59"), $.validator.addMethod("time12h", function(value, element) {
        return this.optional(element) || /^((0?[1-9]|1[012])(:[0-5]\d){1,2}(\ ?[AP]M))$/i.test(value);
    }, "Please enter a valid time in 12-hour am/pm format"), $.validator.addMethod("url2", function(value, element) {
        return this.optional(element) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)*(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
    }, $.validator.messages.url), $.validator.addMethod("vinUS", function(v) {
        if (17 !== v.length) return !1;
        var i, n, d, f, cd, cdv, LL = [ "A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" ], VL = [ 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 7, 9, 2, 3, 4, 5, 6, 7, 8, 9 ], FL = [ 8, 7, 6, 5, 4, 3, 2, 10, 0, 9, 8, 7, 6, 5, 4, 3, 2 ], rs = 0;
        for (i = 0; i < 17; i++) {
            if (f = FL[i], d = v.slice(i, i + 1), 8 === i && (cdv = d), isNaN(d)) {
                for (n = 0; n < LL.length; n++) if (d.toUpperCase() === LL[n]) {
                    d = VL[n], d *= f, isNaN(cdv) && 8 === n && (cdv = LL[n]);
                    break;
                }
            } else d *= f;
            rs += d;
        }
        return cd = rs % 11, 10 === cd && (cd = "X"), cd === cdv;
    }, "The specified vehicle identification number (VIN) is invalid."), $.validator.addMethod("zipcodeUS", function(value, element) {
        return this.optional(element) || /^\d{5}(-\d{4})?$/.test(value);
    }, "The specified US ZIP Code is invalid"), $.validator.addMethod("ziprange", function(value, element) {
        return this.optional(element) || /^90[2-5]\d\{2\}-\d{4}$/.test(value);
    }, "Your ZIP-code must be in the range 902xx-xxxx to 905xx-xxxx"), $;
}), !function($, window, document) {
    "use strict";
    function Timepicker(element, options) {
        this.$element = $(element), this.defaultTime = options.defaultTime, this.disableFocus = options.disableFocus, 
        this.minuteStep = options.minuteStep, this.secondStep = options.secondStep, this.showMeridian = options.showMeridian, 
        this.showSeconds = options.showSeconds, this.$element.on({
            "focus.timepicker": $.proxy(this.highlightUnit, this),
            "click.timepicker": $.proxy(this.highlightUnit, this),
            "keydown.timepicker": $.proxy(this.elementKeydown, this),
            "blur.timepicker": $.proxy(this.blurElement, this),
            "mousewheel.timepicker DOMMouseScroll.timepicker": $.proxy(this.mousewheel, this)
        }), this.setDefaultTime(this.defaultTime);
    }
    Timepicker.prototype = {
        constructor: Timepicker,
        blurElement: function() {
            this.highlightedUnit = null, this.updateFromElementVal();
        },
        clear: function() {
            this.hour = "", this.minute = "", this.second = "", this.meridian = "", this.$element.val("");
        },
        decrementHour: function() {
            var hour = this.hour;
            return this.showMeridian ? 1 === hour ? void (this.hour = 12) : 12 === hour || 0 === hour ? (this.hour = 11, 
            void this.toggleMeridian()) : void this.hour-- : 0 >= hour ? void (this.hour = 23) : void this.hour--;
        },
        decrementMinute: function(step) {
            var newVal = this.minute - (step || this.minuteStep);
            0 > newVal ? (this.decrementHour(), this.minute = newVal + 60) : this.minute = newVal;
        },
        decrementSecond: function() {
            var newVal = this.second - this.secondStep;
            0 > newVal ? (this.decrementMinute(1), this.second = newVal + 60) : this.second = newVal;
        },
        elementKeydown: function(e) {
            switch (e.keyCode) {
              case 9:
              case 27:
                this.updateFromElementVal();
                break;

              case 37:
                e.preventDefault(), this.highlightPrevUnit();
                break;

              case 38:
                switch (e.preventDefault(), this.highlightedUnit) {
                  case "hour":
                    this.incrementHour(), this.highlightHour();
                    break;

                  case "minute":
                    this.incrementMinute(), this.highlightMinute();
                    break;

                  case "second":
                    this.incrementSecond(), this.highlightSecond();
                    break;

                  case "meridian":
                    this.toggleMeridian(), this.highlightMeridian();
                }
                this.update();
                break;

              case 39:
                e.preventDefault(), this.highlightNextUnit();
                break;

              case 40:
                switch (e.preventDefault(), this.highlightedUnit) {
                  case "hour":
                    this.decrementHour(), this.highlightHour();
                    break;

                  case "minute":
                    this.decrementMinute(), this.highlightMinute();
                    break;

                  case "second":
                    this.decrementSecond(), this.highlightSecond();
                    break;

                  case "meridian":
                    this.toggleMeridian(), this.highlightMeridian();
                }
                this.update();
            }
        },
        getCursorPosition: function() {
            var input = this.$element.get(0);
            if ("selectionStart" in input) return input.selectionStart;
            if (document.selection) {
                input.focus();
                var sel = document.selection.createRange(), selLen = document.selection.createRange().text.length;
                return sel.moveStart("character", -input.value.length), sel.text.length - selLen;
            }
        },
        getTime: function() {
            return "" === this.hour ? "" : this.hour + ":" + (1 === this.minute.toString().length ? "0" + this.minute : this.minute) + (this.showSeconds ? ":" + (1 === this.second.toString().length ? "0" + this.second : this.second) : "") + (this.showMeridian ? " " + this.meridian : "");
        },
        highlightUnit: function() {
            this.position = this.getCursorPosition(), this.position >= 0 && this.position <= 2 ? this.highlightHour() : this.position >= 3 && this.position <= 5 ? this.highlightMinute() : this.position >= 6 && this.position <= 8 ? this.showSeconds ? this.highlightSecond() : this.highlightMeridian() : this.position >= 9 && this.position <= 11 && this.highlightMeridian();
        },
        highlightNextUnit: function() {
            switch (this.highlightedUnit) {
              case "hour":
                this.highlightMinute();
                break;

              case "minute":
                this.showSeconds ? this.highlightSecond() : this.showMeridian ? this.highlightMeridian() : this.highlightHour();
                break;

              case "second":
                this.showMeridian ? this.highlightMeridian() : this.highlightHour();
                break;

              case "meridian":
                this.highlightHour();
            }
        },
        highlightPrevUnit: function() {
            switch (this.highlightedUnit) {
              case "hour":
                this.showMeridian ? this.highlightMeridian() : this.showSeconds ? this.highlightSecond() : this.highlightMinute();
                break;

              case "minute":
                this.highlightHour();
                break;

              case "second":
                this.highlightMinute();
                break;

              case "meridian":
                this.showSeconds ? this.highlightSecond() : this.highlightMinute();
            }
        },
        highlightHour: function() {
            var $element = this.$element.get(0), self = this;
            this.highlightedUnit = "hour", $element.setSelectionRange && setTimeout(function() {
                self.hour < 10 ? $element.setSelectionRange(0, 1) : $element.setSelectionRange(0, 2);
            }, 0);
        },
        highlightMinute: function() {
            var $element = this.$element.get(0), self = this;
            this.highlightedUnit = "minute", $element.setSelectionRange && setTimeout(function() {
                self.hour < 10 ? $element.setSelectionRange(2, 4) : $element.setSelectionRange(3, 5);
            }, 0);
        },
        highlightSecond: function() {
            var $element = this.$element.get(0), self = this;
            this.highlightedUnit = "second", $element.setSelectionRange && setTimeout(function() {
                self.hour < 10 ? $element.setSelectionRange(5, 7) : $element.setSelectionRange(6, 8);
            }, 0);
        },
        highlightMeridian: function() {
            var $element = this.$element.get(0), self = this;
            this.highlightedUnit = "meridian", $element.setSelectionRange && (this.showSeconds ? setTimeout(function() {
                self.hour < 10 ? $element.setSelectionRange(8, 10) : $element.setSelectionRange(9, 11);
            }, 0) : setTimeout(function() {
                self.hour < 10 ? $element.setSelectionRange(5, 7) : $element.setSelectionRange(6, 8);
            }, 0));
        },
        incrementHour: function() {
            if (this.showMeridian) {
                if (11 === this.hour) return this.hour++, void this.toggleMeridian();
                12 === this.hour && (this.hour = 0);
            }
            return 23 === this.hour ? void (this.hour = 0) : void this.hour++;
        },
        incrementMinute: function(step) {
            var newVal = this.minute + (step || this.minuteStep - this.minute % this.minuteStep);
            newVal > 59 ? (this.incrementHour(), this.minute = newVal - 60) : this.minute = newVal;
        },
        incrementSecond: function() {
            var newVal = this.second + this.secondStep - this.second % this.secondStep;
            newVal > 59 ? (this.incrementMinute(1), this.second = newVal - 60) : this.second = newVal;
        },
        remove: function() {
            $("document").off(".timepicker"), delete this.$element.data().timepicker;
        },
        setDefaultTime: function(defaultTime) {
            if (this.$element.val()) this.updateFromElementVal(); else if ("current" === defaultTime) {
                var dTime = new Date(), hours = dTime.getHours(), minutes = dTime.getMinutes(), seconds = dTime.getSeconds(), meridian = "AM";
                0 !== seconds && (seconds = Math.ceil(dTime.getSeconds() / this.secondStep) * this.secondStep, 
                60 === seconds && (minutes += 1, seconds = 0)), 0 !== minutes && (minutes = Math.ceil(dTime.getMinutes() / this.minuteStep) * this.minuteStep, 
                60 === minutes && (hours += 1, minutes = 0)), this.showMeridian && (0 === hours ? hours = 12 : hours >= 12 ? (hours > 12 && (hours -= 12), 
                meridian = "PM") : meridian = "AM"), this.hour = hours, this.minute = minutes, this.second = seconds, 
                this.meridian = meridian, this.update();
            } else defaultTime ? this.setTime(defaultTime) : (this.hour = 0, this.minute = 0, 
            this.second = 0, this.meridian = "AM");
        },
        setTime: function(time, ignoreWidget) {
            if (!time) return void this.clear();
            var timeArray, hour, minute, second, meridian;
            "object" == typeof time && time.getMonth ? (hour = time.getHours(), minute = time.getMinutes(), 
            second = time.getSeconds(), this.showMeridian && (meridian = "AM", hour > 12 && (meridian = "PM", 
            hour %= 12), 12 === hour && (meridian = "PM"))) : (meridian = null !== time.match(/p/i) ? "PM" : "AM", 
            time = time.replace(/[^0-9\:]/g, ""), timeArray = time.split(":"), hour = timeArray[0] ? timeArray[0].toString() : timeArray.toString(), 
            minute = timeArray[1] ? timeArray[1].toString() : "", second = timeArray[2] ? timeArray[2].toString() : "", 
            hour.length > 4 && (second = hour.substr(4, 2)), hour.length > 2 && (minute = hour.substr(2, 2), 
            hour = hour.substr(0, 2)), minute.length > 2 && (second = minute.substr(2, 2), minute = minute.substr(0, 2)), 
            second.length > 2 && (second = second.substr(2, 2)), hour = parseInt(hour, 10), 
            minute = parseInt(minute, 10), second = parseInt(second, 10), isNaN(hour) && (hour = 0), 
            isNaN(minute) && (minute = 0), isNaN(second) && (second = 0), this.showMeridian ? 1 > hour ? hour = 1 : hour > 12 && (hour = 12) : (hour >= 24 ? hour = 23 : 0 > hour && (hour = 0), 
            13 > hour && "PM" === meridian && (hour += 12)), 0 > minute ? minute = 0 : minute >= 60 && (minute = 59), 
            this.showSeconds && (isNaN(second) ? second = 0 : 0 > second ? second = 0 : second >= 60 && (second = 59))), 
            this.hour = hour, this.minute = minute, this.second = second, this.meridian = meridian, 
            this.update(ignoreWidget);
        },
        toggleMeridian: function() {
            this.meridian = "AM" === this.meridian ? "PM" : "AM";
        },
        update: function() {
            this.updateElement(), this.$element.trigger({
                type: "changeTime.timepicker",
                time: {
                    value: this.getTime(),
                    hours: this.hour,
                    minutes: this.minute,
                    seconds: this.second,
                    meridian: this.meridian
                }
            });
        },
        updateElement: function() {
            this.$element.val(this.getTime()).change();
        },
        updateFromElementVal: function() {
            this.setTime(this.$element.val());
        }
    }, $.fn.timepicker = function(option) {
        var args = Array.apply(null, arguments);
        return args.shift(), this.each(function() {
            var $this = $(this), data = $this.data("timepicker"), options = "object" == typeof option && option;
            data || $this.data("timepicker", data = new Timepicker(this, $.extend({}, $.fn.timepicker.defaults, options, $(this).data()))), 
            "string" == typeof option && data[option].apply(data, args);
        });
    }, $.fn.timepicker.defaults = {
        defaultTime: "current",
        disableFocus: !1,
        minuteStep: 15,
        secondStep: 15,
        showSeconds: !1,
        showMeridian: !0
    }, $.fn.timepicker.Constructor = Timepicker;
}(jQuery, window, document), function(root, factory) {
    "use strict";
    "object" == typeof module && module.exports ? module.exports = factory(require("./punycode"), require("./IPv6"), require("./SecondLevelDomains")) : "function" == typeof define && define.amd ? define([ "./punycode", "./IPv6", "./SecondLevelDomains" ], factory) : root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
}(this, function(punycode, IPv6, SLD, root) {
    "use strict";
    function URI(url, base) {
        var _urlSupplied = arguments.length >= 1, _baseSupplied = arguments.length >= 2;
        if (!(this instanceof URI)) return _urlSupplied ? _baseSupplied ? new URI(url, base) : new URI(url) : new URI();
        if (void 0 === url) {
            if (_urlSupplied) throw new TypeError("undefined is not a valid argument for URI");
            url = "undefined" != typeof location ? location.href + "" : "";
        }
        if (null === url && _urlSupplied) throw new TypeError("null is not a valid argument for URI");
        return this.href(url), void 0 !== base ? this.absoluteTo(base) : this;
    }
    function escapeRegEx(string) {
        return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
    }
    function getType(value) {
        return void 0 === value ? "Undefined" : String(Object.prototype.toString.call(value)).slice(8, -1);
    }
    function isArray(obj) {
        return "Array" === getType(obj);
    }
    function filterArrayValues(data, value) {
        var i, length, lookup = {};
        if ("RegExp" === getType(value)) lookup = null; else if (isArray(value)) for (i = 0, 
        length = value.length; i < length; i++) lookup[value[i]] = !0; else lookup[value] = !0;
        for (i = 0, length = data.length; i < length; i++) {
            var _match = lookup && void 0 !== lookup[data[i]] || !lookup && value.test(data[i]);
            _match && (data.splice(i, 1), length--, i--);
        }
        return data;
    }
    function arrayContains(list, value) {
        var i, length;
        if (isArray(value)) {
            for (i = 0, length = value.length; i < length; i++) if (!arrayContains(list, value[i])) return !1;
            return !0;
        }
        var _type = getType(value);
        for (i = 0, length = list.length; i < length; i++) if ("RegExp" === _type) {
            if ("string" == typeof list[i] && list[i].match(value)) return !0;
        } else if (list[i] === value) return !0;
        return !1;
    }
    function arraysEqual(one, two) {
        if (!isArray(one) || !isArray(two)) return !1;
        if (one.length !== two.length) return !1;
        one.sort(), two.sort();
        for (var i = 0, l = one.length; i < l; i++) if (one[i] !== two[i]) return !1;
        return !0;
    }
    function trimSlashes(text) {
        var trim_expression = /^\/+|\/+$/g;
        return text.replace(trim_expression, "");
    }
    function escapeForDumbFirefox36(value) {
        return escape(value);
    }
    function strictEncodeURIComponent(string) {
        return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
    }
    function generateSimpleAccessor(_part) {
        return function(v, build) {
            return void 0 === v ? this._parts[_part] || "" : (this._parts[_part] = v || null, 
            this.build(!build), this);
        };
    }
    function generatePrefixAccessor(_part, _key) {
        return function(v, build) {
            return void 0 === v ? this._parts[_part] || "" : (null !== v && (v += "", v.charAt(0) === _key && (v = v.substring(1))), 
            this._parts[_part] = v, this.build(!build), this);
        };
    }
    var _URI = root && root.URI;
    URI.version = "1.18.5";
    var p = URI.prototype, hasOwn = Object.prototype.hasOwnProperty;
    URI._parts = function() {
        return {
            protocol: null,
            username: null,
            password: null,
            hostname: null,
            urn: null,
            port: null,
            path: null,
            query: null,
            fragment: null,
            duplicateQueryParameters: URI.duplicateQueryParameters,
            escapeQuerySpace: URI.escapeQuerySpace
        };
    }, URI.duplicateQueryParameters = !1, URI.escapeQuerySpace = !0, URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i, 
    URI.idn_expression = /[^a-z0-9\.-]/i, URI.punycode_expression = /(xn--)/i, URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, 
    URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/, 
    URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?]))/gi, 
    URI.findUri = {
        start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
        end: /[\s\r\n]|$/,
        trim: /[`!()\[\]{};:'".,<>?]+$/,
        parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
    }, URI.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21",
        gopher: "70",
        ws: "80",
        wss: "443"
    }, URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/, URI.domAttributes = {
        a: "href",
        blockquote: "cite",
        link: "href",
        base: "href",
        script: "src",
        form: "action",
        img: "src",
        area: "href",
        iframe: "src",
        embed: "src",
        source: "src",
        track: "src",
        input: "src",
        audio: "src",
        video: "src"
    }, URI.getDomAttribute = function(node) {
        if (node && node.nodeName) {
            var nodeName = node.nodeName.toLowerCase();
            if ("input" !== nodeName || "image" === node.type) return URI.domAttributes[nodeName];
        }
    }, URI.encode = strictEncodeURIComponent, URI.decode = decodeURIComponent, URI.iso8859 = function() {
        URI.encode = escape, URI.decode = unescape;
    }, URI.unicode = function() {
        URI.encode = strictEncodeURIComponent, URI.decode = decodeURIComponent;
    }, URI.characters = {
        pathname: {
            encode: {
                expression: /%(24|26|2B|2C|3B|3D|3A|40)/gi,
                map: {
                    "%24": "$",
                    "%26": "&",
                    "%2B": "+",
                    "%2C": ",",
                    "%3B": ";",
                    "%3D": "=",
                    "%3A": ":",
                    "%40": "@"
                }
            },
            decode: {
                expression: /[\/\?#]/g,
                map: {
                    "/": "%2F",
                    "?": "%3F",
                    "#": "%23"
                }
            }
        },
        reserved: {
            encode: {
                expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/gi,
                map: {
                    "%3A": ":",
                    "%2F": "/",
                    "%3F": "?",
                    "%23": "#",
                    "%5B": "[",
                    "%5D": "]",
                    "%40": "@",
                    "%21": "!",
                    "%24": "$",
                    "%26": "&",
                    "%27": "'",
                    "%28": "(",
                    "%29": ")",
                    "%2A": "*",
                    "%2B": "+",
                    "%2C": ",",
                    "%3B": ";",
                    "%3D": "="
                }
            }
        },
        urnpath: {
            encode: {
                expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/gi,
                map: {
                    "%21": "!",
                    "%24": "$",
                    "%27": "'",
                    "%28": "(",
                    "%29": ")",
                    "%2A": "*",
                    "%2B": "+",
                    "%2C": ",",
                    "%3B": ";",
                    "%3D": "=",
                    "%40": "@"
                }
            },
            decode: {
                expression: /[\/\?#:]/g,
                map: {
                    "/": "%2F",
                    "?": "%3F",
                    "#": "%23",
                    ":": "%3A"
                }
            }
        }
    }, URI.encodeQuery = function(string, escapeQuerySpace) {
        var escaped = URI.encode(string + "");
        return void 0 === escapeQuerySpace && (escapeQuerySpace = URI.escapeQuerySpace), 
        escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
    }, URI.decodeQuery = function(string, escapeQuerySpace) {
        string += "", void 0 === escapeQuerySpace && (escapeQuerySpace = URI.escapeQuerySpace);
        try {
            return URI.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
        } catch (e) {
            return string;
        }
    };
    var _part, _parts = {
        encode: "encode",
        decode: "decode"
    }, generateAccessor = function(_group, _part) {
        return function(string) {
            try {
                return URI[_part](string + "").replace(URI.characters[_group][_part].expression, function(c) {
                    return URI.characters[_group][_part].map[c];
                });
            } catch (e) {
                return string;
            }
        };
    };
    for (_part in _parts) URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]), 
    URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
    var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
        return function(string) {
            var actualCodingFunc;
            actualCodingFunc = _innerCodingFuncName ? function(string) {
                return URI[_codingFuncName](URI[_innerCodingFuncName](string));
            } : URI[_codingFuncName];
            for (var segments = (string + "").split(_sep), i = 0, length = segments.length; i < length; i++) segments[i] = actualCodingFunc(segments[i]);
            return segments.join(_sep);
        };
    };
    URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment"), URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment"), 
    URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode"), 
    URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode"), 
    URI.encodeReserved = generateAccessor("reserved", "encode"), URI.parse = function(string, parts) {
        var pos;
        return parts || (parts = {}), pos = string.indexOf("#"), pos > -1 && (parts.fragment = string.substring(pos + 1) || null, 
        string = string.substring(0, pos)), pos = string.indexOf("?"), pos > -1 && (parts.query = string.substring(pos + 1) || null, 
        string = string.substring(0, pos)), "//" === string.substring(0, 2) ? (parts.protocol = null, 
        string = string.substring(2), string = URI.parseAuthority(string, parts)) : (pos = string.indexOf(":"), 
        pos > -1 && (parts.protocol = string.substring(0, pos) || null, parts.protocol && !parts.protocol.match(URI.protocol_expression) ? parts.protocol = void 0 : "//" === string.substring(pos + 1, pos + 3) ? (string = string.substring(pos + 3), 
        string = URI.parseAuthority(string, parts)) : (string = string.substring(pos + 1), 
        parts.urn = !0))), parts.path = string, parts;
    }, URI.parseHost = function(string, parts) {
        string = string.replace(/\\/g, "/");
        var bracketPos, t, pos = string.indexOf("/");
        if (pos === -1 && (pos = string.length), "[" === string.charAt(0)) bracketPos = string.indexOf("]"), 
        parts.hostname = string.substring(1, bracketPos) || null, parts.port = string.substring(bracketPos + 2, pos) || null, 
        "/" === parts.port && (parts.port = null); else {
            var firstColon = string.indexOf(":"), firstSlash = string.indexOf("/"), nextColon = string.indexOf(":", firstColon + 1);
            nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash) ? (parts.hostname = string.substring(0, pos) || null, 
            parts.port = null) : (t = string.substring(0, pos).split(":"), parts.hostname = t[0] || null, 
            parts.port = t[1] || null);
        }
        return parts.hostname && "/" !== string.substring(pos).charAt(0) && (pos++, string = "/" + string), 
        string.substring(pos) || "/";
    }, URI.parseAuthority = function(string, parts) {
        return string = URI.parseUserinfo(string, parts), URI.parseHost(string, parts);
    }, URI.parseUserinfo = function(string, parts) {
        var t, firstSlash = string.indexOf("/"), pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
        return pos > -1 && (firstSlash === -1 || pos < firstSlash) ? (t = string.substring(0, pos).split(":"), 
        parts.username = t[0] ? URI.decode(t[0]) : null, t.shift(), parts.password = t[0] ? URI.decode(t.join(":")) : null, 
        string = string.substring(pos + 1)) : (parts.username = null, parts.password = null), 
        string;
    }, URI.parseQuery = function(string, escapeQuerySpace) {
        if (!string) return {};
        if (string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, ""), !string) return {};
        for (var v, name, value, items = {}, splits = string.split("&"), length = splits.length, i = 0; i < length; i++) v = splits[i].split("="), 
        name = URI.decodeQuery(v.shift(), escapeQuerySpace), value = v.length ? URI.decodeQuery(v.join("="), escapeQuerySpace) : null, 
        hasOwn.call(items, name) ? ("string" != typeof items[name] && null !== items[name] || (items[name] = [ items[name] ]), 
        items[name].push(value)) : items[name] = value;
        return items;
    }, URI.build = function(parts) {
        var t = "";
        return parts.protocol && (t += parts.protocol + ":"), parts.urn || !t && !parts.hostname || (t += "//"), 
        t += URI.buildAuthority(parts) || "", "string" == typeof parts.path && ("/" !== parts.path.charAt(0) && "string" == typeof parts.hostname && (t += "/"), 
        t += parts.path), "string" == typeof parts.query && parts.query && (t += "?" + parts.query), 
        "string" == typeof parts.fragment && parts.fragment && (t += "#" + parts.fragment), 
        t;
    }, URI.buildHost = function(parts) {
        var t = "";
        return parts.hostname ? (t += URI.ip6_expression.test(parts.hostname) ? "[" + parts.hostname + "]" : parts.hostname, 
        parts.port && (t += ":" + parts.port), t) : "";
    }, URI.buildAuthority = function(parts) {
        return URI.buildUserinfo(parts) + URI.buildHost(parts);
    }, URI.buildUserinfo = function(parts) {
        var t = "";
        return parts.username && (t += URI.encode(parts.username)), parts.password && (t += ":" + URI.encode(parts.password)), 
        t && (t += "@"), t;
    }, URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
        var unique, key, i, length, t = "";
        for (key in data) if (hasOwn.call(data, key) && key) if (isArray(data[key])) for (unique = {}, 
        i = 0, length = data[key].length; i < length; i++) void 0 !== data[key][i] && void 0 === unique[data[key][i] + ""] && (t += "&" + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace), 
        duplicateQueryParameters !== !0 && (unique[data[key][i] + ""] = !0)); else void 0 !== data[key] && (t += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace));
        return t.substring(1);
    }, URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
        return URI.encodeQuery(name, escapeQuerySpace) + (null !== value ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "");
    }, URI.addQuery = function(data, name, value) {
        if ("object" == typeof name) for (var key in name) hasOwn.call(name, key) && URI.addQuery(data, key, name[key]); else {
            if ("string" != typeof name) throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
            if (void 0 === data[name]) return void (data[name] = value);
            "string" == typeof data[name] && (data[name] = [ data[name] ]), isArray(value) || (value = [ value ]), 
            data[name] = (data[name] || []).concat(value);
        }
    }, URI.removeQuery = function(data, name, value) {
        var i, length, key;
        if (isArray(name)) for (i = 0, length = name.length; i < length; i++) data[name[i]] = void 0; else if ("RegExp" === getType(name)) for (key in data) name.test(key) && (data[key] = void 0); else if ("object" == typeof name) for (key in name) hasOwn.call(name, key) && URI.removeQuery(data, key, name[key]); else {
            if ("string" != typeof name) throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
            void 0 !== value ? "RegExp" === getType(value) ? !isArray(data[name]) && value.test(data[name]) ? data[name] = void 0 : data[name] = filterArrayValues(data[name], value) : data[name] !== String(value) || isArray(value) && 1 !== value.length ? isArray(data[name]) && (data[name] = filterArrayValues(data[name], value)) : data[name] = void 0 : data[name] = void 0;
        }
    }, URI.hasQuery = function(data, name, value, withinArray) {
        switch (getType(name)) {
          case "String":
            break;

          case "RegExp":
            for (var key in data) if (hasOwn.call(data, key) && name.test(key) && (void 0 === value || URI.hasQuery(data, key, value))) return !0;
            return !1;

          case "Object":
            for (var _key in name) if (hasOwn.call(name, _key) && !URI.hasQuery(data, _key, name[_key])) return !1;
            return !0;

          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (getType(value)) {
          case "Undefined":
            return name in data;

          case "Boolean":
            var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
            return value === _booly;

          case "Function":
            return !!value(data[name], name, data);

          case "Array":
            if (!isArray(data[name])) return !1;
            var op = withinArray ? arrayContains : arraysEqual;
            return op(data[name], value);

          case "RegExp":
            return isArray(data[name]) ? !!withinArray && arrayContains(data[name], value) : Boolean(data[name] && data[name].match(value));

          case "Number":
            value = String(value);

          case "String":
            return isArray(data[name]) ? !!withinArray && arrayContains(data[name], value) : data[name] === value;

          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
    }, URI.joinPaths = function() {
        for (var input = [], segments = [], nonEmptySegments = 0, i = 0; i < arguments.length; i++) {
            var url = new URI(arguments[i]);
            input.push(url);
            for (var _segments = url.segment(), s = 0; s < _segments.length; s++) "string" == typeof _segments[s] && segments.push(_segments[s]), 
            _segments[s] && nonEmptySegments++;
        }
        if (!segments.length || !nonEmptySegments) return new URI("");
        var uri = new URI("").segment(segments);
        return "" !== input[0].path() && "/" !== input[0].path().slice(0, 1) || uri.path("/" + uri.path()), 
        uri.normalize();
    }, URI.commonPath = function(one, two) {
        var pos, length = Math.min(one.length, two.length);
        for (pos = 0; pos < length; pos++) if (one.charAt(pos) !== two.charAt(pos)) {
            pos--;
            break;
        }
        return pos < 1 ? one.charAt(0) === two.charAt(0) && "/" === one.charAt(0) ? "/" : "" : ("/" === one.charAt(pos) && "/" === two.charAt(pos) || (pos = one.substring(0, pos).lastIndexOf("/")), 
        one.substring(0, pos + 1));
    }, URI.withinString = function(string, callback, options) {
        options || (options = {});
        var _start = options.start || URI.findUri.start, _end = options.end || URI.findUri.end, _trim = options.trim || URI.findUri.trim, _parens = options.parens || URI.findUri.parens, _attributeOpen = /[a-z0-9-]=["']?$/i;
        for (_start.lastIndex = 0; ;) {
            var match = _start.exec(string);
            if (!match) break;
            var start = match.index;
            if (options.ignoreHtml) {
                var attributeOpen = string.slice(Math.max(start - 3, 0), start);
                if (attributeOpen && _attributeOpen.test(attributeOpen)) continue;
            }
            for (var end = start + string.slice(start).search(_end), slice = string.slice(start, end), parensEnd = -1; ;) {
                var parensMatch = _parens.exec(slice);
                if (!parensMatch) break;
                var parensMatchEnd = parensMatch.index + parensMatch[0].length;
                parensEnd = Math.max(parensEnd, parensMatchEnd);
            }
            if (slice = parensEnd > -1 ? slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "") : slice.replace(_trim, ""), 
            !options.ignore || !options.ignore.test(slice)) {
                end = start + slice.length;
                var result = callback(slice, start, end, string);
                void 0 !== result ? (result = String(result), string = string.slice(0, start) + result + string.slice(end), 
                _start.lastIndex = start + result.length) : _start.lastIndex = end;
            }
        }
        return _start.lastIndex = 0, string;
    }, URI.ensureValidHostname = function(v) {
        if (v.match(URI.invalid_hostname_characters)) {
            if (!punycode) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
            if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        }
    }, URI.noConflict = function(removeAll) {
        if (removeAll) {
            var unconflicted = {
                URI: this.noConflict()
            };
            return root.URITemplate && "function" == typeof root.URITemplate.noConflict && (unconflicted.URITemplate = root.URITemplate.noConflict()), 
            root.IPv6 && "function" == typeof root.IPv6.noConflict && (unconflicted.IPv6 = root.IPv6.noConflict()), 
            root.SecondLevelDomains && "function" == typeof root.SecondLevelDomains.noConflict && (unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict()), 
            unconflicted;
        }
        return root.URI === this && (root.URI = _URI), this;
    }, p.build = function(deferBuild) {
        return deferBuild === !0 ? this._deferred_build = !0 : (void 0 === deferBuild || this._deferred_build) && (this._string = URI.build(this._parts), 
        this._deferred_build = !1), this;
    }, p.clone = function() {
        return new URI(this);
    }, p.valueOf = p.toString = function() {
        return this.build(!1)._string;
    }, p.protocol = generateSimpleAccessor("protocol"), p.username = generateSimpleAccessor("username"), 
    p.password = generateSimpleAccessor("password"), p.hostname = generateSimpleAccessor("hostname"), 
    p.port = generateSimpleAccessor("port"), p.query = generatePrefixAccessor("query", "?"), 
    p.fragment = generatePrefixAccessor("fragment", "#"), p.search = function(v, build) {
        var t = this.query(v, build);
        return "string" == typeof t && t.length ? "?" + t : t;
    }, p.hash = function(v, build) {
        var t = this.fragment(v, build);
        return "string" == typeof t && t.length ? "#" + t : t;
    }, p.pathname = function(v, build) {
        if (void 0 === v || v === !0) {
            var res = this._parts.path || (this._parts.hostname ? "/" : "");
            return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
        }
        return this._parts.urn ? this._parts.path = v ? URI.recodeUrnPath(v) : "" : this._parts.path = v ? URI.recodePath(v) : "/", 
        this.build(!build), this;
    }, p.path = p.pathname, p.href = function(href, build) {
        var key;
        if (void 0 === href) return this.toString();
        this._string = "", this._parts = URI._parts();
        var _URI = href instanceof URI, _object = "object" == typeof href && (href.hostname || href.path || href.pathname);
        if (href.nodeName) {
            var attribute = URI.getDomAttribute(href);
            href = href[attribute] || "", _object = !1;
        }
        if (!_URI && _object && void 0 !== href.pathname && (href = href.toString()), "string" == typeof href || href instanceof String) this._parts = URI.parse(String(href), this._parts); else {
            if (!_URI && !_object) throw new TypeError("invalid input");
            var src = _URI ? href._parts : href;
            for (key in src) hasOwn.call(this._parts, key) && (this._parts[key] = src[key]);
        }
        return this.build(!build), this;
    }, p.is = function(what) {
        var ip = !1, ip4 = !1, ip6 = !1, name = !1, sld = !1, idn = !1, punycode = !1, relative = !this._parts.urn;
        switch (this._parts.hostname && (relative = !1, ip4 = URI.ip4_expression.test(this._parts.hostname), 
        ip6 = URI.ip6_expression.test(this._parts.hostname), ip = ip4 || ip6, name = !ip, 
        sld = name && SLD && SLD.has(this._parts.hostname), idn = name && URI.idn_expression.test(this._parts.hostname), 
        punycode = name && URI.punycode_expression.test(this._parts.hostname)), what.toLowerCase()) {
          case "relative":
            return relative;

          case "absolute":
            return !relative;

          case "domain":
          case "name":
            return name;

          case "sld":
            return sld;

          case "ip":
            return ip;

          case "ip4":
          case "ipv4":
          case "inet4":
            return ip4;

          case "ip6":
          case "ipv6":
          case "inet6":
            return ip6;

          case "idn":
            return idn;

          case "url":
            return !this._parts.urn;

          case "urn":
            return !!this._parts.urn;

          case "punycode":
            return punycode;
        }
        return null;
    };
    var _protocol = p.protocol, _port = p.port, _hostname = p.hostname;
    p.protocol = function(v, build) {
        if (void 0 !== v && v && (v = v.replace(/:(\/\/)?$/, ""), !v.match(URI.protocol_expression))) throw new TypeError('Protocol "' + v + "\" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]");
        return _protocol.call(this, v, build);
    }, p.scheme = p.protocol, p.port = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if (void 0 !== v && (0 === v && (v = null), v && (v += "", ":" === v.charAt(0) && (v = v.substring(1)), 
        v.match(/[^0-9]/)))) throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
        return _port.call(this, v, build);
    }, p.hostname = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if (void 0 !== v) {
            var x = {}, res = URI.parseHost(v, x);
            if ("/" !== res) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
            v = x.hostname;
        }
        return _hostname.call(this, v, build);
    }, p.origin = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if (void 0 === v) {
            var protocol = this.protocol(), authority = this.authority();
            return authority ? (protocol ? protocol + "://" : "") + this.authority() : "";
        }
        var origin = URI(v);
        return this.protocol(origin.protocol()).authority(origin.authority()).build(!build), 
        this;
    }, p.host = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if (void 0 === v) return this._parts.hostname ? URI.buildHost(this._parts) : "";
        var res = URI.parseHost(v, this._parts);
        if ("/" !== res) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        return this.build(!build), this;
    }, p.authority = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if (void 0 === v) return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
        var res = URI.parseAuthority(v, this._parts);
        if ("/" !== res) throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
        return this.build(!build), this;
    }, p.userinfo = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if (void 0 === v) {
            var t = URI.buildUserinfo(this._parts);
            return t ? t.substring(0, t.length - 1) : t;
        }
        return "@" !== v[v.length - 1] && (v += "@"), URI.parseUserinfo(v, this._parts), 
        this.build(!build), this;
    }, p.resource = function(v, build) {
        var parts;
        return void 0 === v ? this.path() + this.search() + this.hash() : (parts = URI.parse(v), 
        this._parts.path = parts.path, this._parts.query = parts.query, this._parts.fragment = parts.fragment, 
        this.build(!build), this);
    }, p.subdomain = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if (void 0 === v) {
            if (!this._parts.hostname || this.is("IP")) return "";
            var end = this._parts.hostname.length - this.domain().length - 1;
            return this._parts.hostname.substring(0, end) || "";
        }
        var e = this._parts.hostname.length - this.domain().length, sub = this._parts.hostname.substring(0, e), replace = new RegExp("^" + escapeRegEx(sub));
        return v && "." !== v.charAt(v.length - 1) && (v += "."), v && URI.ensureValidHostname(v), 
        this._parts.hostname = this._parts.hostname.replace(replace, v), this.build(!build), 
        this;
    }, p.domain = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if ("boolean" == typeof v && (build = v, v = void 0), void 0 === v) {
            if (!this._parts.hostname || this.is("IP")) return "";
            var t = this._parts.hostname.match(/\./g);
            if (t && t.length < 2) return this._parts.hostname;
            var end = this._parts.hostname.length - this.tld(build).length - 1;
            return end = this._parts.hostname.lastIndexOf(".", end - 1) + 1, this._parts.hostname.substring(end) || "";
        }
        if (!v) throw new TypeError("cannot set domain empty");
        if (URI.ensureValidHostname(v), !this._parts.hostname || this.is("IP")) this._parts.hostname = v; else {
            var replace = new RegExp(escapeRegEx(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
        }
        return this.build(!build), this;
    }, p.tld = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if ("boolean" == typeof v && (build = v, v = void 0), void 0 === v) {
            if (!this._parts.hostname || this.is("IP")) return "";
            var pos = this._parts.hostname.lastIndexOf("."), tld = this._parts.hostname.substring(pos + 1);
            return build !== !0 && SLD && SLD.list[tld.toLowerCase()] ? SLD.get(this._parts.hostname) || tld : tld;
        }
        var replace;
        if (!v) throw new TypeError("cannot set TLD empty");
        if (v.match(/[^a-zA-Z0-9-]/)) {
            if (!SLD || !SLD.is(v)) throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
            replace = new RegExp(escapeRegEx(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(replace, v);
        } else {
            if (!this._parts.hostname || this.is("IP")) throw new ReferenceError("cannot set TLD on non-domain host");
            replace = new RegExp(escapeRegEx(this.tld()) + "$"), this._parts.hostname = this._parts.hostname.replace(replace, v);
        }
        return this.build(!build), this;
    }, p.directory = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if (void 0 === v || v === !0) {
            if (!this._parts.path && !this._parts.hostname) return "";
            if ("/" === this._parts.path) return "/";
            var end = this._parts.path.length - this.filename().length - 1, res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
            return v ? URI.decodePath(res) : res;
        }
        var e = this._parts.path.length - this.filename().length, directory = this._parts.path.substring(0, e), replace = new RegExp("^" + escapeRegEx(directory));
        return this.is("relative") || (v || (v = "/"), "/" !== v.charAt(0) && (v = "/" + v)), 
        v && "/" !== v.charAt(v.length - 1) && (v += "/"), v = URI.recodePath(v), this._parts.path = this._parts.path.replace(replace, v), 
        this.build(!build), this;
    }, p.filename = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if ("string" != typeof v) {
            if (!this._parts.path || "/" === this._parts.path) return "";
            var pos = this._parts.path.lastIndexOf("/"), res = this._parts.path.substring(pos + 1);
            return v ? URI.decodePathSegment(res) : res;
        }
        var mutatedDirectory = !1;
        "/" === v.charAt(0) && (v = v.substring(1)), v.match(/\.?\//) && (mutatedDirectory = !0);
        var replace = new RegExp(escapeRegEx(this.filename()) + "$");
        return v = URI.recodePath(v), this._parts.path = this._parts.path.replace(replace, v), 
        mutatedDirectory ? this.normalizePath(build) : this.build(!build), this;
    }, p.suffix = function(v, build) {
        if (this._parts.urn) return void 0 === v ? "" : this;
        if (void 0 === v || v === !0) {
            if (!this._parts.path || "/" === this._parts.path) return "";
            var s, res, filename = this.filename(), pos = filename.lastIndexOf(".");
            return pos === -1 ? "" : (s = filename.substring(pos + 1), res = /^[a-z0-9%]+$/i.test(s) ? s : "", 
            v ? URI.decodePathSegment(res) : res);
        }
        "." === v.charAt(0) && (v = v.substring(1));
        var replace, suffix = this.suffix();
        if (suffix) replace = v ? new RegExp(escapeRegEx(suffix) + "$") : new RegExp(escapeRegEx("." + suffix) + "$"); else {
            if (!v) return this;
            this._parts.path += "." + URI.recodePath(v);
        }
        return replace && (v = URI.recodePath(v), this._parts.path = this._parts.path.replace(replace, v)), 
        this.build(!build), this;
    }, p.segment = function(segment, v, build) {
        var separator = this._parts.urn ? ":" : "/", path = this.path(), absolute = "/" === path.substring(0, 1), segments = path.split(separator);
        if (void 0 !== segment && "number" != typeof segment && (build = v, v = segment, 
        segment = void 0), void 0 !== segment && "number" != typeof segment) throw new Error('Bad segment "' + segment + '", must be 0-based integer');
        if (absolute && segments.shift(), segment < 0 && (segment = Math.max(segments.length + segment, 0)), 
        void 0 === v) return void 0 === segment ? segments : segments[segment];
        if (null === segment || void 0 === segments[segment]) if (isArray(v)) {
            segments = [];
            for (var i = 0, l = v.length; i < l; i++) (v[i].length || segments.length && segments[segments.length - 1].length) && (segments.length && !segments[segments.length - 1].length && segments.pop(), 
            segments.push(trimSlashes(v[i])));
        } else (v || "string" == typeof v) && (v = trimSlashes(v), "" === segments[segments.length - 1] ? segments[segments.length - 1] = v : segments.push(v)); else v ? segments[segment] = trimSlashes(v) : segments.splice(segment, 1);
        return absolute && segments.unshift(""), this.path(segments.join(separator), build);
    }, p.segmentCoded = function(segment, v, build) {
        var segments, i, l;
        if ("number" != typeof segment && (build = v, v = segment, segment = void 0), void 0 === v) {
            if (segments = this.segment(segment, v, build), isArray(segments)) for (i = 0, l = segments.length; i < l; i++) segments[i] = URI.decode(segments[i]); else segments = void 0 !== segments ? URI.decode(segments) : void 0;
            return segments;
        }
        if (isArray(v)) for (i = 0, l = v.length; i < l; i++) v[i] = URI.encode(v[i]); else v = "string" == typeof v || v instanceof String ? URI.encode(v) : v;
        return this.segment(segment, v, build);
    };
    var q = p.query;
    return p.query = function(v, build) {
        if (v === !0) return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if ("function" == typeof v) {
            var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace), result = v.call(this, data);
            return this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), 
            this.build(!build), this;
        }
        return void 0 !== v && "string" != typeof v ? (this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), 
        this.build(!build), this) : q.call(this, v, build);
    }, p.setQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if ("string" == typeof name || name instanceof String) data[name] = void 0 !== value ? value : null; else {
            if ("object" != typeof name) throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
            for (var key in name) hasOwn.call(name, key) && (data[key] = name[key]);
        }
        return this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), 
        "string" != typeof name && (build = value), this.build(!build), this;
    }, p.addQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI.addQuery(data, name, void 0 === value ? null : value), this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), 
        "string" != typeof name && (build = value), this.build(!build), this;
    }, p.removeQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI.removeQuery(data, name, value), this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace), 
        "string" != typeof name && (build = value), this.build(!build), this;
    }, p.hasQuery = function(name, value, withinArray) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI.hasQuery(data, name, value, withinArray);
    }, p.setSearch = p.setQuery, p.addSearch = p.addQuery, p.removeSearch = p.removeQuery, 
    p.hasSearch = p.hasQuery, p.normalize = function() {
        return this._parts.urn ? this.normalizeProtocol(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build() : this.normalizeProtocol(!1).normalizeHostname(!1).normalizePort(!1).normalizePath(!1).normalizeQuery(!1).normalizeFragment(!1).build();
    }, p.normalizeProtocol = function(build) {
        return "string" == typeof this._parts.protocol && (this._parts.protocol = this._parts.protocol.toLowerCase(), 
        this.build(!build)), this;
    }, p.normalizeHostname = function(build) {
        return this._parts.hostname && (this.is("IDN") && punycode ? this._parts.hostname = punycode.toASCII(this._parts.hostname) : this.is("IPv6") && IPv6 && (this._parts.hostname = IPv6.best(this._parts.hostname)), 
        this._parts.hostname = this._parts.hostname.toLowerCase(), this.build(!build)), 
        this;
    }, p.normalizePort = function(build) {
        return "string" == typeof this._parts.protocol && this._parts.port === URI.defaultPorts[this._parts.protocol] && (this._parts.port = null, 
        this.build(!build)), this;
    }, p.normalizePath = function(build) {
        var _path = this._parts.path;
        if (!_path) return this;
        if (this._parts.urn) return this._parts.path = URI.recodeUrnPath(this._parts.path), 
        this.build(!build), this;
        if ("/" === this._parts.path) return this;
        _path = URI.recodePath(_path);
        var _was_relative, _parent, _pos, _leadingParents = "";
        for ("/" !== _path.charAt(0) && (_was_relative = !0, _path = "/" + _path), "/.." !== _path.slice(-3) && "/." !== _path.slice(-2) || (_path += "/"), 
        _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/"), _was_relative && (_leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "", 
        _leadingParents && (_leadingParents = _leadingParents[0])); ;) {
            if (_parent = _path.search(/\/\.\.(\/|$)/), _parent === -1) break;
            0 !== _parent ? (_pos = _path.substring(0, _parent).lastIndexOf("/"), _pos === -1 && (_pos = _parent), 
            _path = _path.substring(0, _pos) + _path.substring(_parent + 3)) : _path = _path.substring(3);
        }
        return _was_relative && this.is("relative") && (_path = _leadingParents + _path.substring(1)), 
        this._parts.path = _path, this.build(!build), this;
    }, p.normalizePathname = p.normalizePath, p.normalizeQuery = function(build) {
        return "string" == typeof this._parts.query && (this._parts.query.length ? this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace)) : this._parts.query = null, 
        this.build(!build)), this;
    }, p.normalizeFragment = function(build) {
        return this._parts.fragment || (this._parts.fragment = null, this.build(!build)), 
        this;
    }, p.normalizeSearch = p.normalizeQuery, p.normalizeHash = p.normalizeFragment, 
    p.iso8859 = function() {
        var e = URI.encode, d = URI.decode;
        URI.encode = escape, URI.decode = decodeURIComponent;
        try {
            this.normalize();
        } finally {
            URI.encode = e, URI.decode = d;
        }
        return this;
    }, p.unicode = function() {
        var e = URI.encode, d = URI.decode;
        URI.encode = strictEncodeURIComponent, URI.decode = unescape;
        try {
            this.normalize();
        } finally {
            URI.encode = e, URI.decode = d;
        }
        return this;
    }, p.readable = function() {
        var uri = this.clone();
        uri.username("").password("").normalize();
        var t = "";
        if (uri._parts.protocol && (t += uri._parts.protocol + "://"), uri._parts.hostname && (uri.is("punycode") && punycode ? (t += punycode.toUnicode(uri._parts.hostname), 
        uri._parts.port && (t += ":" + uri._parts.port)) : t += uri.host()), uri._parts.hostname && uri._parts.path && "/" !== uri._parts.path.charAt(0) && (t += "/"), 
        t += uri.path(!0), uri._parts.query) {
            for (var q = "", i = 0, qp = uri._parts.query.split("&"), l = qp.length; i < l; i++) {
                var kv = (qp[i] || "").split("=");
                q += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26"), 
                void 0 !== kv[1] && (q += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26"));
            }
            t += "?" + q.substring(1);
        }
        return t += URI.decodeQuery(uri.hash(), !0);
    }, p.absoluteTo = function(base) {
        var basedir, i, p, resolved = this.clone(), properties = [ "protocol", "username", "password", "hostname", "port" ];
        if (this._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
        if (base instanceof URI || (base = new URI(base)), resolved._parts.protocol || (resolved._parts.protocol = base._parts.protocol), 
        this._parts.hostname) return resolved;
        for (i = 0; p = properties[i]; i++) resolved._parts[p] = base._parts[p];
        return resolved._parts.path ? (".." === resolved._parts.path.substring(-2) && (resolved._parts.path += "/"), 
        "/" !== resolved.path().charAt(0) && (basedir = base.directory(), basedir = basedir ? basedir : 0 === base.path().indexOf("/") ? "/" : "", 
        resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path, resolved.normalizePath())) : (resolved._parts.path = base._parts.path, 
        resolved._parts.query || (resolved._parts.query = base._parts.query)), resolved.build(), 
        resolved;
    }, p.relativeTo = function(base) {
        var relativeParts, baseParts, common, relativePath, basePath, relative = this.clone().normalize();
        if (relative._parts.urn) throw new Error("URNs do not have any generally defined hierarchical components");
        if (base = new URI(base).normalize(), relativeParts = relative._parts, baseParts = base._parts, 
        relativePath = relative.path(), basePath = base.path(), "/" !== relativePath.charAt(0)) throw new Error("URI is already relative");
        if ("/" !== basePath.charAt(0)) throw new Error("Cannot calculate a URI relative to another relative URI");
        if (relativeParts.protocol === baseParts.protocol && (relativeParts.protocol = null), 
        relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) return relative.build();
        if (null !== relativeParts.protocol || null !== relativeParts.username || null !== relativeParts.password) return relative.build();
        if (relativeParts.hostname !== baseParts.hostname || relativeParts.port !== baseParts.port) return relative.build();
        if (relativeParts.hostname = null, relativeParts.port = null, relativePath === basePath) return relativeParts.path = "", 
        relative.build();
        if (common = URI.commonPath(relativePath, basePath), !common) return relative.build();
        var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        return relativeParts.path = parents + relativeParts.path.substring(common.length) || "./", 
        relative.build();
    }, p.equals = function(uri) {
        var one_query, two_query, key, one = this.clone(), two = new URI(uri), one_map = {}, two_map = {}, checked = {};
        if (one.normalize(), two.normalize(), one.toString() === two.toString()) return !0;
        if (one_query = one.query(), two_query = two.query(), one.query(""), two.query(""), 
        one.toString() !== two.toString()) return !1;
        if (one_query.length !== two_query.length) return !1;
        one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace), two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
        for (key in one_map) if (hasOwn.call(one_map, key)) {
            if (isArray(one_map[key])) {
                if (!arraysEqual(one_map[key], two_map[key])) return !1;
            } else if (one_map[key] !== two_map[key]) return !1;
            checked[key] = !0;
        }
        for (key in two_map) if (hasOwn.call(two_map, key) && !checked[key]) return !1;
        return !0;
    }, p.duplicateQueryParameters = function(v) {
        return this._parts.duplicateQueryParameters = !!v, this;
    }, p.escapeQuerySpace = function(v) {
        return this._parts.escapeQuerySpace = !!v, this;
    }, URI;
}), function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery", "../jquery.validate" ], factory) : "object" == typeof module && module.exports ? module.exports = factory(require("jquery")) : factory(jQuery);
}(function($) {
    return $.extend($.validator.messages, {
        required: "Dieses Feld ist ein Pflichtfeld.",
        maxlength: $.validator.format("Geben Sie bitte maximal {0} Zeichen ein."),
        minlength: $.validator.format("Geben Sie bitte mindestens {0} Zeichen ein."),
        rangelength: $.validator.format("Geben Sie bitte mindestens {0} und maximal {1} Zeichen ein."),
        email: "Geben Sie bitte eine gltige E-Mail Adresse ein.",
        url: "Geben Sie bitte eine gltige URL ein.",
        date: "Bitte geben Sie ein gltiges Datum ein.",
        number: "Geben Sie bitte eine Nummer ein.",
        digits: "Geben Sie bitte nur Ziffern ein.",
        equalTo: "Bitte denselben Wert wiederholen.",
        range: $.validator.format("Geben Sie bitte einen Wert zwischen {0} und {1} ein."),
        max: $.validator.format("Geben Sie bitte einen Wert kleiner oder gleich {0} ein."),
        min: $.validator.format("Geben Sie bitte einen Wert grer oder gleich {0} ein."),
        creditcard: "Geben Sie bitte eine gltige Kreditkarten-Nummer ein."
    }), $;
}), function(factory) {
    "function" == typeof define && define.amd ? define([ "jquery", "../jquery.validate" ], factory) : "object" == typeof module && module.exports ? module.exports = factory(require("jquery")) : factory(jQuery);
}(function($) {
    return $.extend($.validator.methods, {
        date: function(value, element) {
            return this.optional(element) || /^\d\d?\.\d\d?\.\d\d\d?\d?$/.test(value);
        },
        number: function(value, element) {
            return this.optional(element) || /^-?(?:\d+|\d{1,3}(?:\.\d{3})+)(?:,\d+)?$/.test(value);
        }
    }), $;
}), function($) {
    $.fn.datepicker.dates.de = {
        days: [ "Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag" ],
        daysShort: [ "Son", "Mon", "Die", "Mit", "Don", "Fre", "Sam" ],
        daysMin: [ "So", "Mo", "Di", "Mi", "Do", "Fr", "Sa" ],
        months: [ "Januar", "Februar", "Mrz", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember" ],
        monthsShort: [ "Jan", "Feb", "Mr", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez" ],
        today: "Heute",
        monthsTitle: "Monate",
        clear: "Lschen",
        weekStart: 1,
        format: "dd.mm.yyyy"
    };
}(jQuery), function() {
    if (jQuery && jQuery.fn && jQuery.fn.select2 && jQuery.fn.select2.amd) var e = jQuery.fn.select2.amd;
    return e.define("select2/i18n/de", [], function() {
        return {
            inputTooLong: function(e) {
                var t = e.input.length - e.maximum;
                return "Bitte " + t + " Zeichen weniger eingeben";
            },
            inputTooShort: function(e) {
                var t = e.minimum - e.input.length;
                return "Bitte " + t + " Zeichen mehr eingeben";
            },
            loadingMore: function() {
                return "Lade mehr Ergebnisse";
            },
            maximumSelected: function(e) {
                var t = "Sie knnen nur " + e.maximum + " Eintr";
                return t += 1 === e.maximum ? "ag" : "ge", t += " auswhlen";
            },
            noResults: function() {
                return "Keine bereinstimmungen gefunden";
            },
            searching: function() {
                return "Suche";
            }
        };
    }), {
        define: e.define,
        require: e.require
    };
}(), function() {
    "use strict";
    function highlightCurrentSection() {
        var result = URI.parse(window.location.href);
        $("[data-jcnav]").filter(function() {
            return new RegExp("^/" + $(this).attr("data-jcnav")).test(result.path);
        }).addClass("active");
    }
    function adaptScrollableBox() {
        var h = $(window).height(), padtop = parseInt($("body").css("padding-top"), 10), padbottom = parseInt($("body").css("padding-bottom"), 10), otherElementsHeight = 120;
        $(".scrollable-box").css("maxHeight", Math.max(h - (padtop + padbottom + otherElementsHeight), 250) + "px"), 
        $(".scrollable-box").css("margin-bottom", "0px"), $(".scrollable-box").css("overflow-y", "scroll");
    }
    function patchBootstrapPopover() {
        var originalLeave = $.fn.popover.Constructor.prototype.leave;
        $.fn.popover.Constructor.prototype.leave = function(obj) {
            var container, timeout, self = obj instanceof this.constructor ? obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data("bs." + this.type);
            originalLeave.call(this, obj), obj.currentTarget && (container = $(".popover"), 
            timeout = self.timeout, container.one("mouseenter", function() {
                clearTimeout(timeout), container.one("mouseleave", function() {
                    $.fn.popover.Constructor.prototype.leave.call(self, self);
                });
            }));
        };
    }
    function addHelpButtonToTextarea() {
        $(".md-textarea").each(function() {
            $(this).markdown({
                additionalButtons: [ [ {
                    name: "groupCustom",
                    data: [ {
                        name: "cmdHelp",
                        title: "Hilfe",
                        icon: "fa fa-question-circle",
                        callback: function() {
                            $("#cheatsheet").modal({
                                remote: "/cheatsheet.html"
                            });
                        }
                    } ]
                } ] ],
                onPreview: function(e) {
                    return $.post("/preview", {
                        data: e.getContent(),
                        subdir: $("[name=subdir]").val() || $("[name=assignedGroup]").val() || $("[name=id]").val(),
                        _csrf: $("[name=_csrf]").val()
                    }, function(data) {
                        e.$element.parent().find(".md-preview").html(data);
                    }), "";
                },
                iconlibrary: "fa",
                language: "de",
                resize: "vertical"
            });
        });
    }
    function initPickersAndWidgets() {
        $(".datepicker").datepicker({
            autoclose: !0,
            format: "dd.mm.yyyy",
            startDate: moment().format("DD.MM.YYYY"),
            weekStart: 1,
            viewMode: "days",
            minViewMode: "days",
            language: "de",
            orientation: "bottom"
        }), $(".timepicker").timepicker({
            template: !1,
            minuteStep: 15,
            showSeconds: !1,
            showMeridian: !1
        }), $(".enhance").each(function() {
            $(this).select2({
                theme: "bootstrap"
            });
        }), $(".trim-text").on("blur", function() {
            $(this).val($(this).val().trim());
        });
    }
    function initTooltipsAndHovers() {
        $(".tooltiplabel").each(function() {
            $(this).tooltip();
        });
    }
    patchBootstrapPopover(), $.event.add(window, "resize", adaptScrollableBox), $(document).ready(highlightCurrentSection), 
    $(document).ready(adaptScrollableBox), $(document).ready(initPickersAndWidgets), 
    $(document).ready(addHelpButtonToTextarea), $(document).ready(initTooltipsAndHovers);
}();